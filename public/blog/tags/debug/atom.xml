<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: debug | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/tags/debug/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2014-05-12T23:52:14+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C语言断言简介]]></title>
    <link href="http://ibillxia.github.io/blog/2011/05/03/introduce-to-assert-in-c-language/"/>
    <updated>2011-05-03T10:31:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2011/05/03/introduce-to-assert-in-c-language</id>
    <content type="html"><![CDATA[<h2>1.概述</h2>


<p> 断言是对某种假设条件进行检查（可理解为若条件成立则无动作，否则应报告），它可以快速发现并定位软件问题，
同时对系统错误进行自动报警。断言可以对在系统中隐藏很深，用其它手段极难发现的问题进行定位，从而缩短软件问题定位时间，
提高系统的可测性。实际应用时，可根据具体情况灵活地设计断言。</p>




<h2>2.标准断言机制</h2>


<p>原型定义：</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>include &lt;assert.h>&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>void assert( int expression_r_r_r );</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>assert的作用是现计算表达式 expression_r_r_r ，如果其值为假（即为0），
那么它先向stderr打印一条出错信息，然后通过调用 abort来终止程序运行。</p>




<!-- more -->


<h2>3.简单实例</h2>


<p>下面给一个断言的简单实例：</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>include &lt;stdio.h>&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>include &lt;assert.h>&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>include &lt;stdlib.h>&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>int main( void )&lt;br/>
</span><span class='line'>{&lt;br/>
</span><span class='line'>   FILE *fp;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>   fp = fopen( "test.txt", "w" );//以可写的方式打开一个文件，如果不存在就创建一个同名文件&lt;br/>
</span><span class='line'>   assert( fp );         //所以这里不会出错&lt;br/>
</span><span class='line'>   fclose( fp );&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>   fp = fopen( "noexitfile.txt", "r" );//以只读的方式打开一个文件，如果不存在就打开失败&lt;br/>
</span><span class='line'>   assert( fp );         //所以这里出错&lt;br/>
</span><span class='line'>   fclose( fp );         //程序永远都执行不到这里来&lt;br/>
</span><span class='line'>   return 0;&lt;br/>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>4.断言用法详解</h2>


<p>1)在函数开始处检验传入参数的合法性，如:</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int resetBufferSize(int nNewSize)
</span><span class='line'>{
</span><span class='line'>  //功能:改变缓冲区大小,
</span><span class='line'>  //参数:nNewSize 缓冲区新长度
</span><span class='line'>  //返回值:缓冲区当前长度
</span><span class='line'>  //说明:保持原信息内容不变，nNewSize&lt;=0表示清除缓冲区
</span><span class='line'>  assert(nNewSize >= 0);
</span><span class='line'>  assert(nNewSize &lt;= MAX_BUFFER_SIZE);
</span><span class='line'>  //...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>2)每个assert只检验一个条件,因为同时检验多个条件时,如果断言失败,无法直观的判断是哪个条件失败</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>assert(nOffset>=0 &amp;&amp; nOffset+nSize&lt;=m_nInfomationSize);  //不好
</span><span class='line'>assert(nOffset >= 0);   //好
</span><span class='line'>assert(nOffset+nSize &lt;= m_nInfomationSize);</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>3)不能使用改变环境的语句,因为assert只在DEBUG个生效,如果这么做,会使用程序在真正运行时遇到问题</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>assert(i++ &lt; 100);  //错误</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这是因为如果出错，比如在执行之前i=100,那么这条语句就不会执行，那么i++这条命令就没有执行。</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>assert(i &lt; 100);    //正确
</span><span class='line'>i++;</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>4)assert和后面的语句应空一行,以形成逻辑和视觉上的一致感</p>




<p>5)有的地方,assert不能代替条件过滤</p>




<h2>5注意事项：</h2>


<p>1).使用assert的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。
在调试结束后，可以通过在包含#include <assert.h>的语句之前插入 #define NDEBUG 来禁用assert调用，
示例代码如下：</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>include &lt;stdio.h>&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>define NDEBUG&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>include &lt;assert.h>&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>2).ASSERT只有在Debug版本中才有效，如果编译为Release版本则被忽略掉。（在C中，ASSERT是宏而不是函数），
使用ASSERT“断言”容易在debug时输出程序错误所在。而assert()的功能类似，它是ANSI C标准中规定的函数，
它与ASSERT的一个重要区别是可以用在Release版本中。</p>




<h3>推荐阅读</h3>


<p><a href="http://www.cppblog.com/oosky/archive/2006/03/26/4625.html#_Toc131314725">华为软件编程规范</a></p>
]]></content>
  </entry>
  
</feed>