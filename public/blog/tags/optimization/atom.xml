<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Optimization | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/tags/optimization/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2014-05-12T23:52:14+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++ 应用程序性能优化之 new/delete 操作符]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/11/cpp-program-optimization-new-delete-operator/"/>
    <updated>2014-05-11T20:33:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/11/cpp-program-optimization-new-delete-operator</id>
    <content type="html"><![CDATA[<h2>1.概述</h2>

<p>C++ 程序的存储空间可以分为静态/全局存储区、栈区和堆区。下图展示了一个典型的Linux C/C++ 程序内存空间布局：</p>

<center><img src="/images/2014/IMAG2014051101.png"></center>


<p>其中，每一部分的具体涵义如下：<br/>
- <strong>代码段（.text）</strong>：这里存放的是CPU要执行的指令。代码段是可共享的，相同的代码在内存中只会有一个拷贝，同时这个段是<strong>只读</strong>的，防止程序由于错误而修改自身的指令。<br/>
- <strong>初始化数据段（.data）</strong>：这里存放的是程序中需要明确赋初始值的变量，例如位于所有函数之外的全局变量：<code>int val=100;</code> 。 需要强调的是，以上两段都是位于程序的可执行文件中，内核在调用 exec 函数启动该程序时从源程序文件中读入。<br/>
- <strong>未初始化数据段（.bss）</strong>：位于这一段中的数据，内核在执行该程序前，将其初始化为0或者null。例如出现在任何函数之外的全局变量：<code>int sum;</code><br/>
- <strong>堆（Heap）</strong>：这个段用于在程序中进行动态内存申请，例如经常用到的 malloc，new 系列函数就是从这个段中申请内存。<br/>
- <strong>栈（Stack）</strong>：函数中的局部变量以及在函数调用过程中产生的临时变量都保存在此段中。<br/>
静态/全局存储区和栈区一般在程序编译阶段决定；而堆区则随着程序的运行而动态变化，每一次程序运行都会有不同的行为，因此动态内存管理对于一个程序在运行过程中占用的内存大小及程序运行性能有非常重要的影响。 本文主要探讨在C++中如何管理动态内存，以及如何使用 C++ 的语言特性来提高动态内存的管理效率，减少错误的发生。</p>

<!-- more -->


<h2>2. new/delete 操作符</h2>

<h4>2.1 C++内置new/delete的原型</h4>

<p>一般来说 C++ 的运行库提供了默认的全局 <code>new/new[]</code> 和 <code>delete/delete[]</code> 的实现，程序也可以用自定义的实现来取代运行库的实现。 下面是 C++ 标准中定义的 <code>new/new[]</code> 和 <code>delete/delete[]</code> 的声明（位于 <code>include/c++/new</code> 文件中）：</p>

<p>```
namespace std {
  class bad_alloc : public exception {</p>

<pre><code>public:
  bad_alloc() throw() { }
  virtual ~bad_alloc() throw();
  virtual const char* what() const throw();
</code></pre>

<p>  };
  struct nothrow_t { };
  extern const nothrow_t nothrow;
  typedef void (*new_handler)();
  new_handler set_new_handler(new_handler) throw();
} // namespace std</p>

<p>void<em> operator new(std::size_t) throw (std::bad_alloc);  // (1)
void</em> operator new<a href="std::size_t"></a> throw (std::bad_alloc);
void operator delete(void<em>) throw();
void operator delete<a href="void*"></a> throw();
void</em> operator new(std::size_t, const std::nothrow_t&amp;) throw();  // (2)
void<em> operator new<a href="std::size_t,%20const%20std::nothrow_t&amp;"></a> throw();
void operator delete(void</em>, const std::nothrow_t&amp;) throw();
void operator delete<a href="void*,%20const%20std::nothrow_t&amp;"></a> throw();
// Default placement versions of operator new.
inline void<em> operator new(std::size_t, void</em> <strong>p) throw() { return </strong>p; }  // (3)
inline void<em> operator new<a href="std::size_t,%20void*%20__p"></a> throw() { return __p; }
// Default placement versions of operator delete.
inline void  operator delete  (void</em>, void*) throw() { }
inline void  operator delete<a href="void*,%20void*"></a> throw() { }
```</p>

<p>其中最后的 <code>inline</code> 函数是 <code>placement</code> 版本的 new/delete 操作，其特点在于分配的内存块的起始地址由用户给定（通过参数 <code>void* __p</code>）。 而前面两种 <code>new/delete</code> （(1)和(2)处）是系统决定待分配内存块的起始地址，区别在于：第一个在分配失败是会抛出 <code>bad_alloc</code> 异常（这是C++标准要求的）；而第二个则不抛出异常，返回0。 很多应用程序都没有处理内存分配的失败情况，但相对于一个需要长期稳定运行的系统来说，这种处理是必不可少的。 应用程序可以通过捕获 <code>bad_alloc</code> 异常或者检查返回值来检查内存分配是否成功，而更好的方法是使用C++中的 <code>new_handler()</code> 函数。 C++规定 <code>new_handler</code> 要执行如下操作中的一种：</p>

<ul>
<li>使 <code>new</code> 有更多的内存可用，然后返回</li>
<li>抛出一个 <code>bad_alloc</code> 或其派生类的异常</li>
<li>调用 <code>abort()</code> 或者 <code>exit()</code> 退出</li>
</ul>


<h4>2.2 使用 <code>new_handler</code> 自定义异常处理</h4>

<p>下面看一个例子，看看如何使用 <code>new_handler</code> 处理内存分配失败的情况：</p>

<p>```</p>

<h1>include<new></h1>

<h1>include<cstdio></h1>

<h1>include&lt;Windows.h></h1>

<p>using namespace std;
char *gPool = NULL;
void my_new_handler();</p>

<p>int main(){</p>

<pre><code>set_new_handler(my_new_handler);
gPool = new char[512*1024*1024];
if(gPool!=NULL){
    printf("Preserve 512MB memory at %x.\n",gPool);
}
char *p = NULL;
for(int i=0;i&lt;4;i++){
    p = new char[512*1024*1024];
    printf("%d * 512M, p = %x\n",i+1,p);
    Sleep(5000); // 休眠5s
}
printf("Done.\n");
return 0;
</code></pre>

<p>}</p>

<p>void my_new_handler(){</p>

<pre><code>if(gPool!=NULL){
    printf("try to get more memory...\n");
    delete[] gPool; // 释放512MB内存空间
    gPool = NULL;
    return;
}else{
    printf("I can not help...\n");
    throw bad_alloc();  // 分配失败，抛出异常
}
return;
</code></pre>

<p>}
```</p>

<p>在 Windows 上编译并运行（使用Code::Blocks 13.12 IDE），得到如下输出：</p>

<p>```
Preserve 512MB memory at 7e0020.
1 * 512M, p = 207f0020
2 * 512M, p = 40800020
try to get more memory...
3 * 512M, p = 7e0020
I can not help...
terminate called after throwing an instance of 'std::bad_alloc'
  what():  std::bad_alloc</p>

<p>This application has requested the Runtime to terminate it in an unusual way.
Please contact the application's support team for more information.
```</p>

<p>在 Windows 的 win32 程序中，一个进程可以访问的内存空间是 4GB，但可以用来动态分配的最大内存是 2GB，因而上面的程序执行到第3次（为神马不是第4次？）动态内存分配时由于内存不够，调用了 <code>my_new_handler</code> 获得了内存（可以看到第3次分配的内存的地址和Preserve的内存地址是一样的），而当执行第4次内存分配时，<code>gPool</code> 已被分配，于是 <code>my_new_handler</code> 中抛出了 <code>bad_alloc</code> 异常，导致程序退出。 另外，在程序实际运行过程当中，会发现任务管理器中内存占用不会往上飙，这可能是因为操作系统的动态内存管理策略在作怪，不会说你一申请就立马全部给你，只是建立了一个映射表，只有当你真正用的时候才会给你。</p>

<h4>2.3 使用 placement new</h4>

<p>在 C++ 内置 <code>new/delete</code> 中最后的一种是 placement 形式的 <code>new/delete</code> ，即分配的内存地址有用户给定。下面是一个最简单的实例：</p>

<p>```</p>

<h1>include <cstdio></h1>

<h1>include <new></h1>

<p>using namespace std;</p>

<p>int main()
{</p>

<pre><code>char buffer[100];
char *p = new(buffer) char[20]; // call placement new
printf("Address of buffer: %x, and p: %x.\n",buffer,p);
return 0;
</code></pre>

<p>}
// output: Address of buffer: 28feb8, and p: 28feb8.
```</p>

<p>可以看到 <code>buffer</code> 和 <code>p</code> 的地址是一样的。在大型应用程序中，我们可以充分利用 <code>placement new</code> 的特性，实现自己管理（分配、释放等）本应用的内存空间，基本思路就是： 首先申请一大片内存，然后对每个小的动态内存分配都使用 <code>placement new</code> 的方式进行申请。</p>

<h4>2.4 重载 placement new</h4>

<p>在 <code>new</code> 操作符中，除了可以使用自定义申请的内存的大小及位置，我们还可以通过重载系统的 <code>new/delete</code> 操作符来加入其它一些附加参数，但仍称之为 <code>placement new</code> 。例如：</p>

<p>```</p>

<h1>include<cstdio></h1>

<h1>include<new></h1>

<p>using namespace std;</p>

<h1>define DEBUG</h1>

<h1>ifdef DEBUG</h1>

<p>// 自定义 new 操作符
void *operator new<a href="unsigned%20int%20n,%20const%20char*%20file,%20int%20line"></a>{</p>

<pre><code>printf("Alloc size: %d at file %s, in line %d\n",n,file,line);
return ::operator new(n);
</code></pre>

<p>}
// 自定义 delete 操作符
void operator delete<a href="void%20*p,const%20char%20*file,%20int%20line"></a>{</p>

<pre><code>printf("delete at file %s, in line %d\n",file,line);
::operator delete(p);
return;
</code></pre>

<p>}
// 宏定义，必须放在重载函数之后</p>

<h1>define new new(<strong>FILE</strong>, <strong>LINE</strong>)</h1>

<p>//#define delete delete(<strong>FILE</strong>, <strong>LINE</strong>)</p>

<h1>endif</h1>

<p>int main(){</p>

<pre><code>char *p = new char[10];
delete p;  // delete 的重载还有问题 "error: type 'int' argument given to 'delete', expected pointer"
return 0;
</code></pre>

<p>}
// output: Alloc size: 10 at file D:\Programs\test\main.cpp, in line 22
```</p>

<p>这在 <code>DEBUG</code> 模式下非常好使。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[凸优化简介]]></title>
    <link href="http://ibillxia.github.io/blog/2012/09/26/convex-optimization-overview/"/>
    <updated>2012-09-26T23:03:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2012/09/26/convex-optimization-overview</id>
    <content type="html"><![CDATA[<p>在machine learning 的很多问题中，我们最终往往要求解某个函数的最优值。用数学术语表示就是，
给定一个函数 $f: R<sup>{n}</sup> \rightarrow R$，求 $ x \in R<sup>{n}</sup> $使得$f(x)$ 取得最小（大）值。例如least-square,
logistic regression, linear regression, svm, etc. 这类问题统称为优化问题。</p>

<h2>1.引言</h2>


<p>在一般情况下，求解任意一个函数的全局最优值是很困难的。但是对于一种特定类型的函数——凸函数（convex function），
我们可以很有效的求解其全局最优值。这里的“有效”是指在实际问题求解中，能在多项式复杂度的时间里求解。
人们将这类函数的最值问题称为凸优化问题（Convex Optimal Problem）。下面我从凸集和凸函数讲起，然后
介绍凸优化的一般描述和典型问题举例。</p>




<h2>2.凸集及其实例</h2>


<p><strong>凸集的定义</strong>：一个集合$C$是凸集，当且仅当对任意$x,y\in C$和$\theta \in R$且$0\leq \theta \leq 1$，都有</br>
<center>$\theta x + (1-\theta)y \in C$.</center>
其几何意义在于，在集合C中任取两个点，连接两点的直线段上的任一点也在集合C中。下图是凸集和非凸集的例子：</br>
<img src="/images/201209026/IMAG20120902601.jpg">
</p>




<!-- more -->


<p><strong>凸集的实例</strong>：
以下列举几个简单的凸集实例</br>
（1）所有Rn。很显然，对任意给定的$x,y\in R^{n}$ 都有 $\theta x + (1-\theta)y \in R^{n}$。
（2）非负卦限，R^{n}_{+}。很显然也符合定义。</br>
（3）单位球。设$\parallel . \parallel$为$R^{n}$上的模（例如欧几里得空间的模为$\parallel x\parallel = sqrt(sum(x_{i}^{2}))$.）,
那么集合${x|\parallel x\parallel \leq 1}$是一个凸集。
</p>




<h2>3.凸函数及判定和Jensen不等式</h2>


<p>凸优化中的一个核心概念就是凸函数。</br>
<strong>凸函数定义</strong>：一个函数$f: R^{n} → R$是凸函数当且仅当其定义域（设为$D(f)$）是凸集，
且对任意的$x,y\in D(f)$和$\theta \in R$且$0\leq \theta \leq 1$，都有</br>
<center>$f(\theta x + (1-\theta)y \leq \theta f(x) + (1-\theta) f(y))$.</center>
设$f(x)$为一元函数，那么上式的几何意义在于，曲线上任意两点处的割线在函数曲线的上方，如下图所示：</br>
<img src="/images/2012/IMAG20120902602.jpg">
</p>




<p>常见的凸函数有指数函数（$f(x) = a^{x}，a>1$）、负对数函数（$f(x)=-log_{a}x，a>1，x>0$）、开口向上的二次函数等。</p>




<p><strong>凸函数第一判定定理</strong>：设函数$f: R^{n} → R$是一阶可导的，那么$f$是凸函数当且仅当对任意的$x,y \in D(f)$都有：
<center>$f(y) \geq f(x) + f'(x)(y-x)$</center>
其中$f(x) + f'(x)(y-x)$称为$f(x)$在$x$处的一阶近似。</p>




<p><strong>凸函数第二判定定理</strong>：设函数$f: R^{n} → R$是二阶可导的，那么$f$是凸函数当且仅当对任意的$x\in D(f)$都有：</p>


<center>$f''(x)  \succeq 0$.</center>


<p>其中，当$f''(x)$是矩阵时，符号‘$ \succeq $’表示半正定，而非一个个的不等式（在一维的情况下，相当于'$\geq$'；
在二维情况下，不是表示对所有的$i$和$j$都有$X_{ij} \geq 0$，而是表示$X$为半正定矩阵）。
</p></p>

<p><strong>Jensen不等式</strong>：我们先看凸函数的定义中的不等式:</br>
<center>$f(\theta x+(1-\theta y)) \leq \theta f(x) + (1-\theta)f(y), for 0\leq \theta \leq 1$.</center>
类似的可以将其推广到多个点的情况：</br>
<center>$f(\sum_{i=1}^{k}\theta_{i}x_{i}) \leq \sum_{i=1}{k}\theta_{i}f(x_{i}), for \sum_{i=1}^{k}\theta_{i} = 1, \theta_{i} \geq 0 \forall i$.</center>
因为上式中的和为1，可以将其看作为是概率密度，则上式又可写为：</br>
<center>$f(E[x]) \leq E[f(x)]$.</center>
这个不等式称为Jensen不等式。
</p>




<h2>4.凸优化问题举例</h2>


<p>有了凸集和凸函数的定义，现在我们重点讨论凸优化问题的求解方法。凸优化的一般描述为：</br>
<center>$minimize f(x)$,</center>
<center>$subject to x \in C$.</center>
其中$f(x)$为凸函数，$C$是一个凸集，这是不带约束条件的情况下的凸优化问题。对于带约束条件的问题而言，其一般描述为：</br>
<center>$minimize f(x)$,</center>
<center>$subject to g_{i}(x) \leq 0, i=1,2,...,m; h_{j}(x) = 0, j=1,2,...,p$.</center>
其中$f(x)$为凸函数，$g_{i}(x)$对所有的$i$均为凸函数，$h_{j}(x)$均为仿射函数。注意$g_{i}(x)$不等式中不等号的方向。
</p>




<p>凸问题中的全局优化：首先要分清楚什么是局部最优，什么是全局最优。局部最优是指在该最优值附近的点对应的函数值
都比该最优值大，而全局最优是指对可行域里所有点，其函数值都比该最优值大。对于凸优化问题，它具有一个很重要的特性，
那就是所有的局部最优值都是全局最优的（关于其证明这里就不讲了，感兴趣的可以自行查查资料或后文中的参考文献）。</p>




<h4>几类特殊的凸优化问题：</h4>


<p>（1）线性规划（Linear Programing, LP）: 目标函数和约束条件函数都是线性函数的情况，一般形式如下：</br>
<center>$minimize c^{T}x +d$,</center>
<center>$subject to Gx \preceq h; Ax = b$.</center>
</p>




<p>（2）二次规划（Quadratic Programing, QP）: 目标函数为二次函数，约束条件为线性函数，一般形式为：</br>
<center>$minimize 1/2 x^{T}Px + c^{T}x +d$,</center>
<center>$subject to Gx \preceq h; Ax = b$.</center>
LP可以看做是QP的特例，QP包含LP。
</p>




<p>（3）二次约束的二次规划（Quadratically Constrained Quadratic Programming, QCQP）: 目标函数和约束条件均为
二次函数的情况，一般形式为：</br>
<center>$minimize 1/2 x^{T}Px + c^{T}x +d$,</center>
<center>$subject to 1/2 x^{T}Qx + r^{T}x + s \preceq h, i=1,2,...,m; Ax = b$.</center>
QP可以看做是QCQP的特例，QCQP包含QP。
</p>




<p>半正定规划（Semideﬁnite Programming，SDP）: 其一般形式为：</br>
<center>$minimize tr(CX)$,</center>
<center>$subject to tr(A_{i}X) = b_{i},i=1,2,...,p; 0 \preceq X$.</center>
其中对称矩阵$X\inS^{n}$为决策变量，矩阵$C$，$A_{i}$均为对称矩阵，条件$0 \preceq X$的作用为约束$X$为半正定的。
QCQP可以看做是SDP的特例，SDP包含QCQP。SDP在machine learning中有非常广泛的应用。
</p>




<h2>5.凸优化应用举例</h2>


<p>下面我们来看几个实例。</br>
（1）支持向量机（Support Vector Machines，SVM）：凸优化在machine learning中的一个典型的应用就是基于支持向量机分类器，
它可以用如下优化问题表示：</br>
<center>$minimize 1/2 \parallel x \parallel ^{2} + C \xi _{i}$,</center>
<center>$subject to y^{(i)}(w^{T}x^{(i)}+b) \geq 1 - \xi _{i}, \xi_{i} \geq 0, i = 1,2,...,m$.</center>
其中决策变量$w\in R^{n}, \xi \in R^{n}, b \in R$. $C\in R, x(i), y(i), i=1,2, ... , m$由
具体问题定义。可以看出，这是一个典型的QP问题。
</p>




<p>（2）带约束的least squares问题：其一般描述为</br>
<center>$minimize 1/2\parallel Ax-b \parallel ^{2} $,</center>
<center>$subject to l \preceq x \preceq u$.</center>
这也是一个很典型的QP问题。
</p>




<p>（3）Maximum Likelihood for Logistic Regression：该问题的目标函数为:</br>
<center>$l (\theta) = \sum_{i=1}^{n}[y^{(i)}ln g(\theta^{T}x^{(i)}) + (1-y^{(i)})ln(1-g(\theta^{T}x^{(i)}))]$</center>
其中$g(z)$为Sigmoid函数，关于Logistic Regression请参见Andrew Ng的Machine Learning的第6讲。
</p>




<h2>6.凸优化问题求解简介</h2>


<p>上文中提到了几类特殊的凸优化问题，并举了几个应用实例，但并没有给出解法。对于凸优化问题，目前没有一个通用的解析式的
解决方案，但是我们仍然可以用非解析的方法来有效的求解很多问题。内点法（后续文章中会详细介绍）被证明是很好的解决方案，
特别具有实用性，在某些问题中，能够在多项式时间复杂度下，将解精确到指定精度。</p>




<p>我们将会看到，经过10到100次的迭代，内点法可以解决一般的凸优化问题，其中每次迭代的时间复杂度为</br>
<center>$max{n^{3},n^{2}m,F}$.</center>
其中$F$为计算目标函数和约束条件函数的一阶、二阶导数的总时间代价。如同用解析法求解线性规划问题，内点法也是非常可靠的，
在一般的PC机上，它可以在几十秒的时间内求解含有上百个变量、上千个约束条件的凸优化问题。对于一些特殊的结构（如稀疏的），
内点法可以求解包含上千个变量和约束条件的凸优化问题。
</p>




<p>对于一般的凸优化问题的求解，还没有像求解最小二乘和线性规划那么成熟的技术，基于内点法的一般凸优化问题求解依然是
当前的一个研究热点。虽然目前还没有公认的最好的解决方案，但我们有理由相信，在不久的将来，内点法求解一般的凸优化问题
是一项技术。事实上，对于一些特定的凸优化问题，如二次锥规划和几何规划问题（后续文章将会介绍），内点法在向一项技术迈进。</p>




<h2>参考文献</h2>


<p>
[1]Book: Stephen Boyd and Lieven Vandenberghe. Convex Optimization. Cambridge University Press, 2004</br>
[2]Slide: Zico Kolter (updated by Honglak Lee). Convex Optimization Overview. October 17, 2008</br>
[3]Standford Convex Optimization Course I：http://www.stanford.edu/class/ee364a/lectures.html
</p>



]]></content>
  </entry>
  
</feed>