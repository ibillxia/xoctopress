<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Technics | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/categories/technics/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2014-01-05T22:59:51+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[2013IDF声龙语音识别技术演示]]></title>
    <link href="http://ibillxia.github.io/blog/2013/04/10/Intel-Developer-Forum-2013-Nuance-Dragon-Presentation/"/>
    <updated>2013-04-10T12:57:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/04/10/Intel-Developer-Forum-2013-Nuance-Dragon-Presentation</id>
    <content type="html"><![CDATA[<p>2013英特尔信息技术峰会(Intel Developer Forum, IDF)上，来自Nuance的声龙语音合成和识别技术的演示，中文语音识别不给力，
笑点频出啊，哈哈</p>




<p><iframe height=560 width=780 src="http://player.youku.com/embed/XNTQwNjQ0MjUy" frameborder=0 allowfullscreen></iframe></p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EFI和操作系统]]></title>
    <link href="http://ibillxia.github.io/blog/2012/09/23/EFI-and-operating-system/"/>
    <updated>2012-09-23T23:03:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2012/09/23/EFI-and-operating-system</id>
    <content type="html"><![CDATA[<p>前两天在98上看到一个帖子 windows 8 没法和linux共存？ 里面有一个概念就是EFI</p>

<h2>什么是EFI？</h2>


<p>EFI英文全称为Extensible Firmware Interface，中文译为可扩展固件接口，其主要目的是为了提供一组在 OS 加载之前（启动前）在
所有平台上一致的、正确指定的启动服务。EFI最初由Intel开发，并在2002年12月所发布1.1版，后来在2005年Intel将此规范交由UEFI论坛
来推广与发展，并更名为Unified EFI(UEFI)。</p>




<p>EFI是一种个人电脑系统规格，用来定义操作系统与系统固件之间的软件界面，为替代BIOS的升级方案。可扩展固件接口（EFI）负责
加电自检（POST）、连系操作系统以及提供连接操作系统与硬件的接口。UEFI在EFI基础上增加与改进了加密编码（cryptography）、
网络认证（network authentication）与用户界面架构（User Interface Architecture）等方面的内容。EFI在软件层次中的位置如下图</br>
<img src="/images/2012/IMAG2012092301.png">
</p>




<!-- more -->


<h2>为什么有EFI？</h2>


<p>EFI技术源于英特尔安腾处理器（Itanium）平台的推出。安腾处理器是英特尔瞄准服务器高端市场投入近十年研发力量设计产生的
与x86系列完全不同的64位新架构。在x86系列处理器进入32位的时代，由于兼容性的原因，新的处理器(80386)保留了16位的运行方式(实模式)，
此后多次处理器的升级换代都保留了这种运行方式。甚至在含64位扩展技术的至强系列处理器中，处理器加电启动时仍然会切换到16位的
实模式下运行。英特尔将这种情况归咎于BIOS技术的发展缓慢。</p>




<p>为什么这么说呢？因为自从PC兼容机厂商通过净室的方式复制出第一套BIOS源程序，BIOS就以16位汇编代码，寄存器参数调用方式，
静态链接，以及1MB以下内存固定编址的形式存在了十几年。虽然由于各大BIOS厂商近年来的努力，有许多新元素添加到产品中，
如PnP BIOS，ACPI，传统USB设备支持等等，但BIOS的根本性质没有得到任何改变。这迫使英特尔在开发新的处理器时，都必须考虑加进
使性能大大降低的兼容模式。有人曾打了一个比喻：这就像保时捷新一代的全自排跑车，被人套上去一个蹩脚打档器。正是在这种背景下，
Intel发展了EFI技术。</p>




<h2>EFI与操作系统又有什么关系呢？</h2>


<p>上文提到EFI是BIOS的升级版，那么EFI与OS的关系是不是也和BIOS与OS的关系一样呢？</br>
要回答这个问题，我们首先得将EFI与BIOS进行一个详细的比较：</br>
（1）EFI运行于32位或64位模式，突破传统的BIOS的16位实模式，达到处理器的最大寻址；</br>
（2）EFI利用加载驱动的形式，识别及操作硬件，不同于BIOS利用挂载真实模式中断的方式增加硬件功能；</br>
（3）EFI大部分（99%）是用模块化的C语言编写的，较BIOS而言更易于实现，容错和纠错特性更强，更易于扩展；</br>
（4）EFI系统下的驱动并不是由可以直接运行在CPU上的代码组成的，而是用EFI Byte Code编写而成的（有点像Java
的Byte Code），这是一组专用于EFI驱动的虚拟机器语言，必须在EFI驱动运行环境（Driver Execution Environment，或DXE）
下被解释运行，这就保证了充分的向下兼容性；</br>
（5）UEFI内置图形驱动功能，可以提供一个高分辨率的彩色图形环境，用户进入后能用鼠标点击调整配置，一切就像操作Windows
系统下的应用软件一样简单。BIOS将不再是高手才能玩转的工具，光这一点就足以让很多菜鸟朋友心仪不已了。</br>
（6）强大的可扩展性是UEFI的另一大优点。我们都知道，当电脑出现故障导致无法进入操作系统时，我们往往要借助其他工具才能
解决问题，BIOS在诊断系统故障方面的作用实是在太小了。不过，UEFI将不会重蹈BIOS功能单一的覆辙！UEFI使用模块化设计，它在
逻辑上分为硬件控制与OS（操作系统）软件管理两部分，硬件控制为所有UEFI版本所共有，而OS软件管理其实是一个可编程的开放接口。
借助这个接口，主板厂商可以实现各种丰富的功能。比如我们熟悉的各种备份及诊断功能可通过UEFI加以实现，主板或固件厂商可以
将它们作为自身产品的一大卖点。如果你更习惯让别人来维护机器，UEFI也可提供强大的联网功能，其他用户可以对你的主机进行
可靠的远程故障诊断，而这一切并不需要进入操作系统！
</p>




<p>由以上比较可知，EFI在开机时的作用和BIOS一样，就是初始化PC，但在细节上却有很多不一样。BIOS对PC的初始化，只是按照
一定的顺序对硬件通电，简单地检查硬件是否能工作，而EFI不但检查硬件的完好性，还会加载硬件在EFI中的驱动程序，不用操作
系统负责驱动的加载工作。 对于很多非专业人士而言，EFI的最革命之处，就在于颠 覆了BIOS的界面概念，让操作界面和Windows
一样易于上手。在EFI的操作界面中，鼠标成为了替代键盘的输入工具，各功能调节的模块也做的和Windows程序一样，可以说，EFI
就是一个小型化的Windows系统。</p>




<p>说EFI是一个小型化的Windows系统，毫不夸张。EFI在概念上非常类似于一个低阶的操作系统，并且具有操控所有硬件资源的能力。
不少人感觉它的不断发展将有可能代替现代的操作系统。事实上，EFI的缔造者们在第一版规范出台时就将EFI的能力限制于不足以
威胁操作系统的统治地位。首先，它只是硬件和预启动软件间的接口规范；其次，EFI环境下不提供中断的机制，也就是说每个EFI
驱动程序必须用轮询(polling)的方式来检查硬件状态，并且需要以解释的方式运行，较操作系统下的机械码驱动效率更低；再则，
EFI系统不提供复杂的缓存器保护功能，它只具备简单的缓存器管理机制，具体来说就是指运行在x86处理器的段保护模式下，以最大
寻址能力为限把缓存器分为一个平坦的段(Segment)，所有的程序都有权限访问任何一段位置，并不提供真实的保护服务。当EFI所有
组件加载完毕时，系统可以开启一个类似于操作系统Shell的命令解释环境，在这里，用户可以调入执行任何EFI应用程序，这些程序
可以是硬件检测及除错软件，引导管理，设置软件，操作系统引导软件等等。理论上来说，对于EFI应用程序的功能并没有任何限制，
任何人都可以编写这类软件，并且效果较以前MS-DOS下的软件更华丽，功能更强大。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[伪造IP地址的原理]]></title>
    <link href="http://ibillxia.github.io/blog/2010/08/31/the-elements-of-ip-faking/"/>
    <updated>2010-08-31T09:41:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2010/08/31/the-elements-of-ip-faking</id>
    <content type="html"><![CDATA[<p>入侵者使用假IP地址发送包，利用基于IP地址证实的应用程序。其结果是未授权的远端用户进入带有防火墙的主机系统。</p>




<p>假设有两台主机A、B和入侵者控制的主机X。假设B授予A某些特权，使得A能够获得B所执行的一些操作。X的目标就是得到与B相同的权利。
为了实现该目标，X必须执行两步操作：首先，与B建立一个虚假连接；然后，阻止A向B报告网络证实系统的问题。主机X必须假造A的IP地址，
从而使B相信从X发来的包的确是从A发来的。</p>




<p>我们同时假设主机A和B之间的通信遵守TCP／IP的三次握手机制。握手方法是：</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>A->：SYN（序列号=M）
</span><span class='line'>B->A：SYN（序列号＝N），ACK（应答序号=M+1）
</span><span class='line'>A->B：ACK（应答序号＝N+1）</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<!--more-->


<p>主机X伪造IP地址步骤如下：首先，X冒充A，向主机B发送一个带有随机序列号的SYN包。主机B响应，向主机A发送一个带有应答号的SYN+ACK包、
该应答号等于原序列号加1。同时，主机B产生自己发送包序列号，并将其与应答号一起发送。为了完成三次握手，主机X需要向主</p>




<p>机B回送一个应答包，其应答号等于主机B向主机A发送的包序列号加1。假设主机X与A和B不同在一个子网内，则不能检测到B的包，
主机X只有算出B的序列号，才能创建TCP连接。其过程描述如下：</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>X->B：SYN（序列号=M），SRC=A
</span><span class='line'>B->A：SYN（序列号=N），ACK（应答号=M+1）
</span><span class='line'>X->B：ACK（应答号＝N+1），SRC＝A</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>同时，主机X应该阻止主机A响应主机B的包。为此，X可以等到主机A因某种原因终止运行，或者阻塞主机A的操作系统协议部分，使它不能响应主机B。
一旦主机X完成了以上操作，它就可以向主机B发送命令。主机B将执行这些命令，认为他们是由合法主机A发来的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UTF8中文编码范围]]></title>
    <link href="http://ibillxia.github.io/blog/2010/08/21/utf8-chinese-coding/"/>
    <updated>2010-08-21T10:31:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2010/08/21/utf8-chinese-coding</id>
    <content type="html"><![CDATA[<p>UTF-8有点类似于Haffman编码，它将Unicode编码为： </br>
00000000-0000007F的字符，用单个字节来表示； </br>
00000080-000007FF的字符用两个字节表示 （中文的编码范围） </br>
00000800-0000FFFF的字符用3字节表示</br>
编码转换：iconv -f “文件目前编码” -t “文件转换后的编码” -o “转换后生成的新文件名” “源文件名”temp = Iconv.conv("UTF-8","gb2312",a) </p>




<p>因为目前为止Unicode-16规范没有指定FFFF以上的字符，所以UTF-8最多是使用3个字节来表示一个字符。但理论上来说，UTF-8最多需要用6字节表示一个字符。 
在UTF-8里，英文字符仍然跟ASCII编码一样，因此原先的函数库可以继续使用。而中文的编码范围是在0080-07FF之间，因此是2个字节表示（但这两个字节
和GB编码的两个字节是不同的）。 </p>


<!--more-->


<h2>big endian和little endian</h2>


<p>我们一般将endian翻译成“字节序”，将big endian和little endian称作“大尾”和“小尾”。</p>




<p>“endian”这个词出自《格列佛游记》。小人国的内战就源于吃鸡蛋时是究竟从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开，
由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。</p>




<p>big endian和little endian是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C写在前面，
还是将49写在前面？如果将6C写在前面，就是big endian。而如果将49写在前面，就是little endian。</p>




<h2>UTF编码</h2>


<p>UTF-8就是以8位为单元对UCS进行编码。从UCS-2到UTF-8的编码方式如下：</br>

UCS-2编码(16进制) UTF-8 字节流(二进制)</br>
0000 - 007F 0xxxxxxx</br>
0080 - 07FF 110xxxxx 10xxxxxx</br>
0800 - FFFF 1110xxxx 10xxxxxx 10xxxxxx </p>




<p>例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。
将6C49写成二进制是：0110 110001 001001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。</p>




<p>读者可以用记事本测试一下我们的编码是否正确。</p>




<p>UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，
定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。
但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。</p>




<h2>UTF的字节序和BOM</h2>


<p>UTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。
例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？</p>




<p>Unicode规范中推荐的标记字节顺序的方法是BOM。BOM不是“Bill Of Material”的BOM表，而是Byte Order Mark。BOM是一个有点小聪明的想法：</br>

在UCS编码中有一个叫做"ZERO WIDTH NO-BREAK SPACE"的字符，它的编码是FEFF。
而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。</br>
UCS规范建议我们在传输字节流前，先传输字符"ZERO WIDTH NO-BREAK SPACE"。</p>




<p>这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。
因此字符"ZERO WIDTH NO-BREAK SPACE"又被称作BOM。</p>




<p>UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符"ZERO WIDTH NO-BREAK SPACE"的UTF-8编码是EF BB BF（读者
可以用我们前面介绍的编码方法验证一下）。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。</p>




<p>Windows就是使用BOM来标记文本文件的编码方式的。</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开源网络爬虫介绍及其比较]]></title>
    <link href="http://ibillxia.github.io/blog/2010/08/20/several-open-source-web-crawlers-comparing/"/>
    <updated>2010-08-20T18:53:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2010/08/20/several-open-source-web-crawlers-comparing</id>
    <content type="html"><![CDATA[<h2>主流的爬虫</h2>


<p><strong>Nutch</strong></br>
开发语言：Java</br>
主页：<a href="http://lucene.apache.org/nutch/">http://lucene.apache.org/nutch/</a></br>
简介：</br>
Apache的子项目之一，属于Lucene项目下的子项目。</br>
Nutch是一个基于Lucene，类似Google的完整网络搜索引擎解决方案，基于Hadoop的分布式处理模型保证了系统的性能，类似Eclipse的插件机制
保证了系统的可客户化，而且很容易集成到自己的应用之中。
</p>


<!--more-->


<p><strong>Larbin</strong></br>
开发语言：C++</br>
主页：<a href="http://larbin.sourceforge.net/index-eng.html">http://larbin.sourceforge.net</a></br>
简介：</br>
larbin是一种开源的网络爬虫/网络蜘蛛，由法国的年轻人 Sébastien Ailleret独立开发。larbin目的是能够跟踪页面的url进行扩展的抓取，
最后为搜索引擎提供广泛的数据来源。</br>
Larbin只是一个爬虫，也就是说larbin只抓取网页，至于如何parse的事情则由用户自己完成。另外，如何存储到数据库以及建立索引的事情 larbin也不提供。</br>

latbin最初的设计也是依据设计简单但是高度可配置性的原则，因此我们可以看到，一个简单的larbin的爬虫可以每天获取５００万的网页，非常高效。
</p>




<p><strong>Heritrix</strong></br>
开发语言：Java</br>
主页：<a href="http://crawler.archive.org/">http://crawler.archive.org/</a></br>
与Nutch比较：</br>
二者均为Java开源框架，Heritrix是 SourceForge上的开源产品，Nutch为Apache的一个子项目，它们都称作网络爬虫/蜘蛛（ Web Crawler），
它们实现的原理基本一致：深度遍历网站的资源，将这些资源抓取到本地，使用的方法都是分析网站每一个有效的URI，并提交Http请求，
从而获得相应结果，生成本地文件及相应的日志信息等。</br>
Heritrix 是个 "archival crawler" -- 用来获取完整的、精确的、站点内容的深度复制。包括获取图像以及其他非文本内容。抓取并存储相关的内容。
对内容来者不拒，不对页面进行内容上的修改。重新爬行对相同的URL不针对先前的进行替换。爬虫通过Web用户界面启动、监控、调整，允许弹性的
定义要获取的URL。</br></br>
二者的差异：</br>
Nutch 只获取并保存可索引的内容。Heritrix则是照单全收。力求保存页面原貌。</br>
Nutch 可以修剪内容，或者对内容格式进行转换。</br>
Nutch 保存内容为数据库优化格式便于以后索引；刷新替换旧的内容。而Heritrix 是添加(追加)新的内容。</br>
Nutch 从命令行运行、控制。Heritrix 有 Web 控制管理界面。</br>
Nutch 的定制能力不够强，不过现在已经有了一定改进。Heritrix 可控制的参数更多。</br>
Heritrix提供的功能没有nutch多，有点整站下载的味道。既没有索引又没有解析，甚至对于重复爬取URL都处理不是很好。</br>
Heritrix的功能强大，但是配置起来却有点麻烦。
</p>




<h2>其他的爬虫</h2>


<p><strong>WebLech</strong></br>
<a href="http://weblech.sourceforge.net/">http://weblech.sourceforge.net/</a></br>
WebLech是一个功能强大的Web站点下载与镜像工具。它支持按功能需求来下载web站点并能够尽可能模仿标准Web浏览器的行为。
WebLech有一个功能控制台并采用多线程操作。
</p>




<p><strong>Arale</strong></br>
<a href="http://web.tiscali.it/_flat/arale.jsp.html">http://web.tiscali.it/_flat/arale.jsp.html</a></br>
Arale主要为个人使用而设计，而没有像其它爬虫一样是关注于页面索引。Arale能够下载整个web站点或来自web站点的某些资源。
Arale还能够把动态页面映射成静态页面。
</p>




<p><strong>J-Spider</strong></br>
<a href="http://j-spider.sourceforge.net/">http://j-spider.sourceforge.net/</a></br>
J-Spider:是一个完全可配置和定制的Web Spider引擎.你可以利用它来检查网站的错误(内在的服务器错误等),网站内外部链接检查，
分析网站的结构(可创建一个网站地图),下载整个Web站点，你还可以写一个JSpider插件来扩展你所需要的功能。
</p>




<p><strong>Spindle</strong></br>
<a href="http://www.bitmechanic.com/projects/spindle/">http://www.bitmechanic.com/projects/spindle/</a></br>
spindle 是一个构建在Lucene工具包之上的Web索引/搜索工具.它包括一个用于创建索引的HTTP spider和一个用于搜索这些索引的搜索类。
spindle项目提供了一组JSP标签库使得那些基于JSP的站点不需要开发任何Java类就能够增加搜索功能。
</p>




<p><strong>Arachnid</strong></br>
<a href="http://arachnid.sourceforge.net/">http://arachnid.sourceforge.net/</a></br>
Arachnid: 是一个基于Java的web spider框架.它包含一个简单的HTML剖析器能够分析包含HTML内容的输入流.通过实现Arachnid的子类就能够
开发一个简单的Web spiders并能够在Web站上的每个页面被解析之后增加几行代码调用。 Arachnid的下载包中包含两个spider应用程序例子
用于演示如何使用该框架。
</p>




<p><strong>LARM</strong></br>
<a href="http://larm.sourceforge.net/">http://larm.sourceforge.net/</a></br>
LARM能够为Jakarta Lucene搜索引擎框架的用户提供一个纯Java的搜索解决方案。它包含能够为文件，数据库表格建立索引的方法和为Web站点建索引的爬虫。
</p>




<p><strong>JoBo</strong></br>
<a href="http://www.matuschek.net/software/jobo/index.html">http://www.matuschek.net/software/jobo/index.html</a></br>
JoBo 是一个用于下载整个Web站点的简单工具。它本质是一个Web Spider。与其它下载工具相比较它的主要优势是能够自动填充form(如：自动登录)和
使用cookies来处理session。JoBo还有灵活的下载规则(如：通过网页的URL，大小，MIME类型等)来限制下载。
</p>




<p><strong>snoics-reptile</strong></br>
<a href="http://www.blogjava.net/snoics">http://www.blogjava.net/snoics</a></br>
snoics -reptile是用纯Java开发的，用来进行网站镜像抓取的工具，可以使用配制文件中提供的URL入口，把这个网站所有的能用浏览器通过GET的方式
获取到的资源全部抓取到本地，包括网页和各种类型的文件，如：图片、flash、mp3、zip、rar、exe等文件。可以将整个网站完整地下传至硬盘内，
并能保持原有的网站结构精确不变。只需要把抓取下来的网站放到web服务器(如：Apache)中，就可以实现完整的网站镜像。
</p>




<p><strong>Web-Harvest</strong></br>
<a href="http://web-harvest.sourceforge.net">http://web-harvest.sourceforge.net</a></br>
Web-Harvest 是一个Java开源Web数据抽取工具。它能够收集指定的Web页面并从这些页面中提取有用的数据。Web-Harvest主要是运用了像XSLT,
XQuery,正则表达式等这些技术来实现对text/xml的操作。
</p>




<p><strong>Spiderpy</strong></br>
<a href="http://pyspider.sourceforge.net/">http://pyspider.sourceforge.net/</a></br>
spiderpy是一个基于Python编码的一个开源web爬虫工具，允许用户收集文件和搜索网站，并有一个可配置的界面。
</p>




<p><strong>The Spider Web Network Xoops Mod Team</strong></br>
<a href="http://www.tswn.com/">http://www.tswn.com/</a></br>
pider Web Network Xoops Mod是一个Xoops下的模块，完全由PHP语言实现。
</p>




<p><strong>HiSpider</strong></br>
<a href="https://code.google.com/p/hispider/">https://code.google.com/p/hispider/</a></br>
Hispider is a fast and high performance spider with high speed</br>
严格说只能是一个spider系统的框架, 没有细化需求, 目前只是能提取URL, URL排重, 异步DNS解析, 队列化任务, 支持N机分布式下载, 
支持网站定向下载(需要配置hispiderd.ini whitelist).</br></br>
特征和用法:</br>
基于unix/linux系统的开发</br>
异步DNS解析</br>
URL排重</br>
支持HTTP 压缩编码传输 gzip/deflate</br>
字符集判断自动转换成UTF-8编码</br>
文档压缩存储</br>
支持多下载节点分...
</p>



]]></content>
  </entry>
  
</feed>
