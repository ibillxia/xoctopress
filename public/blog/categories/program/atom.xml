<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Program | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/categories/program/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2014-04-28T23:12:20+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[给Octopress博客配置Twitter Bootstrap主题]]></title>
    <link href="http://ibillxia.github.io/blog/2014/04/28/configure-twitter-bootstrap-theme-in-octopress/"/>
    <updated>2014-04-28T22:37:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/04/28/configure-twitter-bootstrap-theme-in-octopress</id>
    <content type="html"><![CDATA[<p>很长一段时间以来就看到各种基于 Twitter Bootstrap 主题的博客很清爽，而且对 Tag 的归档也做得很赞，于是很想将自己的博客也换成 Bootstrap 的主题，随着看到的博客越来越多，自己的 Octopress 主题先得越来越臃肿，而 Tags 归档功能也相形见绌，更换主题的欲望越来越强烈了。于是乎，趁这个周末捣鼓了一番，最终大功告成，在这里分享一下具体过程。</p>

<h2>Bootstrap 主题的安装</h2>

<p>首先下载适用于 Octopress 的 <a href="https://github.com/bkutil/bootstrap-theme">Bootstrap主题</a> 并解压缩到博客的 .theme 目录，然后安装：</p>

<p><code>
rake install['bootstrap']
</code></p>

<p>安装的过程中可能会提示有 sass 或其他依赖库的语法错误神马的，这是因为 sass 的版本过低，可以通过如下命令来跟新：</p>

<p><code>
bundle update sass
</code></p>

<!-- more -->


<p>其他库的升级类推。升级完这些依赖后，要修改你的 Octopress 博客的根目录下的 Gemfile 中的版本说明。最后再重新运行上上条的 rake install 指令。这样就完成主体的安装了，是不是很简单（实际操作中遇到问题的话，一般都是 jekyll 等各种的库的版本及相互间的依赖问题，通过 bundle update 基本上都能搞定）。安装完了之后，可以运行 rake generate 和 rake preview 来看看效果了。</p>

<h2>配置 Tags 归档</h2>

<p>接下来是配置类似 <a href="http://ibillxia.github.io/blog/tags/">这种显示结果</a> 的 Tags 归档页面了。</p>

<p>首先，需要安装 <a href="https://github.com/plusjade/jekyll-bootstrap">jekyll-bootstrap</a> 的一些东西，请先下载并解压。主要是 <em>includes/JB/ 目录下的内容，将 JB 文件夹拷贝到 $BLOG_HOME/source/</em>includes/ 目录下，还有 jekyll-bootstrap 根目录下的 tags.html 拷贝到你想展示 Tags 的目录，并在 _config.yml 文件中配置 tag_dir 项的值为该目录，例如我这里的配置是：</p>

<p><code>
tag_dir: blog/tags
</code></p>

<p>所以我的 tags.html 文件放在了 $BLOG_HOME/source/blog/tags 目录下，并将 tags.html 重命名为 index.html。</p>

<p>这些配置好了后，你就可以先运行 rake generate 和 rake preview 来看看效果。可以发现 Tags 归档页的显示还是不太友好。那么我们需要加入一些自己的 css 样式。这里我参考了 pluskid 师兄的博客的 css 代码并略有修改，在我新建的 $BLOG_HOME/source/stylesheets/style.css 文件中加入如下代码：</p>

<p><code>
/* tag_box */
.tag_box {
  list-style:none;
  margin:0;
  padding:2px 0 ;
  overflow:hidden;
}
.tag_box li {
  line-height:20px;
  margin:0;
}
.tag_box.inline li {
  float:left;
  padding:2px 0 ;
}
.tag_box a {
  padding: 2px;
  margin: 2px;
  background: #eee;
  color:#005F6B;
  border-radius: 3px;
  text-decoration:none;
}
.tag_box a span{
  vertical-align:super;
  font-size:0.8em;
}
.tag_box a.active {
  background:#57A957;
  border:1px solid #4C964D;
  color:#FFF;
}
/* tag_box end */
</code></p>

<p>注意，这里由于新加了 css 文件，要让其生效，需要在 html 模板中加入引用，具体我是在 $BLOG_HOME/source/_includes/head.html 文件中加入如下代码：</p>

<p><code>
&lt;link href="/stylesheets/style.css" media="screen, projection" rel="stylesheet" type="text/css"&gt;
</code></p>

<p>你也可以直接在 html 模板中加入 css 代码而不用新建 css 文件并添加引用。</p>

<p>至此，已经配置完成了 ^_^ 可以运行 rake generate 和 rake preview 来看看最终效果了。</p>

<p>PS：本博客的主题及插件相关文件和代码可以看我的 GitHub Repo：<a href="https://github.com/ibillxia/xoctopress">xoctopress</a>. 如有问题，可以参考这些代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[全排列及某排列的后继的求解及其STL实现的分析]]></title>
    <link href="http://ibillxia.github.io/blog/2014/04/24/next-permutation-and-analysis-of-its-stl-implementation/"/>
    <updated>2014-04-24T23:24:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/04/24/next-permutation-and-analysis-of-its-stl-implementation</id>
    <content type="html"><![CDATA[<p>在Leetcode上有好几道全排列相关的题，一直以来只是会写基于递归的全排列生成算法，遇到这几道题后，搜了下一些非递归的实现方法，发现其实全排列的生成还是很有规律的有木有！这里就总结一下递归和非递归的全排列生成方法，并分析一下 STL 的实现。</p>

<p>递归和非递归实现全排列生成的方法也分别有多种，递归法有基于交换的，有基于链接的，还有回溯，非递归法有排序、回溯、求模等，关于所有这些方法的具体实现参见 <a href="http://mengliao.blog.51cto.com/876134/824079">全排列的六种算法</a>. 本文只实现一种递归和一种非递归算法，并在最后对 STL 的非递归算法进行分析。</p>

<h2>递归法求全排列</h2>

<p>递归法的基本思路是这样的：</p>

<blockquote><p>首先选一个元素排在第一个（有 n 中选法）；
然后递归的对剩下的所有元素进行全排列；
直到一个元素的全排列是其本身。</p></blockquote>

<p>假设给定的元素序列为 &lt;e1, e2, ..., en>，其全排列表示为 P(e1, e2, ..., en)，则对递归的第一步展开有：</p>

<blockquote><p>P(e1, e2, ..., en) = {
&lt;e1, P(e2, e3, ..., en)>,
&lt;e2, P(e1, e3, ..., en)>,
... ...
&lt;en, P(e1, e2, ..., e(n-1))> }</p></blockquote>

<!-- more -->


<p> 一个简单的实现如下：</p>

<p>```
void recursive_permute(int A[],int i,int n){</p>

<pre><code>if(i==n-1){
    for(int j=0;j&lt;n;j++)
        cout&lt;&lt;A[j]&lt;&lt;" ";
    cout&lt;&lt;endl;
    return;
}
for(int j=i;j&lt;n;j++){
    swap(A[i],A[j]);  // choose A[j] as the ith element
    recursive_permute(A,i+1,n);
    swap(A[i],A[j]);  // reset to enter next for
}
</code></pre>

<p>}
```</p>

<p>这个实现非常精简易懂，但却存在一个问题，那就是当数组 A 中存在重复元素时，得到的排列是有重复的，这是因为在第8行的循环中，可能会选取重复的 A[j] 值。 为了去掉重复排列，我们可以在选取第 i 个数 A[j] 之前（即交换 A[i] 和 A[j] 之前），判断值为 A[j] 的元素是否选取过，即要判断在 A[i] 到 A[j-1] 中是否存在与 A[j] 相等的元素，如果出现过，说明 A[i] 选 A[j] 这个排列已经生成过了，可以直接跳过当前的 A[j] 看看是否可以选取 A[j+1] 作为 A[i] 了。比如上面的 e1 = e2，那么无重复的全排列应该是：</p>

<blockquote><p>P(e1, e2, ..., en) = {
&lt;e1, P(e2, e3, ..., en)>,
&lt;e3, P(e1, e2, e4, ..., en)>,
... ...
&lt;en, P(e1, e2, ..., e(n-1))> }</p></blockquote>

<p>添加这个限制的递归实现代码如下：</p>

<p>```
void recursive_permute2(int A[],int i,int n){</p>

<pre><code>if(i==n-1){
    for(int j=0;j&lt;n;j++)
        cout&lt;&lt;A[j]&lt;&lt;" ";
    cout&lt;&lt;endl;
    return;
}
for(int j=i;j&lt;n;j++){
    int k;
    for(k=i;k&lt;j;k++)if(A[k]==A[j])break; // A[j] already used
    if(k&lt;j)continue;
    swap(A[i],A[j]);  // choose A[j] as the ith element
    recursive_permute2(A,i+1,n);
    swap(A[i],A[j]);  // reset to enter next for
}
</code></pre>

<p>}
```</p>

<p>至此，递归法实现全排列的求解就总结到这儿了，下面来看看非递归怎么实现。</p>

<h2>非递归法求全排列</h2>

<p>非递归法求全排列的一种最常用算法是基于字典序的全排列生成算法，其基本思路为，先解决生成一个序列在字典序下的下一个排列这个问题，然后利用这个来一次求解每一个排列。其中求解给定序列在字典序下的下一个排列序列的基本思想如下：</p>

<blockquote><ol>
<li>对于给定序列 &lt;e1, e2, ..., en> 从右往左找到第一个非递增点，设下标为 i；</li>
<li>从右往左查找第一个比 e[i] 大的数，设其下标为 j;</li>
<li>交换 e[i] 和 e[j] 的值；</li>
<li>将序列 e[i+1..n] 逆置。</li>
</ol>
</blockquote>

<p>举个例子，如下图（修改自 <a href="http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html">Next Permutation 解题报告</a> ）所示：</p>

<center><img src="/images/2014/IMAG2014042401.png"></center>


<p>上面的说明已经很接近伪代码了，具体实现如下：</p>

<p>```
bool next_permute(int A[],int n){</p>

<pre><code>int i,j;
// step .1
if(n&lt;2)return false;
for(i=n-2;i&gt;=0;i--){
    if(A[i]&lt;A[i+1])break;
}
if(i&lt;0)return false; // A[0] is maximum, no next permute for it
// step .2
for(j=n-1;j&gt;i;j--){
    if(A[j]&gt;A[i])break;
}
// step .3
swap(A[i],A[j]);
// step .4
while(++i &lt; --n){
    swap(A[i],A[n]);
}
return true;
</code></pre>

<p>}
```</p>

<p>这里将其返回值定义为 bool 类型，可以方便后面求解全排列时调用：</p>

<p>```
void non_recursive_permute(int A[],int n){</p>

<pre><code>sort(A,A+n);
int i;
do{
    for(i=0;i&lt;n;i++)cout&lt;&lt;A[i]&lt;&lt;" ";
    cout&lt;&lt;endl;
}while(next_permute(A,n));
</code></pre>

<p>}
```</p>

<p>上面这个函数即实现了按字典序生成全排列的功能，而且对于输入含有重复值的情况，不会生成重复的排列。对于非递归实现，很容易分析其时间复杂度，next_permute 的时间复杂度为 O(n)，而 non_recursive_permute 的时间复杂度为 O(n*n!)。</p>

<h2>STL 中 next permute 的实现</h2>

<p>下面来分析一下 STL 中是如何实现 next permute 的，在 stl_algo.h 中我们可以找到 next_permutation 的实现，基本思路也是按照上面的四步走来实现的，具体见如下代码及注释：</p>

<p>```
/<em>*
 *  @brief  Permute range into the next @a dictionary ordering.
 *  @ingroup sorting_algorithms
 *  @param  first  Start of range.
 *  @param  last   End of range.
 *  @return  False if wrapped to first permutation, true otherwise.
 *
 *  Treats all permutations of the range as a set of @a dictionary sorted
 *  sequences.  Permutes the current sequence into the next one of this set.
 *  Returns true if there are more sequences to generate.  If the sequence
 *  is the largest of the set, the smallest is generated and false returned.
</em>/
template<typename _BidirectionalIterator>
bool
next_permutation(_BidirectionalIterator __first,</p>

<pre><code>             _BidirectionalIterator __last)
</code></pre>

<p>{</p>

<pre><code>// concept requirements
__glibcxx_function_requires(_BidirectionalIteratorConcept&lt;
                            _BidirectionalIterator&gt;)
__glibcxx_function_requires(_LessThanComparableConcept&lt;
                            typename iterator_traits&lt;_BidirectionalIterator&gt;::value_type&gt;)
__glibcxx_requires_valid_range(__first, __last);

if (__first == __last)  // 容器中没有元素，没有 next permute
    return false;
_BidirectionalIterator __i = __first;
++__i;
if (__i == __last)  // 容器中只有一个元素，同没有
    return false;
__i = __last;
--__i;  // 将 __i 指向最后一个元素

for(;;) {
    _BidirectionalIterator __ii = __i;  
    --__i;
    if (*__i &lt; *__ii) {  // step .1, 这里的 __i 就相当于上面step 1中的i
        _BidirectionalIterator __j = __last;
        while (!(*__i &lt; *--__j)) {  // step .2, 这里的 __j 就相当上面 step 2中的j
        }
        std::iter_swap(__i, __j);  // step .3 交换
        std::reverse(__ii, __last);  // step .4 逆置
        return true;
    }
    if (__i == __first) {  // 直到 __i = __first 还是没有 *__i &lt; *__ii ，说明序列是递减排列的
        std::reverse(__first, __last); // 本应该没有下一个排列，但这里将字典序中第一个排列作为最后一个排列的 next permute
        return false; // 这里返回 false 而不是 true
    }
}
</code></pre>

<p>}
```</p>

<p>这里是用双向迭代器对容器中的元素进行操作的，一个调用的实例如下：</p>

<p>```
vector&lt;vector<int> > permute(vector<int> &amp;num) {</p>

<pre><code>vector&lt;vector&lt;int&gt; &gt; ans;
sort(num.begin(),num.end());
do{
    ans.push_back(num);
}while(next_permutation(num.begin(),num.end()));
return ans;
</code></pre>

<p>}
```</p>

<p>可以看到，其实 STL 的 next permute 的实现跟我们的非递归算法是一致的。但这里有两个问题：一是，这里看似有二重循环（在 for 中套 while ），但实际上复杂度是 n+n =》 O(n) 的（可以为什么要写成这种二重循环的形式捏？不解）；二是，我们可以看到在 for 循环中，对 __ii 这个变量进行了多次声明，为什么不将其声明放在 for 外面捏？（虽然待排列的元素数 n 不会很大，但这样多次声明一个迭代器变量，虽不会占用过多内存，但在声明时调用构造函数和析构函数也是有一定的时间开销的吧，虽然相对于求全排列的复杂度 O(n*n!) 几乎可以忽略不计）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[原地交换两个变量的值]]></title>
    <link href="http://ibillxia.github.io/blog/2014/04/11/swap-two-variables-in-place/"/>
    <updated>2014-04-11T22:27:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/04/11/swap-two-variables-in-place</id>
    <content type="html"><![CDATA[<h2>引子</h2>

<p>在码代码的过程中，不经意间就会遇到需要交换两个变量的情况，一般情况下都是通过新定义一个同类型的变量来中转，但自己也知道可以不用定义新变量直接原地交换，但具体如何原地交换以及其中可能隐藏的bug却了解得不是很清楚，于是乎google了一下，发现这里面还真是有很多学问呢，这里整理和总结一下。</p>

<p>原地交换两个变量，最主要有加减法和异或法。</p>

<p>本文完整代码链接：<a href="../upload/code/20140411.cpp">20140411.cpp</a></p>

<h2>加减法</h2>

<p>加减法最简单、最好理解了，设待交换的两个变量分别为 a 和 b ，首先将两者的和赋给 a ；然后将 a 与 b的差赋给 b ，这样 b 就是 a 原来的值了；最后再将 a 与 b 的差赋给 a ，这样 a 就是 b 原来的值了。具体代码如下：</p>

<p>```
inline template <class T>
void xswap(T &amp;a,T &amp;b){</p>

<pre><code>a=a+b;
//printf("a=%u\n",a);
b=a-b;
a=a-b;
</code></pre>

<p>}
```</p>

<!-- more -->


<p>当然也可以先减后加：</p>

<p>```
inline template <class T>
void xswap2(T &amp;a,T &amp;b){</p>

<pre><code>a=a-b;
//printf("a=%u\n",a);
b=a+b;
a=b-a;
</code></pre>

<p>}
```</p>

<p>这里实现的原理与先加后减类似。粗一看，这样实现两个变量的原地交换很简单有效。但是，这其中有一个很隐秘的bug，就是溢出的问题，在先加后减的实现中，如果 a 与 b 的和大于该类型的能表示的最大值，会发生神马捏？我写了一个 main 函数来简单的测试了一下：</p>

<p>```
int main()
{</p>

<pre><code>unsigned char a=255,b=1;
printf("a=%u,b=%u\n",a,b);
xswap(a,b);
printf("a=%u,b=%u\n",a,b);
return 0;
</code></pre>

<p>}
```</p>

<p>将上面的 xswap 函数中的注释取消，编译运行后（使用Code::Blocks 13.12 MinGW g++编译），得到如下输出：</p>

<p><code>
a=255,b=1
a=0
a=1,b=255
</code></p>

<p>可以看到其中第2行输出的 a 的值为 0，产生了上溢（如果 a , b 同为负，可能产生下溢）。虽然最后交换的结果还是对的，但溢出的部分可能对内存中其他变量产生不可预测的后果。因此，不建议这么实现原地交换两个变量，如果实在需要用这种方法，一定要在进行加或减之前，判断时候回产生溢出。</p>

<h2>异或法</h2>

<p>异或法的基本原理类似，但还利用了异或的如下两个特性： a ^ 0 = a, a ^ a = 0. 用异或来实现两个变量的交换如下：</p>

<p>```
template <class T>
inline void xswap3(T &amp;a,T &amp;b){</p>

<pre><code>a=a^b;
b=a^b;
a=b^a;
</code></pre>

<p>}
```</p>

<p>由于异或是按位运算的，所以不存在溢出问题。因此，如果一定要原地实现两个变量的交换的话，建议用异或的方法。</p>

<h2>原地交换多个变量</h2>

<p>实际上，我们还可以利用上面的思想，将两个变量扩展到多个变量的原地交换，例如三个变量的交换：</p>

<p>```
template <class T>
inline void swap3(T &amp;a,T &amp;b,T &amp;c){</p>

<pre><code>a=a^b;
b=a^b;
a=b^a;
b=b^c;
c=b^c;
b=b^c;
</code></pre>

<p>}
```</p>

<p>即先交换 a 和 b，再交换 b (=a) 和 c。另外，上面的式子可以简化和压缩到一个式子，具体的技巧读者可以自行google，这里不提倡这么做。</p>

<h2>STL是如何实现swap的</h2>

<p>最后，我们来看看STL标准库是如何实现swap的（这里的实现版本是 move.h 文件中的一个，在 STL 中还有针对 vector, string, tree, map, multimap, deque 的 swap 函数）。</p>

<p>```
/<em>*
*  @brief Swaps two values.
*  @ingroup mutating_algorithms
*  @param  <strong>a  A thing of arbitrary type.
*  @param  </strong>b  Another thing of arbitrary type.
*  @return   Nothing.
</em>/
template<typename _Tp>
inline void
swap(<em>Tp&amp; __a, </em>Tp&amp; <strong>b)
{
  // concept requirements
  </strong>glibcxx_function_requires(_SGIAssignableConcept<_Tp>)</p>

<p>  <em>Tp __tmp = </em>GLIBCXX_MOVE(<strong>a);
  </strong>a = <em>GLIBCXX_MOVE(<strong>b);
  </strong>b = </em>GLIBCXX_MOVE(__tmp);
}
```</p>

<p>可以看到，这里新声明了一个变量 __tmp 来中转。至于为什么没有原地进行交换，一个可能的解释是：对于 inline 函数来说，函数调用的代码会直接被改函数体替换，再经过编译优化，最后可能只需要借助一个寄存器变量就可以实现两个变量的交换了，这是非常快的，与通过按位的异或运算的实现，在性能上区别不是太大。</p>

<h2>update</h2>

<p>关于溢出的更深入的讨论，可以看看陈浩的最新博文 <a href="http://coolshell.cn/articles/11466.html">C语言的整型溢出问题</a> . 这里面有提到溢出的几个危害，还有关于 C 语言标准、编译器对溢出是如何处理和对待的，以及如何写代码实现预先判断溢出。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go并发编程初探]]></title>
    <link href="http://ibillxia.github.io/blog/2014/03/16/go-concurrent-programming-first-try/"/>
    <updated>2014-03-16T23:35:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/03/16/go-concurrent-programming-first-try</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>最近在做的一个项目，需要对大量数据进行一些基本的统计和处理，整个程序的思路很简单，但处理起来却很慢，特别是有二重循环的地方，龟速前进，眼看着16核32线程
的服务器只有一个线程被利用，束手无策。之前一直听说Go是一门对并发编程有很好的支持的语言，七牛的许牛大力推崇Go语言，于是就开始了对Go并行编程的探索之旅。</p>


<center><img src="/images/2014/IMAG2014031601.jpg"></center>




<!--more-->




<h2>一些准备工作</h2>


<p>在正式开始Go并行编程之前，首先我们需要准备Go的编程开发环境：Go编译器、Go编辑器。</br>
在<a href="http://golang.org/">golang的官网</a>上有go的下载链接：</br>
<a href="http://code.google.com/p/go/downloads/list">http://code.google.com/p/go/downloads/list</a></br>
我选择的是go1.2.1.windows-amd64.msi安装包，下载完后直接点击该安装包，按照默认选项安装即可。安装完后，可以在命令行中查看go版本以检查是否安装成功：

```
C:\Users\Bill>go version
go version go1.2.1 windows/amd64
```

然后，我们需要安装一个用于Go开发的IDE。当然也可以用通用的文本编辑器就可以，比如notepad、vi等，但这都是一些轻量级的，对于初学者来说还是不太合适的。
网上有很多推荐的IDE，主要有LiteIDE、Eclipse+Goclipse、GoIde等，以及vim/emacs搭配go插件等，这里我选择的是LiteIDE，下载地址：</br>
<a href="http://sourceforge.net/projects/liteide/files/x21/">http://sourceforge.net/projects/liteide/files/x21/</a></br>
下载安装后，我们就可以开始go编程了。可以先运行一个Hello world程序，这里就不演示了，具体见：<a href="http://tour.golangtc.com/#1">Go 指南</a>
</p>




<p>关于Go的一些特性的介绍这里也不讲了，有兴趣的可以移步酷壳的这两篇文章<a href="http://coolshell.cn/articles/8460.html">Go 语言简介（上）— 语法</a> 
和 <a href="http://coolshell.cn/articles/8489.html">Go 语言简介（下）— 特性</a>。下面我们直接进入Go并发编程。</p>




<h2>Go并发编程</h2>


<h4>#0x01.goroutine</h4>


<p>优雅的并发编程范式，完善的并发支持，出色的并发性能是Go语言区别于其他语言的一大特色。在Go中，通过一种叫做goroutine的go协程这种轻量级线程来支持
并发编程范式。协程是比进程和线程更轻量级的线程，go语言标准库提供的所有系统调用操作都会出让CPU给其他goroutine，协程的切换管理不依赖于系统的线程和
进程，也不依赖于CPU的核心数量。下面我们来看一个简单的goroutine的实例。

```
package main

import "fmt"

func main() {
    arr := [10]int{}
    for i := 0; i < 10; i++ {
        fmt.Print("Result of ", i, ":")
        go func() {
            arr[i] = i + i*i
            fmt.Println(arr[i])
        }()
    }
    fmt.Println("Done")
}
```

Go从main package的main()函数开始执行，这段代码的功能是计算arr[i]=i+i*i，其中i取值从0到9，每一个i计算完后立即输出。其中go为golang的关键字，启动
一个协程（goroutine）。程序的运行的结果是什么呢？我们期望的结果应该是这样的吧：

```
Result of 0:0
Result of 1:2
Result of 2:6
Result of 3:12
Result of 4:20
Result of 5:30
Result of 6:42
Result of 7:56
Result of 8:72
Result of 9:90
Done
```

可是在LiteIDE中运行后，却会发现结果是这样子的：

```
Result of 0:Result of 1:Result of 2:Result of 3:Result of 4:Result of 5:Result of 6:Result of 7:Result of 8:Result of 9:Done
```

这是为神马捏？怎么第9~12行的go func(){...}() 这段代码好像更笨就没有执行嘛？！莫非这是golang的bug？</p>

<p>其实，这与golang的程序执行顺序有关。go程序从初始化main package并执行main()函数开始，当main()函数返回时，程序退出，且程序并不等待其他goroutine
（非主goroutine）结束。于是上面的程序中，主函数虽然启动了10gegoroutine，但都没来得及执行，程序就已经退出了。那么怎么解决这个问题捏？很显然，我们
在退出程序之前，需要判断这些创建的goroutine执行完了没。我们可以用一个全局变量来计数执行了的协程数，如果计数变量小于10，我们就等待或sleep。</p>

<h4>#0x02.并发通讯</h4>
<p>等一等，多个协程读写同一个变量，我们是不是需要对这个变量枷锁呀？答案是肯定的，我们可以采用类似与C/C++的线程通讯、数据共享的思路来实现，如下：

```
package main

import (
    "fmt"
    "runtime"
    "sync"
)

func main() {
    var cnt int = 0  // 全局计数器
    mylock := &sync.Mutex{}  // 互斥锁
    arr := [10]int{}
    for i := 0; i < 10; i++ {
        fmt.Print("Result of ", i, ":")
        go func() {
            arr[i] = i + i*i
            fmt.Println(arr[i])
            mylock.Lock() // 写之前枷锁
            cnt++
            mylock.Unlock() // 写之后释放锁
        }()
    }
    for {
        mylock.Lock() // 读之前枷锁
        temp := cnt
        mylock.Unlock() // 读之后释放锁
        runtime.Gosched() // 协程切换
        if temp >= 10 {
            break
        }
    }
    fmt.Println("Done")
}
```

执行以上程序，应该能够得到我们之前预期的那样的结果吧？可以运行之后，我们发现，结果却是这样的：

```
Result of 0:Result of 1:Result of 2:Result of 3:Result of 4:Result of 5:Result of 6:Result of 7:Result of 8:Result of 9:panic: runtime error: index out of range
...
```

出现了运行时错误，数组下表越界了？！第17行还是没有输出？！经过一番修改，得到如下代码：

```
package main

import (
    "fmt"
    "runtime"
    "sync"
)

func main() {
    var cnt int = 0  // 全局计数器
    mylock := &sync.Mutex{}  // 互斥锁
    arr := [11]int{}
    for i := 0; i < 10; i++ {
        go func() {
            arr[i] = i + i*i
            mylock.Lock() // 写之前枷锁
            cnt++
            mylock.Unlock() // 写之后释放锁
        }()
    }
    for {
        mylock.Lock() // 读之前枷锁
        temp := cnt
        mylock.Unlock() // 读之后释放锁
        runtime.Gosched() // 协程切换
        if temp >= 10 {
            break
        }
    }
    for i := 0; i < 11; i++ {
        fmt.Println("Result of ", i, ":", arr[i])
    }
    fmt.Println("Done")
}
```

这下应该能得到预期的结果了吧。可以运行程序后，有傻眼了，结果是：

```
Result of  0 : 0
Result of  1 : 0
Result of  2 : 0
Result of  3 : 0
Result of  4 : 0
Result of  5 : 0
Result of  6 : 0
Result of  7 : 0
Result of  8 : 0
Result of  9 : 0
Result of  10 : 110
Done
```

神马？arr[0]~arr[9]肿么都是0，肿么会冒出一个arr[10]=110？！即使把第15、16行顺序互换，得到的结果还是一样！！！这真是一场噩梦啊！！！仔细对比许书上的例子，
我们发现，这里使用的是匿名函数创建协程，匿名函数中使用了全局的变量，而每次使用go关键字创建协程后，程序不是继续往下执行，而是继续返回到for这一行来执行，首先i++，
然后判断i<10，成立就继续执行并创建协程，10个协程创建完了之后，才真正开始匿名函数的执行，而此时i已经是10了，对于每一个协程i都是10，因此最终只计算了一个arr[10]=110，
这也是为什么申请10个单位的数组时会出现运行时错误。而这完全不是我们所要的结果，那么怎么办呢？我们不妨用带参数的匿名函数来试试？如下：

```
package main

import (
    "fmt"
    "runtime"
    "sync"
)

func main() {
    var cnt int = 0  // 全局计数器
    mylock := &sync.Mutex{}  // 互斥锁
    arr := [11]int{}
    for i := 0; i < 10; i++ {
        go func(i int) { // 这里的i是形参
            arr[i] = i + i*i
            mylock.Lock() // 写之前枷锁
            cnt++
            mylock.Unlock() // 写之后释放锁
        }(i) // 这里的i是实参
    }
    for {
        mylock.Lock() // 读之前枷锁
        temp := cnt
        mylock.Unlock() // 读之后释放锁
        runtime.Gosched() // 协程切换
        if temp >= 10 {
            break
        }
    }
    for i := 0; i < 11; i++ {
        fmt.Println("Result of ", i, ":", arr[i])
    }
    fmt.Println("Done")
}
```

终于，我们总算得到了想要的结果了，经过不懈努力终于大功告成。这里没创建一个协程，都有一个实参值传给形参，在匿名函数中就不存在共享的全局变量i了。
然而，在让我们回头看看我们的代码，却会发现，这与一般的多线程程序有什么区别的，而且写起来会感觉更麻烦，有过之而无不及啊！</p>

<p>想象一下，在一个大的系统中具有无数的锁、无数的共享变量、无数的业务逻辑与错误处理分支，那将是一场噩梦。这噩梦就是众多C/C++开发者正在经历的，其实Java和C#开发
者也好不到哪里去。Go语言既然以并发编程作为语言的最核心优势，当然不至于将这样的问题用这么无奈的方式来解决。Go语言提供的是另一种通信模型，即以消息机制而非共享
内存作为通信方式。</p>

<h4>#0x03.channel</h4>
<p>Go语言提供的消息通信机制被称为channel，接下来我们将详细介绍channel。现在，让我们用Go语言社区的那句著名的口号来开始这一小节： </br>
<blockquote><p>不要通过共享内存来通信，而应该通过通信来共享内存。</p></blockquote>
channel是Go语言在语言级别提供的goroutine间的通信方式，可以使用channel在两个或多个goroutine之间传递消息。channel是进程内的通信方式，因此通过channel传递
对象的过程和调用函数时的参数传递行为比较一致，比如也可以传递指针等。如果需要跨进程通信，建议用分布式系统的方法来解决，比如使用Socket或者HTTP等通信协议。
channel是类型相关的。也就是说，一个channel只能传递一种类型的值，这个类型需要在声明channel时指定。我们先看下用channel的方式重写上面的例子是什么样子的

```
package main

import "fmt"

func main() {
    chs := make([]chan int, 10) // 申请一个10维的channel数组
    arr := [11]int{}
    for i := 0; i < 10; i++ {
        chs[i] = make(chan int) // 对每个channel初始化
        go func(ch chan int, i int) {
            arr[i] = i + i*i
            ch <- 1  // 写channel，应该在函数体的最后一行，许书（P94，代码清单4-4）上有bug
        }(chs[i], i)
    }
    for _, ch := range chs {
        <-ch // 读channel
    }
    for i := 0; i < 11; i++ {
        fmt.Println("Result of ", i, ":", arr[i])
    }
    fmt.Println("Done")
}
```

在这段代码中，我们给每个goroutine分配了一个channel，在每个goroutine执行完时对该goroutine的channel进行写操作，而在第16行进行读操作，对于每个channel，
只有完成了写操作之后，才可以进行读取，否则会处于阻塞状态。因此在10个goroutine没有执行完之前，main函数是不会退出的。这样是不是比共享内存的方式更简单
而优雅呢？其实，我们还可以对代码继续进行简化，可以将匿名函数的传递的channel参数省去，而在匿名函数内部直接使用全局的chs[i]，匿名函数可以修改为如下：

```
go func(i int) {
    arr[i] = i + i*i
    chs[i] <- 1  // 写channel
}(i)
```

</p>

<p>到这里，go的并行编程基本已经入门了，关于channel的更多详细的用法可以参见参考资料。</p>

<h2>参考资料</h2>
<p>[1] golang 官方主页：<a href="http://golang.org/">http://golang.org/</a></br>
[2] go语言编程，许世伟
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PCM WAVE格式详解及用C语言实现wave文件的读取]]></title>
    <link href="http://ibillxia.github.io/blog/2013/07/20/details-of-wave-format-and-reading-wave-files-in-C-language/"/>
    <updated>2013-07-20T20:07:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/07/20/details-of-wave-format-and-reading-wave-files-in-C-language</id>
    <content type="html"><![CDATA[<h2>1.PCM Wave格式详解</h2>


<p>WAVE文件格式是微软RIFF(Resource Interchange File Format,资源交换文件标准)的一种，是针对于多媒体文件存储的一种文件格式和标准。
一般而言，RIFF文件由文件头和数据两部分组成，一个WAVE文件由一个“WAVE”数据块组成，这个“WAVE”块又由一个"fmt"子数据块和一个“data”子
数据块组成，也称这种格式为“Canonical form”（权威/牧师格式），如下图所示：
<center><img src="/images/2013/IMAG2013072001.gif"></center>
</p>


<!--more-->


<p>每个字段的涵义如下：
ChunkID: 占4个字节，内容为“RIFF”的ASCII码(0x52494646)，以大端（big endian）存储。</br>
ChunkSize: 4字节，存储整个文件的字节数（不包含ChunkID和ChunkSize这8个字节），以小端（little endian）方式存储。</br>
Format: 4字节，内容为“WAVE”的ASCII码(0x57415645)，以大端存储。</br>
</p>




<p>
其中bigendian 主要有一个特征，在内存中对操作数的存储方式和从高字节到低字节。例如：0x1234，这样一个数，存储为:</br>
0x4000:   0x12</br>
0x4001:   0x34</br>
而小尾端littleendian是：</br>
0x4000:   0x34</br>
0x4001:   0x12</br>
用程序在区别的话，可以考虑：
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h>
</span><span class='line'>#include &lt;stdlib.h>
</span><span class='line'>int main(int argc, char *argv[])
</span><span class='line'>{
</span><span class='line'>       union w
</span><span class='line'>      {
</span><span class='line'>       short int a;
</span><span class='line'>       char b;
</span><span class='line'>      }c;
</span><span class='line'>      c.a=1;
</span><span class='line'>      if( c.b==1 )  printf("little endian\n");
</span><span class='line'>      else printf("big endian\n");
</span><span class='line'>      system("PAUSE"); 
</span><span class='line'>      return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></notextile></div>
</p>




<p>"WAVE"格式由两个子数据块构成：“fmt”块和“data”块，其中“fmt”块的详细解释如下：
Subchunk1ID: 占4个字节，内容为“fmt ”的ASCII码(0x666d7420)，以大端存储。</br>
Subchunk1Size: 占4个字节，存储该子块的字节数（不含前面的Subchunk1ID和Subchunk1Size这8个字节），以小端方式存储。</br>
AudioFormat：占2个字节，以小端方式存储，存储音频文件的编码格式，例如若为PCM则其存储值为1，若为其他非PCM格式的则有一定的压缩。</br>
NumChannels: 占2个字节，以小端方式存储，通道数，单通道(Mono)值为1，双通道(Stereo)值为2，等等。</br>
SampleRate: 占4个字节，以小端方式存储，采样率，如8k，44.1k等。</br>
ByteRate: 占4个字节，以小端方式存储，每秒存储的bit数，其值=SampleRate * NumChannels * BitsPerSample/8</br>
BlockAlign: 占2个字节，以小端方式存储，块对齐大小，其值=NumChannels * BitsPerSample/8</br>
BitsPerSample: 占2个字节，以小端方式存储，每个采样点的bit数，一般为8,16,32等。</br>
接下来是两个可选的扩展参数：</br>
ExtraParamSize: 占2个字节，表示扩展段的大小。</br>
ExtraParams: 扩展段其他自定义的一些参数的具体内容，大小由前一个字段给定。
</p>




<p>其中，对于每个采样点的bit数，不同的bit数读取数据的方式不同：
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// data 为读取到的采样点的值，speech为原始数据流，
</span><span class='line'>//对应于下面的"WAVE"格式文件的第二个子数据块“data”块的“Data”部分。
</span><span class='line'>for(i=0;i&lt;NumSample;i++){
</span><span class='line'>    if(BitsPerSample==8)
</span><span class='line'>        data[i] = (int)*((char*)speech+i);
</span><span class='line'>    else if(BitsPerSample==16)
</span><span class='line'>        data[i] = (int)*((short*)speech+i);
</span><span class='line'>    else if(BitsPerSample==32)
</span><span class='line'>        data[i] = (int)*((int*)speech+i);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></notextile></div>
</p>




<p>"WAVE"格式文件的第二个子数据块是“data”，其个字段的详细解释如下：</br>
Subchunk2ID: 占4个字节，内容为“data”的ASCII码(0x64617461)，以大端存储。</br>
Subchunk2Size: 占4个字节，内容为接下来的正式的数据部分的字节数，其值=NumSamples * NumChannels * BitsPerSample/8</br>
Data: 真正的语音数据部分。</br>
</p>




<h2>一个Wave文件头的实例</h2>


<p>设一个wave文件的前72个字节的十六进制内容如下(可以使用Ultra Edit等工具查看wave文件头)：
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>52 49 46 46 24 08 00 00 57 41 56 45 66 6d 74 20 10 00 00 00 01 00 02 00 
</span><span class='line'>22 56 00 00 88 58 01 00 04 00 10 00 64 61 74 61 00 08 00 00 00 00 00 00 
</span><span class='line'>24 17 1e f3 3c 13 3c 14 16 f9 18 f9 34 e7 23 a6 3c f2 24 f2 11 ce 1a 0d</span></code></pre></td></tr></table></div></figure></notextile></div>
则其个字段的解析如下图：
<center><img src="/images/2013/IMAG2013072002.gif"></center>
</p>




<h2>C语言实现wave文件的读取</h2>


<p>这里给出一个用基本的C语言文件操作库函数实现的Wave文件读取的实例代码，可以跨Windows和Linux平台。</p>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>include &lt;stdio.h>&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>include &lt;stdlib.h>&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>include &lt;string.h>&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>// define Wave format structure
</span><span class='line'>typedef struct tWAVEFORMATEX
</span><span class='line'>{&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>short wFormatTag;         /* format type */
</span><span class='line'>short nChannels;          /* number of channels (i.e. mono, stereo...) */
</span><span class='line'>unsigned int nSamplesPerSec;     /* sample rate */
</span><span class='line'>unsigned int nAvgBytesPerSec;    /* for buffer estimation */
</span><span class='line'>short nBlockAlign;        /* block size of data */
</span><span class='line'>short wBitsPerSample;     /* number of bits per sample of mono data */
</span><span class='line'>short cbSize;             /* the count in bytes of the size of */
</span><span class='line'>                                /* extra information (after cbSize) */
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>} WAVEFORMATEX, *PWAVEFORMATEX;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>char&lt;em> wavread(char &lt;/em>fname, WAVEFORMATEX *wf);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>int main(){&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>char fname = "test.wav";
</span><span class='line'>char *speech;
</span><span class='line'>WAVEFORMATEX wf;
</span><span class='line'>
</span><span class='line'>speech = wavread(fname, &amp;wf);
</span><span class='line'>// afterward processing...
</span><span class='line'>
</span><span class='line'>return 0;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// read wave file
</span><span class='line'>char&lt;em> wavread(char &lt;/em>fname, WAVEFORMATEX *wf){&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>FILE* fp;
</span><span class='line'>char str[32];
</span><span class='line'>char *speech;
</span><span class='line'>unsigned int subchunk1size; // head size
</span><span class='line'>unsigned int subchunk2size; // speech data size
</span><span class='line'>
</span><span class='line'>// check format type
</span><span class='line'>fp = fopen(fname,"r");
</span><span class='line'>if(!fp){
</span><span class='line'>    fprintf(stderr,"Can not open the wave file: %s.\n",fname);
</span><span class='line'>    return NULL;
</span><span class='line'>}
</span><span class='line'>fseek(fp, 8, SEEK_SET);
</span><span class='line'>fread(str, sizeof(char), 7, fp);
</span><span class='line'>str[7] = '\0';
</span><span class='line'>if(strcmp(str,"WAVEfmt")){
</span><span class='line'>    fprintf(stderr,"The file is not in WAVE format!\n");
</span><span class='line'>    return NULL;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// read format header
</span><span class='line'>fseek(fp, 16, SEEK_SET);
</span><span class='line'>fread((unsigned int*)(&amp;subchunk1size),4,1,fp);
</span><span class='line'>fseek(fp, 20, SEEK_SET);
</span><span class='line'>fread(wf, subchunk1size, 1, fp);
</span><span class='line'>
</span><span class='line'>// read wave data
</span><span class='line'>fseek(fp, 20+subchunk1size, SEEK_SET);
</span><span class='line'>fread(str, 1, 4, fp);
</span><span class='line'>str[4] = '\0';
</span><span class='line'>if(strcmp(str,"data")){
</span><span class='line'>    fprintf(stderr,"Locating data start point failed!\n");
</span><span class='line'>    return NULL;
</span><span class='line'>}
</span><span class='line'>fseek(fp, 20+subchunk1size+4, SEEK_SET);
</span><span class='line'>fread((unsigned int*)(&amp;subchunk2size), 4, 1, fp);
</span><span class='line'>speech = (char*)malloc(sizeof(char)*subchunk2size);
</span><span class='line'>if(!speech){
</span><span class='line'>    fprintf(stderr, "Memory alloc failed!\n");
</span><span class='line'>    return NULL;
</span><span class='line'>}
</span><span class='line'>fseek(fp, 20+subchunk1size+8, SEEK_SET);
</span><span class='line'>fread(speech, 1, subchunk2size, fp);
</span><span class='line'>
</span><span class='line'>fclose(fp);
</span><span class='line'>return speech;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>参考</h2>


<p>
[1]WAVE PCM soundfile format: https://ccrma.stanford.edu/courses/422/projects/WaveFormat/ </br>
[2]Resource Interchange File Format: http://en.wikipedia.org/wiki/Resource_Interchange_File_Format </br>
[3]基于Visual C++6.0的声音文件操作: http://www.yesky.com/20030414/1663116_1.shtml
</p>

]]></content>
  </entry>
  
</feed>
