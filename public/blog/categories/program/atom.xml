<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Program | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/categories/program/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2014-05-11T23:47:42+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ubuntu 下 Android NDK 开发入门]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/04/android-ndk-development/"/>
    <updated>2014-05-04T23:53:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/04/android-ndk-development</id>
    <content type="html"><![CDATA[<p>本文首先介绍一下在 Ubuntu 下如何配置 Android NDK 开发环境，然后用一个简单的 hello-jni 项目来介绍 NDK 开发流程，本文的全部代码下载链接：<a href="http://ibillxia.github.io/upload/code/20140504-HelloJni.tar.gz">HelloJni.tar.gz</a>，也可以在我的 <a href="https://github.com/ibillxia/Demo/tree/master/HelloJni">GitHub</a> 上下载。</p>

<h2>1. 简介</h2>

<p>什么是 Android NDK 呢？ NDK(Native Development Kit) 是一个允许开发者用一些本地语言(C/C++)编写 Android App 的部分功能的工具集。对于一些特定的 App，NDK 非常有利于我们直接使用现成的用 C/C++ 编写的代码库（但对于大多数 App 来说，NDK 是没有必要的）。使用 NDK 进行 C/C++ Android 开发的基本结构和流程如下图（来自<a href="http://shihongzhi.com/ndk/">shihongzhi博客</a> ）：</p>

<center> <img src="/images/2014/IMAG2014050401.jpg"> </center>


<p>在开始之前，这里要提醒大家：NDK 对大多数 App 而言是不会有太多的好处的，在 Android 上使用原生 C/C++ 代码并不会很明显的提升应用的性能，但却增加了你开发应用的复杂度。所以，仅仅在需要使用 NDK 时才使用它 —— 不要因为你更喜欢用 C/C++。典型的 NDK 应用场景是一些 CPU 操作密集而不需要太多内存的场合，如信号处理、物理模拟等等，很多这些处理过程都已经封装到了 Android 系统内部，所以当你不确定是否要使用本地 C/C++ 代码时，先看看你的需求，以及 Android 框架中的 API 是否已经提供你需要的功能。</p>

<!-- more -->


<h2>2.开发环境配置</h2>

<p>由于 NDK 开发过程中涉及到将 C/C++ 程序编译为动态库(.so文件)，所以首先系统中需要安装 C/C++ 的编译工具 gcc/g++，还要有 make 工具，一般情况下 Linux 系统会默认安装，如果没有安装请先安装这几个工具。然后是 Java 和 Android 开发相关环境的配置。首先需要安装 JDK，并配置 Java 的环境变量，然后是集成开发环境如 Eclipse 的安装和配置，这些也不是本文的重点，如果你没有安装，请自行 google 并安装配置好。</p>

<p>下面重点讲讲 Android 相关 SDK 的安装和配置，主要涉及到 Android SDK，ADT，NDK等。要进行 Android 开发，首先需要安装 Android SDK，要在 Eclipse 中进行开发的话，还需在 Eclipse 中安装 ADT(Android Develop Tools)，在 Android 官网上提供了 SDK 和 包含 ADT 的 Eclipse 的集成开发包，可以一起下载：<a href="http://dl.google.com/android/adt/22.6.2/adt-bundle-linux-x86-20140321.zip">adt-bundle-linux-x86-20140321.zip</a>。另外，还需要安装 NDK，下载地址：<a href="http://dl.google.com/android/ndk/android-ndk-r9d-linux-x86.tar.bz2">android-ndk-r9d-linux-x86.tar.bz2</a>。下载完这两个压缩包后解压并移动到 /usr/local 目录下：</p>

<p><code>
sudo mv Downloads/adt-bundle-x86-20140321/ /usr/local/adt-x86-20140321
mv Downloads/android-ndk-r9d/ /usr/local/adt-x86-20140321/ndk-r9d
</code></p>

<p>然后配置环境变量：</p>

<p><code>
sudo vim /etc/profile
</code></p>

<p>在 /etc/profile 最后添加如下两行：</p>

<p><code>
export PATH=/usr/local/adt-x86-20140321/sdk/tools:/usr/local/adt-x86-20140321/sdk/platform-tools:$PATH
export PATH=/usr/local/adt-x86-20140321/ndk-r9d:$PATH
</code></p>

<p>保存并退出，并用如下命令使设置生效：</p>

<p><code>
source /etc/profile
</code></p>

<p>完了可以执行如下命令看看设置是否生效：</p>

<p><code>
echo $PATH
adb --version
emulator -version
ndk-build --version
</code></p>

<p>至此，开发环境已经配置完成了，接下来我们看一个 hello-jni 的例子。</p>

<h2>3.NDK 开发实例 hello-jni</h2>

<h4>3.1 JNI 简介</h4>

<p>首先我们了解一下什么是JNI。JNI(Java Native Interface)是一种在Java虚拟机控制下执行代码的标准机制。 代码被编写成汇编程序或者C/C++程序，并组装为动态库，从而提供了一个在Java平台上调用C/C++的一种途径。 JNI主要的竞争优势在于：它在设计之初就确保了二进制的兼容性，JNI编写的应用程序兼容性以及在某些具体平台上的Java虚拟机兼容性（当谈及JNI，这里并不特别针对Dalvik；JNI由Oracle开发，适用于所有Java虚拟机）。 关于JNI的更多内容可以参见该文：<a href="http://www.importnew.com/8038.html">Android NDK介绍</a>。</p>

<h4>3.2 Eclipse 配置</h4>

<p>下面以参考 Android NDK 自带的 hello-jni 示例程序改写的我自己的 hello-jni 来介绍开发流程。首先打开 Eclipse 并配置 Android SDK 和 NDK 的路径。 选择 Eclipse 的如下菜单：Window =&gt; Preferences =&gt; Android，点击浏览按钮设置 SDK 路径；Window =&gt; Preferences =&gt; Android =&gt; NDK，点击浏览按钮设置 NDK 路径。接下来按照简介中的开发流程图来一步一步介绍 NDK 开发步骤。</p>

<h4>3.3 创建 Android App 并添加 Native Support</h4>

<p>首先用Eclipse 创建一个空的 Android App，命名为 HelloJni。在项目上点击右键，选择 Android Tools =&gt; Add Native Support... ，在弹出的对话框中填入 HelloJni 并确定，会发现项目中多了一个 jni 目录，并自动生成了 HelloJni.cpp 和 Android.mk 文件，分别是我们需要封装的native C++ 代码和编译它的 Makefile 文件。</p>

<h4>3.4 编写 java API</h4>

<p>原本按照图一中的流程我们需要先编写一些 C/C++ 原生的代码，但实际中，为了简便起见，我们可以使用 jdk 的 javah 工具（如果没有， <code>sudo apt-get update</code> 一下）来根据 java 调用 C/C++ API 的接口类来自动生成 jni 的头文件。因此，我们需要先做第3步的内容，这里编写的 Java API 接口 HelloCal 类（在 <code>src/io.ibillxia.hellojni</code> 路径下）如下：</p>

<p>```
//HelloCal.java
package io.ibillxia.hellojni;</p>

<p>public class HelloCal {</p>

<pre><code>static { 
    System.loadLibrary("HelloJni"); // 加载 jni 动态库 
} 

public native String helloSay(); // 返回字符串 
public native int helloAdd(int a,int b); // 两个整数相加 
public native int helloSub(int a,int b); // 两个整数相减 
public native int helloMul(int a,int b); // 两个整数相乘 
public native int helloDiv(int a,int b); // 两个整数相除 
</code></pre>

<p>}
```</p>

<h4>3.5 使用 javah 生成 jni 格式的 C/C++ API</h4>

<p>编写完 java API 后在 Eclipse 中 build 一下生成对应 .class 文件，然后使用 javah 工具根据该 class 文件自动生成 jni API 的头文件。在 HelloJni App 根目录下执行如下命令：</p>

<p><code>
javah -classpath ./bin/classes -d jni io.ibillxia.hellojni.HelloCal
</code></p>

<p>其中 <code>-classpath ./bin/classes</code> 表示类的路径，<code>-d jni</code> 表示生成的头文件存放的目录， <code>io.ibillxia.hellojni.HelloCal</code> 则是完整类名，如果不出意外，在 <code>~/workspace/HelloJni/jni</code> 目录下生成了 <code>io_ibillxia_hellojni_HelloCal.h</code> 。然后根据这个头文件的内容，编写 <code>HelloCal.cpp</code> 文件实现头文件中声明的接口，具体的头文件和 cpp 源文件内容见源码压缩包。值得一提的是，在 cpp 源文件中，对数据运算后可能产生溢出进行了判断，对于溢出异常这里处理的办法是，如果上溢则返回最大值，下溢则返回最小值。实际中，这样做可能还不是很合理，比较好的做法是，在 cpp 中处理并返回异常值，并在相应的 Java API 中针对返回的异常值进行不同的处理，即在 cpp 中只检查异常，而真正处理异常则由 Java API 来处理。</p>

<p>注意，这里需要添加一下 C/C++ 的包含目录，否则会报错。选中 jni文件夹，右键选择 Properties =&gt; C/C++ General =&gt; Paths and Symbols =&gt; Includes，点击 Add 一个一个添加如下依赖库：</p>

<blockquote><p>/usr/include<br/>
/usr/include/c++/4.8<br/>
/usr/include/c++/4.8/backward<br/>
/usr/include/i386-linux-gnu<br/>
/usr/include/i386-linux-gnu/c++/4.8<br/>
/usr/lib/gcc/i686-linux-gnu/4.8/include<br/>
/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed<br/>
/usr/local/include<br/>
/usr/local/adt-x86-20140321/ndk-r9d/platforms/android-19/arch-arm/usr/include</p></blockquote>

<p>添加完后 build 一下，看看是否有错误，如果不出意外，应该在 <code>HelloJni/libs/armeabi/</code> 目录下生成了 <code>libHelloJni.so</code> 文件。</p>

<h4>3.6 编写 Android App</h4>

<p>最后是编写 Android App，并在 App 中调用 Jni 接口函数。在 <code>io.ibillxia.hellojni</code> 包中新建一个 Java 类 HelloJni ，编写如下代码（import 内容省略，具体见源码压缩包）：</p>

<p>```
//HelloJni.java
public class HelloJni extends Activity {</p>

<pre><code>/** Called when the activity is first created. */
@Override
public void onCreate(Bundle savedInstanceState)
{
    super.onCreate(savedInstanceState);
    setContentView(R.layout.hello_jni);

    Button btn = (Button)findViewById(R.id.btn_cal);
    btn.setOnClickListener(new Button.OnClickListener() {
        @Override
        public void onClick(View v) {
            // TODO Auto-generated method stub
            TextView tv1 = (TextView) findViewById(R.id.textView1);
            TextView tv2 = (TextView) findViewById(R.id.textView2);
            TextView tv3 = (TextView) findViewById(R.id.textView3);

            int a = Integer.parseInt(tv1.getText().toString());
            int b = Integer.parseInt(tv2.getText().toString());
            HelloCal cal = new HelloCal();
            int c = cal.helloAdd(a,b);
            String str = cal.helloSay();  
            tv3.setText(str + Integer.toString(c));
        }
    });
}
</code></pre>

<p>}
```</p>

<p>另外，还需要设计对应的 layout xml 文件，具体见源码压缩包。 最后上一张运行效果截图：
<img src="/images/2014/IMAG2014050402.png">
图中输入的两个数的和超过了 int 能表示的最大值，出现上溢，但返回的是最大值。如果输入的两个数本身就超出范围将出现
<code>Unfortunately, HelloJni has stopped.</code> 的异常的对话框。实际过程中，究竟在哪一步检测并处理异常，还是一个值得商讨的问题。如果是引用第三方的库，可能需要对相应的接口提供充分的测试，对于可以并且方便在 native code 层面解决的异常就在 native code 层面上处理掉，实在不行也要在 Java API 层面上解决掉，比如这里需要在 Java 中判断输入参数本身的合法性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给Octopress博客配置Twitter Bootstrap主题]]></title>
    <link href="http://ibillxia.github.io/blog/2014/04/28/configure-twitter-bootstrap-theme-in-octopress/"/>
    <updated>2014-04-28T22:37:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/04/28/configure-twitter-bootstrap-theme-in-octopress</id>
    <content type="html"><![CDATA[<p>很长一段时间以来就看到各种基于 Twitter Bootstrap 主题的博客很清爽，而且对 Tag 的归档也做得很赞，于是很想将自己的博客也换成 Bootstrap 的主题，随着看到的博客越来越多，自己的 Octopress 主题先得越来越臃肿，而 Tags 归档功能也相形见绌，更换主题的欲望越来越强烈了。于是乎，趁这个周末捣鼓了一番，最终大功告成，在这里分享一下具体过程。</p>

<h2>Bootstrap 主题的安装</h2>

<p>首先下载适用于 Octopress 的 <a href="https://github.com/bkutil/bootstrap-theme">Bootstrap主题</a> 并解压缩到博客的 .theme 目录，然后安装：</p>

<p><code>
rake install['bootstrap']
</code></p>

<p>安装的过程中可能会提示有 sass 或其他依赖库的语法错误神马的，这是因为 sass 的版本过低，可以通过如下命令来跟新：</p>

<p><code>
bundle update sass
</code></p>

<!-- more -->


<p>其他库的升级类推。升级完这些依赖后，要修改你的 Octopress 博客的根目录下的 Gemfile 中的版本说明。最后再重新运行上上条的 rake install 指令。这样就完成主体的安装了，是不是很简单（实际操作中遇到问题的话，一般都是 jekyll 等各种的库的版本及相互间的依赖问题，通过 bundle update 基本上都能搞定）。安装完了之后，可以运行 rake generate 和 rake preview 来看看效果了。</p>

<h2>配置 Tags 归档</h2>

<p>接下来是配置类似 <a href="http://ibillxia.github.io/blog/tags/">这种显示结果</a> 的 Tags 归档页面了。</p>

<p>首先，需要安装 <a href="https://github.com/plusjade/jekyll-bootstrap">jekyll-bootstrap</a> 的一些东西，请先下载并解压。主要是 <em>includes/JB/ 目录下的内容，将 JB 文件夹拷贝到 $BLOG_HOME/source/</em>includes/ 目录下，还有 jekyll-bootstrap 根目录下的 tags.html 拷贝到你想展示 Tags 的目录，并在 _config.yml 文件中配置 tag_dir 项的值为该目录，例如我这里的配置是：</p>

<p><code>
tag_dir: blog/tags
</code></p>

<p>所以我的 tags.html 文件放在了 $BLOG_HOME/source/blog/tags 目录下，并将 tags.html 重命名为 index.html。</p>

<p>这些配置好了后，你就可以先运行 rake generate 和 rake preview 来看看效果。可以发现 Tags 归档页的显示还是不太友好。那么我们需要加入一些自己的 css 样式。这里我参考了 pluskid 师兄的博客的 css 代码并略有修改，在我新建的 $BLOG_HOME/source/stylesheets/style.css 文件中加入如下代码：</p>

<p><code>
/* tag_box */
.tag_box {
  list-style:none;
  margin:0;
  padding:2px 0 ;
  overflow:hidden;
}
.tag_box li {
  line-height:20px;
  margin:0;
}
.tag_box.inline li {
  float:left;
  padding:2px 0 ;
}
.tag_box a {
  padding: 2px;
  margin: 2px;
  background: #eee;
  color:#005F6B;
  border-radius: 3px;
  text-decoration:none;
}
.tag_box a span{
  vertical-align:super;
  font-size:0.8em;
}
.tag_box a.active {
  background:#57A957;
  border:1px solid #4C964D;
  color:#FFF;
}
/* tag_box end */
</code></p>

<p>注意，这里由于新加了 css 文件，要让其生效，需要在 html 模板中加入引用，具体我是在 $BLOG_HOME/source/_includes/head.html 文件中加入如下代码：</p>

<p><code>
&lt;link href="/stylesheets/style.css" media="screen, projection" rel="stylesheet" type="text/css"&gt;
</code></p>

<p>你也可以直接在 html 模板中加入 css 代码而不用新建 css 文件并添加引用。</p>

<p>至此，已经配置完成了 ^_^ 可以运行 rake generate 和 rake preview 来看看最终效果了。</p>

<p>PS：本博客的主题及插件相关文件和代码可以看我的 GitHub Repo：<a href="https://github.com/ibillxia/xoctopress/tree/master">xoctopress</a>. 如有问题，可以参考这些代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[全排列及某排列的后继的求解及其STL实现的分析]]></title>
    <link href="http://ibillxia.github.io/blog/2014/04/24/next-permutation-and-analysis-of-its-stl-implementation/"/>
    <updated>2014-04-24T23:24:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/04/24/next-permutation-and-analysis-of-its-stl-implementation</id>
    <content type="html"><![CDATA[<p>在Leetcode上有好几道全排列相关的题，一直以来只是会写基于递归的全排列生成算法，遇到这几道题后，搜了下一些非递归的实现方法，发现其实全排列的生成还是很有规律的有木有！这里就总结一下递归和非递归的全排列生成方法，并分析一下 STL 的实现。</p>

<p>递归和非递归实现全排列生成的方法也分别有多种，递归法有基于交换的，有基于链接的，还有回溯，非递归法有排序、回溯、求模等，关于所有这些方法的具体实现参见 <a href="http://mengliao.blog.51cto.com/876134/824079">全排列的六种算法</a>. 本文只实现一种递归和一种非递归算法，并在最后对 STL 的非递归算法进行分析。</p>

<p>本文的全部代码下载：<a href="http://ibillxia.github.io/upload/code/20140424.cpp">code</a>.</p>

<h2>递归法求全排列</h2>

<p>递归法的基本思路是这样的：</p>

<blockquote><p>首先选一个元素排在第一个（有 n 中选法）；
然后递归的对剩下的所有元素进行全排列；
直到一个元素的全排列是其本身。</p></blockquote>

<p>假设给定的元素序列为 &lt;e1, e2, ..., en>，其全排列表示为 P(e1, e2, ..., en)，则对递归的第一步展开有：</p>

<blockquote><p>P(e1, e2, ..., en) = {
&lt;e1, P(e2, e3, ..., en)>,
&lt;e2, P(e1, e3, ..., en)>,
... ...
&lt;en, P(e1, e2, ..., e(n-1))> }</p></blockquote>

<!-- more -->


<p> 一个简单的实现如下：</p>

<p>```
void recursive_permute(int A[],int i,int n){</p>

<pre><code>if(i==n-1){
    for(int j=0;j&lt;n;j++)
        cout&lt;&lt;A[j]&lt;&lt;" ";
    cout&lt;&lt;endl;
    return;
}
for(int j=i;j&lt;n;j++){
    swap(A[i],A[j]);  // choose A[j] as the ith element
    recursive_permute(A,i+1,n);
    swap(A[i],A[j]);  // reset to enter next for
}
</code></pre>

<p>}
```</p>

<p>这个实现非常精简易懂，但却存在一个问题，那就是当数组 A 中存在重复元素时，得到的排列是有重复的，这是因为在第8行的循环中，可能会选取重复的 A[j] 值。 为了去掉重复排列，我们可以在选取第 i 个数 A[j] 之前（即交换 A[i] 和 A[j] 之前），判断值为 A[j] 的元素是否选取过，即要判断在 A[i] 到 A[j-1] 中是否存在与 A[j] 相等的元素，如果出现过，说明 A[i] 选 A[j] 这个排列已经生成过了，可以直接跳过当前的 A[j] 看看是否可以选取 A[j+1] 作为 A[i] 了。比如上面的 e1 = e2，那么无重复的全排列应该是：</p>

<blockquote><p>P(e1, e2, ..., en) = {
&lt;e1, P(e2, e3, ..., en)>,
&lt;e3, P(e1, e2, e4, ..., en)>,
... ...
&lt;en, P(e1, e2, ..., e(n-1))> }</p></blockquote>

<p>添加这个限制的递归实现代码如下：</p>

<p>```
void recursive_permute2(int A[],int i,int n){</p>

<pre><code>if(i==n-1){
    for(int j=0;j&lt;n;j++)
        cout&lt;&lt;A[j]&lt;&lt;" ";
    cout&lt;&lt;endl;
    return;
}
for(int j=i;j&lt;n;j++){
    int k;
    for(k=i;k&lt;j;k++)if(A[k]==A[j])break; // A[j] already used
    if(k&lt;j)continue;
    swap(A[i],A[j]);  // choose A[j] as the ith element
    recursive_permute2(A,i+1,n);
    swap(A[i],A[j]);  // reset to enter next for
}
</code></pre>

<p>}
```</p>

<p>至此，递归法实现全排列的求解就总结到这儿了，下面来看看非递归怎么实现。</p>

<h2>非递归法求全排列</h2>

<p>非递归法求全排列的一种最常用算法是基于字典序的全排列生成算法，其基本思路为，先解决生成一个序列在字典序下的下一个排列这个问题，然后利用这个来一次求解每一个排列。其中求解给定序列在字典序下的下一个排列序列的基本思想如下：</p>

<blockquote><ol>
<li>对于给定序列 &lt;e1, e2, ..., en> 从右往左找到第一个非递增点，设下标为 i；</li>
<li>从右往左查找第一个比 e[i] 大的数，设其下标为 j;</li>
<li>交换 e[i] 和 e[j] 的值；</li>
<li>将序列 e[i+1..n] 逆置。</li>
</ol>
</blockquote>

<p>举个例子，如下图（修改自 <a href="http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html">Next Permutation 解题报告</a> ）所示：</p>

<center><img src="/images/2014/IMAG2014042401.png"></center>


<p>上面的说明已经很接近伪代码了，具体实现如下：</p>

<p>```
bool next_permute(int A[],int n){</p>

<pre><code>int i,j;
// step .1
if(n&lt;2)return false;
for(i=n-2;i&gt;=0;i--){
    if(A[i]&lt;A[i+1])break;
}
if(i&lt;0)return false; // A[0] is maximum, no next permute for it
// step .2
for(j=n-1;j&gt;i;j--){
    if(A[j]&gt;A[i])break;
}
// step .3
swap(A[i],A[j]);
// step .4
while(++i &lt; --n){
    swap(A[i],A[n]);
}
return true;
</code></pre>

<p>}
```</p>

<p>这里将其返回值定义为 bool 类型，可以方便后面求解全排列时调用：</p>

<p>```
void non_recursive_permute(int A[],int n){</p>

<pre><code>sort(A,A+n);
int i;
do{
    for(i=0;i&lt;n;i++)cout&lt;&lt;A[i]&lt;&lt;" ";
    cout&lt;&lt;endl;
}while(next_permute(A,n));
</code></pre>

<p>}
```</p>

<p>上面这个函数即实现了按字典序生成全排列的功能，而且对于输入含有重复值的情况，不会生成重复的排列。对于非递归实现，很容易分析其时间复杂度，next_permute 的时间复杂度为 O(n)，而 non_recursive_permute 的时间复杂度为 O(n*n!)。</p>

<h2>STL 中 next permute 的实现</h2>

<p>下面来分析一下 STL 中是如何实现 next permute 的，在 stl_algo.h 中我们可以找到 next_permutation 的实现，基本思路也是按照上面的四步走来实现的，具体见如下代码及注释：</p>

<p>```
/<em>*
 *  @brief  Permute range into the next @a dictionary ordering.
 *  @ingroup sorting_algorithms
 *  @param  first  Start of range.
 *  @param  last   End of range.
 *  @return  False if wrapped to first permutation, true otherwise.
 *
 *  Treats all permutations of the range as a set of @a dictionary sorted
 *  sequences.  Permutes the current sequence into the next one of this set.
 *  Returns true if there are more sequences to generate.  If the sequence
 *  is the largest of the set, the smallest is generated and false returned.
</em>/
template<typename _BidirectionalIterator>
bool
next_permutation(_BidirectionalIterator __first,</p>

<pre><code>             _BidirectionalIterator __last)
</code></pre>

<p>{</p>

<pre><code>// concept requirements
__glibcxx_function_requires(_BidirectionalIteratorConcept&lt;
                            _BidirectionalIterator&gt;)
__glibcxx_function_requires(_LessThanComparableConcept&lt;
                            typename iterator_traits&lt;_BidirectionalIterator&gt;::value_type&gt;)
__glibcxx_requires_valid_range(__first, __last);

if (__first == __last)  // 容器中没有元素，没有 next permute
    return false;
_BidirectionalIterator __i = __first;
++__i;
if (__i == __last)  // 容器中只有一个元素，同没有
    return false;
__i = __last;
--__i;  // 将 __i 指向最后一个元素

for(;;) {
    _BidirectionalIterator __ii = __i;  
    --__i;
    if (*__i &lt; *__ii) {  // step .1, 这里的 __i 就相当于上面step 1中的i
        _BidirectionalIterator __j = __last;
        while (!(*__i &lt; *--__j)) {  // step .2, 这里的 __j 就相当上面 step 2中的j
        }
        std::iter_swap(__i, __j);  // step .3 交换
        std::reverse(__ii, __last);  // step .4 逆置
        return true;
    }
    if (__i == __first) {  // 直到 __i = __first 还是没有 *__i &lt; *__ii ，说明序列是递减排列的
        std::reverse(__first, __last); // 本应该没有下一个排列，但这里将字典序中第一个排列作为最后一个排列的 next permute
        return false; // 这里返回 false 而不是 true
    }
}
</code></pre>

<p>}
```</p>

<p>这里是用双向迭代器对容器中的元素进行操作的，一个调用的实例如下：</p>

<p>```
vector&lt;vector<int> > permute(vector<int> &amp;num) {</p>

<pre><code>vector&lt;vector&lt;int&gt; &gt; ans;
sort(num.begin(),num.end());
do{
    ans.push_back(num);
}while(next_permutation(num.begin(),num.end()));
return ans;
</code></pre>

<p>}
```</p>

<p>可以看到，其实 STL 的 next permute 的实现跟我们的非递归算法是一致的。但这里有两个问题：一是，这里看似有二重循环（在 for 中套 while ），但实际上复杂度是 n+n =》 O(n) 的（可以为什么要写成这种二重循环的形式捏？不解）；二是，我们可以看到在 for 循环中，对 __ii 这个变量进行了多次声明，为什么不将其声明放在 for 外面捏？（虽然待排列的元素数 n 不会很大，但这样多次声明一个迭代器变量，虽不会占用过多内存，但在声明时调用构造函数和析构函数也是有一定的时间开销的吧，虽然相对于求全排列的复杂度 O(n*n!) 几乎可以忽略不计）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[原地交换两个变量的值]]></title>
    <link href="http://ibillxia.github.io/blog/2014/04/11/swap-two-variables-in-place/"/>
    <updated>2014-04-11T22:27:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/04/11/swap-two-variables-in-place</id>
    <content type="html"><![CDATA[<h2>引子</h2>

<p>在码代码的过程中，不经意间就会遇到需要交换两个变量的情况，一般情况下都是通过新定义一个同类型的变量来中转，但自己也知道可以不用定义新变量直接原地交换，但具体如何原地交换以及其中可能隐藏的bug却了解得不是很清楚，于是乎google了一下，发现这里面还真是有很多学问呢，这里整理和总结一下。</p>

<p>原地交换两个变量，最主要有加减法和异或法。</p>

<p>本文完整代码链接：<a href="../upload/code/20140411.cpp">20140411.cpp</a></p>

<h2>加减法</h2>

<p>加减法最简单、最好理解了，设待交换的两个变量分别为 a 和 b ，首先将两者的和赋给 a ；然后将 a 与 b的差赋给 b ，这样 b 就是 a 原来的值了；最后再将 a 与 b 的差赋给 a ，这样 a 就是 b 原来的值了。具体代码如下：</p>

<p>```
inline template <class T>
void xswap(T &amp;a,T &amp;b){</p>

<pre><code>a=a+b;
//printf("a=%u\n",a);
b=a-b;
a=a-b;
</code></pre>

<p>}
```</p>

<!-- more -->


<p>当然也可以先减后加：</p>

<p>```
inline template <class T>
void xswap2(T &amp;a,T &amp;b){</p>

<pre><code>a=a-b;
//printf("a=%u\n",a);
b=a+b;
a=b-a;
</code></pre>

<p>}
```</p>

<p>这里实现的原理与先加后减类似。粗一看，这样实现两个变量的原地交换很简单有效。但是，这其中有一个很隐秘的bug，就是溢出的问题，在先加后减的实现中，如果 a 与 b 的和大于该类型的能表示的最大值，会发生神马捏？我写了一个 main 函数来简单的测试了一下：</p>

<p>```
int main()
{</p>

<pre><code>unsigned char a=255,b=1;
printf("a=%u,b=%u\n",a,b);
xswap(a,b);
printf("a=%u,b=%u\n",a,b);
return 0;
</code></pre>

<p>}
```</p>

<p>将上面的 xswap 函数中的注释取消，编译运行后（使用Code::Blocks 13.12 MinGW g++编译），得到如下输出：</p>

<p><code>
a=255,b=1
a=0
a=1,b=255
</code></p>

<p>可以看到其中第2行输出的 a 的值为 0，产生了上溢（如果 a , b 同为负，可能产生下溢）。虽然最后交换的结果还是对的，但溢出的部分可能对内存中其他变量产生不可预测的后果。因此，不建议这么实现原地交换两个变量，如果实在需要用这种方法，一定要在进行加或减之前，判断时候回产生溢出。</p>

<h2>异或法</h2>

<p>异或法的基本原理类似，但还利用了异或的如下两个特性： a ^ 0 = a, a ^ a = 0. 用异或来实现两个变量的交换如下：</p>

<p>```
template <class T>
inline void xswap3(T &amp;a,T &amp;b){</p>

<pre><code>a=a^b;
b=a^b;
a=b^a;
</code></pre>

<p>}
```</p>

<p>由于异或是按位运算的，所以不存在溢出问题。因此，如果一定要原地实现两个变量的交换的话，建议用异或的方法。</p>

<h2>原地交换多个变量</h2>

<p>实际上，我们还可以利用上面的思想，将两个变量扩展到多个变量的原地交换，例如三个变量的交换：</p>

<p>```
template <class T>
inline void swap3(T &amp;a,T &amp;b,T &amp;c){</p>

<pre><code>a=a^b;
b=a^b;
a=b^a;
b=b^c;
c=b^c;
b=b^c;
</code></pre>

<p>}
```</p>

<p>即先交换 a 和 b，再交换 b (=a) 和 c。另外，上面的式子可以简化和压缩到一个式子，具体的技巧读者可以自行google，这里不提倡这么做。</p>

<h2>STL是如何实现swap的</h2>

<p>最后，我们来看看STL标准库是如何实现swap的（这里的实现版本是 move.h 文件中的一个，在 STL 中还有针对 vector, string, tree, map, multimap, deque 的 swap 函数）。</p>

<p>```
/<em>*
*  @brief Swaps two values.
*  @ingroup mutating_algorithms
*  @param  <strong>a  A thing of arbitrary type.
*  @param  </strong>b  Another thing of arbitrary type.
*  @return   Nothing.
</em>/
template<typename _Tp>
inline void
swap(<em>Tp&amp; __a, </em>Tp&amp; <strong>b)
{
  // concept requirements
  </strong>glibcxx_function_requires(_SGIAssignableConcept<_Tp>)</p>

<p>  <em>Tp __tmp = </em>GLIBCXX_MOVE(<strong>a);
  </strong>a = <em>GLIBCXX_MOVE(<strong>b);
  </strong>b = </em>GLIBCXX_MOVE(__tmp);
}
```</p>

<p>可以看到，这里新声明了一个变量 __tmp 来中转。至于为什么没有原地进行交换，一个可能的解释是：对于 inline 函数来说，函数调用的代码会直接被改函数体替换，再经过编译优化，最后可能只需要借助一个寄存器变量就可以实现两个变量的交换了，这是非常快的，与通过按位的异或运算的实现，在性能上区别不是太大。</p>

<h2>update</h2>

<p>关于溢出的更深入的讨论，可以看看陈浩的最新博文 <a href="http://coolshell.cn/articles/11466.html">C语言的整型溢出问题</a> . 这里面有提到溢出的几个危害，还有关于 C 语言标准、编译器对溢出是如何处理和对待的，以及如何写代码实现预先判断溢出。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go并发编程初探]]></title>
    <link href="http://ibillxia.github.io/blog/2014/03/16/go-concurrent-programming-first-try/"/>
    <updated>2014-03-16T23:35:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/03/16/go-concurrent-programming-first-try</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>最近在做的一个项目，需要对大量数据进行一些基本的统计和处理，整个程序的思路很简单，但处理起来却很慢，特别是有二重循环的地方，龟速前进，眼看着16核32线程
的服务器只有一个线程被利用，束手无策。之前一直听说Go是一门对并发编程有很好的支持的语言，七牛的许牛大力推崇Go语言，于是就开始了对Go并行编程的探索之旅。</p>


<center><img src="/images/2014/IMAG2014031601.jpg"></center>




<!--more-->




<h2>一些准备工作</h2>


<p>在正式开始Go并行编程之前，首先我们需要准备Go的编程开发环境：Go编译器、Go编辑器。</br>
在<a href="http://golang.org/">golang的官网</a>上有go的下载链接：</br>
<a href="http://code.google.com/p/go/downloads/list">http://code.google.com/p/go/downloads/list</a></br>
我选择的是go1.2.1.windows-amd64.msi安装包，下载完后直接点击该安装包，按照默认选项安装即可。安装完后，可以在命令行中查看go版本以检查是否安装成功：

```
C:\Users\Bill>go version
go version go1.2.1 windows/amd64
```

然后，我们需要安装一个用于Go开发的IDE。当然也可以用通用的文本编辑器就可以，比如notepad、vi等，但这都是一些轻量级的，对于初学者来说还是不太合适的。
网上有很多推荐的IDE，主要有LiteIDE、Eclipse+Goclipse、GoIde等，以及vim/emacs搭配go插件等，这里我选择的是LiteIDE，下载地址：</br>
<a href="http://sourceforge.net/projects/liteide/files/x21/">http://sourceforge.net/projects/liteide/files/x21/</a></br>
下载安装后，我们就可以开始go编程了。可以先运行一个Hello world程序，这里就不演示了，具体见：<a href="http://tour.golangtc.com/#1">Go 指南</a>
</p>




<p>关于Go的一些特性的介绍这里也不讲了，有兴趣的可以移步酷壳的这两篇文章<a href="http://coolshell.cn/articles/8460.html">Go 语言简介（上）— 语法</a> 
和 <a href="http://coolshell.cn/articles/8489.html">Go 语言简介（下）— 特性</a>。下面我们直接进入Go并发编程。</p>




<h2>Go并发编程</h2>


<h4>#0x01.goroutine</h4>


<p>优雅的并发编程范式，完善的并发支持，出色的并发性能是Go语言区别于其他语言的一大特色。在Go中，通过一种叫做goroutine的go协程这种轻量级线程来支持
并发编程范式。协程是比进程和线程更轻量级的线程，go语言标准库提供的所有系统调用操作都会出让CPU给其他goroutine，协程的切换管理不依赖于系统的线程和
进程，也不依赖于CPU的核心数量。下面我们来看一个简单的goroutine的实例。

```
package main

import "fmt"

func main() {
    arr := [10]int{}
    for i := 0; i < 10; i++ {
        fmt.Print("Result of ", i, ":")
        go func() {
            arr[i] = i + i*i
            fmt.Println(arr[i])
        }()
    }
    fmt.Println("Done")
}
```

Go从main package的main()函数开始执行，这段代码的功能是计算arr[i]=i+i*i，其中i取值从0到9，每一个i计算完后立即输出。其中go为golang的关键字，启动
一个协程（goroutine）。程序的运行的结果是什么呢？我们期望的结果应该是这样的吧：

```
Result of 0:0
Result of 1:2
Result of 2:6
Result of 3:12
Result of 4:20
Result of 5:30
Result of 6:42
Result of 7:56
Result of 8:72
Result of 9:90
Done
```

可是在LiteIDE中运行后，却会发现结果是这样子的：

```
Result of 0:Result of 1:Result of 2:Result of 3:Result of 4:Result of 5:Result of 6:Result of 7:Result of 8:Result of 9:Done
```

这是为神马捏？怎么第9~12行的go func(){...}() 这段代码好像更笨就没有执行嘛？！莫非这是golang的bug？</p>

<p>其实，这与golang的程序执行顺序有关。go程序从初始化main package并执行main()函数开始，当main()函数返回时，程序退出，且程序并不等待其他goroutine
（非主goroutine）结束。于是上面的程序中，主函数虽然启动了10gegoroutine，但都没来得及执行，程序就已经退出了。那么怎么解决这个问题捏？很显然，我们
在退出程序之前，需要判断这些创建的goroutine执行完了没。我们可以用一个全局变量来计数执行了的协程数，如果计数变量小于10，我们就等待或sleep。</p>

<h4>#0x02.并发通讯</h4>
<p>等一等，多个协程读写同一个变量，我们是不是需要对这个变量枷锁呀？答案是肯定的，我们可以采用类似与C/C++的线程通讯、数据共享的思路来实现，如下：

```
package main

import (
    "fmt"
    "runtime"
    "sync"
)

func main() {
    var cnt int = 0  // 全局计数器
    mylock := &sync.Mutex{}  // 互斥锁
    arr := [10]int{}
    for i := 0; i < 10; i++ {
        fmt.Print("Result of ", i, ":")
        go func() {
            arr[i] = i + i*i
            fmt.Println(arr[i])
            mylock.Lock() // 写之前枷锁
            cnt++
            mylock.Unlock() // 写之后释放锁
        }()
    }
    for {
        mylock.Lock() // 读之前枷锁
        temp := cnt
        mylock.Unlock() // 读之后释放锁
        runtime.Gosched() // 协程切换
        if temp >= 10 {
            break
        }
    }
    fmt.Println("Done")
}
```

执行以上程序，应该能够得到我们之前预期的那样的结果吧？可以运行之后，我们发现，结果却是这样的：

```
Result of 0:Result of 1:Result of 2:Result of 3:Result of 4:Result of 5:Result of 6:Result of 7:Result of 8:Result of 9:panic: runtime error: index out of range
...
```

出现了运行时错误，数组下表越界了？！第17行还是没有输出？！经过一番修改，得到如下代码：

```
package main

import (
    "fmt"
    "runtime"
    "sync"
)

func main() {
    var cnt int = 0  // 全局计数器
    mylock := &sync.Mutex{}  // 互斥锁
    arr := [11]int{}
    for i := 0; i < 10; i++ {
        go func() {
            arr[i] = i + i*i
            mylock.Lock() // 写之前枷锁
            cnt++
            mylock.Unlock() // 写之后释放锁
        }()
    }
    for {
        mylock.Lock() // 读之前枷锁
        temp := cnt
        mylock.Unlock() // 读之后释放锁
        runtime.Gosched() // 协程切换
        if temp >= 10 {
            break
        }
    }
    for i := 0; i < 11; i++ {
        fmt.Println("Result of ", i, ":", arr[i])
    }
    fmt.Println("Done")
}
```

这下应该能得到预期的结果了吧。可以运行程序后，有傻眼了，结果是：

```
Result of  0 : 0
Result of  1 : 0
Result of  2 : 0
Result of  3 : 0
Result of  4 : 0
Result of  5 : 0
Result of  6 : 0
Result of  7 : 0
Result of  8 : 0
Result of  9 : 0
Result of  10 : 110
Done
```

神马？arr[0]~arr[9]肿么都是0，肿么会冒出一个arr[10]=110？！即使把第15、16行顺序互换，得到的结果还是一样！！！这真是一场噩梦啊！！！仔细对比许书上的例子，
我们发现，这里使用的是匿名函数创建协程，匿名函数中使用了全局的变量，而每次使用go关键字创建协程后，程序不是继续往下执行，而是继续返回到for这一行来执行，首先i++，
然后判断i<10，成立就继续执行并创建协程，10个协程创建完了之后，才真正开始匿名函数的执行，而此时i已经是10了，对于每一个协程i都是10，因此最终只计算了一个arr[10]=110，
这也是为什么申请10个单位的数组时会出现运行时错误。而这完全不是我们所要的结果，那么怎么办呢？我们不妨用带参数的匿名函数来试试？如下：

```
package main

import (
    "fmt"
    "runtime"
    "sync"
)

func main() {
    var cnt int = 0  // 全局计数器
    mylock := &sync.Mutex{}  // 互斥锁
    arr := [11]int{}
    for i := 0; i < 10; i++ {
        go func(i int) { // 这里的i是形参
            arr[i] = i + i*i
            mylock.Lock() // 写之前枷锁
            cnt++
            mylock.Unlock() // 写之后释放锁
        }(i) // 这里的i是实参
    }
    for {
        mylock.Lock() // 读之前枷锁
        temp := cnt
        mylock.Unlock() // 读之后释放锁
        runtime.Gosched() // 协程切换
        if temp >= 10 {
            break
        }
    }
    for i := 0; i < 11; i++ {
        fmt.Println("Result of ", i, ":", arr[i])
    }
    fmt.Println("Done")
}
```

终于，我们总算得到了想要的结果了，经过不懈努力终于大功告成。这里没创建一个协程，都有一个实参值传给形参，在匿名函数中就不存在共享的全局变量i了。
然而，在让我们回头看看我们的代码，却会发现，这与一般的多线程程序有什么区别的，而且写起来会感觉更麻烦，有过之而无不及啊！</p>

<p>想象一下，在一个大的系统中具有无数的锁、无数的共享变量、无数的业务逻辑与错误处理分支，那将是一场噩梦。这噩梦就是众多C/C++开发者正在经历的，其实Java和C#开发
者也好不到哪里去。Go语言既然以并发编程作为语言的最核心优势，当然不至于将这样的问题用这么无奈的方式来解决。Go语言提供的是另一种通信模型，即以消息机制而非共享
内存作为通信方式。</p>

<h4>#0x03.channel</h4>
<p>Go语言提供的消息通信机制被称为channel，接下来我们将详细介绍channel。现在，让我们用Go语言社区的那句著名的口号来开始这一小节： </br>
<blockquote><p>不要通过共享内存来通信，而应该通过通信来共享内存。</p></blockquote>
channel是Go语言在语言级别提供的goroutine间的通信方式，可以使用channel在两个或多个goroutine之间传递消息。channel是进程内的通信方式，因此通过channel传递
对象的过程和调用函数时的参数传递行为比较一致，比如也可以传递指针等。如果需要跨进程通信，建议用分布式系统的方法来解决，比如使用Socket或者HTTP等通信协议。
channel是类型相关的。也就是说，一个channel只能传递一种类型的值，这个类型需要在声明channel时指定。我们先看下用channel的方式重写上面的例子是什么样子的

```
package main

import "fmt"

func main() {
    chs := make([]chan int, 10) // 申请一个10维的channel数组
    arr := [11]int{}
    for i := 0; i < 10; i++ {
        chs[i] = make(chan int) // 对每个channel初始化
        go func(ch chan int, i int) {
            arr[i] = i + i*i
            ch <- 1  // 写channel，应该在函数体的最后一行，许书（P94，代码清单4-4）上有bug
        }(chs[i], i)
    }
    for _, ch := range chs {
        <-ch // 读channel
    }
    for i := 0; i < 11; i++ {
        fmt.Println("Result of ", i, ":", arr[i])
    }
    fmt.Println("Done")
}
```

在这段代码中，我们给每个goroutine分配了一个channel，在每个goroutine执行完时对该goroutine的channel进行写操作，而在第16行进行读操作，对于每个channel，
只有完成了写操作之后，才可以进行读取，否则会处于阻塞状态。因此在10个goroutine没有执行完之前，main函数是不会退出的。这样是不是比共享内存的方式更简单
而优雅呢？其实，我们还可以对代码继续进行简化，可以将匿名函数的传递的channel参数省去，而在匿名函数内部直接使用全局的chs[i]，匿名函数可以修改为如下：

```
go func(i int) {
    arr[i] = i + i*i
    chs[i] <- 1  // 写channel
}(i)
```

</p>

<p>到这里，go的并行编程基本已经入门了，关于channel的更多详细的用法可以参见参考资料。</p>

<h2>参考资料</h2>
<p>[1] golang 官方主页：<a href="http://golang.org/">http://golang.org/</a></br>
[2] go语言编程，许世伟
</p>

]]></content>
  </entry>
  
</feed>
