<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Program | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/categories/program/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2014-05-18T08:42:29+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入理解C语言的define和内联函数]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/17/insight-into-define-and-inline-function-in-c/"/>
    <updated>2014-05-17T22:43:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/17/insight-into-define-and-inline-function-in-c</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>在 <code>Robert C.Searcord</code> 的 <em>The</em> <em>Cert</em> <em>C</em> <em>Secure</em> <em>Coding</em> <em>Standard</em> 一书中，关于宏定义的规范中第一条就是</p>

<blockquote><p>用内联函数或静态函数替代与函数相似的宏</p></blockquote>

<p>这个规范非常实用。内联函数是C99标准中新增的，当宏定义和内联函数可以互换时，应该优先考虑选择内联函数，这也是为什么在C++标准库函数中 <code>max</code>, <code>min</code>, <code>swap</code> 等都是通过内联函数来实现的原因。 宏定义是完全原封不动的很SB的替换，而内联函数则并非简单的文本替换，而是按函数调用的方式展开。关于内联函数相对于宏替换的优点，在wiki有如下几点的总结：</p>

<ul>
<li>宏调用并不执行类型检查，甚至连正常参数也不检查，但是函数调用却要检查。</li>
<li>C语言的宏使用的是文本替换，可能导致无法预料的后果，因为需要重新计算参数和操作顺序。</li>
<li>在宏中的编译错误很难发现，因为它们引用的是扩展的代码，而不是程序员键入的。</li>
<li>许多结构体使用宏或者使用不同的语法来表达很难理解。内联函数使用与普通函数相同的语言，可以随意的内联和不内联。</li>
<li>内联代码的调试信息通常比扩展的宏代码更有用。</li>
</ul>


<p>其中前面两条很好理解，相信大家应该不陌生，这里主要通过具体讨论一个该书中提到的一个程序实例来感受一下后面几点。</p>

<!-- more -->


<h2>宏定义引起的运行时错误</h2>

<p>下面我们看一个稍微复杂的例子，这个例子是在运行时才出现另我们感到意外的错误（这里的运行时错误并不是指 <code>Runtime Error</code>，么么哒）。</p>

<p>```</p>

<h1>include &lt;stdio.h></h1>

<p>int count=0;</p>

<p>void g(void){</p>

<pre><code>printf("Called g, count=%d.\n",count);
</code></pre>

<p>}</p>

<h1>define EXEC_BUMP(func) (func(),++count)</h1>

<p>typedef void(*exec_func)(void);  // 定义函数指针类型
inline void exec_bump(exec_func f){</p>

<pre><code>f();
++count;
</code></pre>

<p>}</p>

<p>int main(void)
{</p>

<pre><code>int count=0;
while(count++&lt;10){
    //EXEC_BUMP(g);  // (1) 宏定义实现
    exec_bump(g);    // (2) 内联实现
}
return 0;
</code></pre>

<p>}
```</p>

<p>使用宏定义的实现得到输出如下：</p>

<p><code>
Called g, count=0.
Called g, count=0.
Called g, count=0.
Called g, count=0.
Called g, count=0.
</code></p>

<p>这并不是我们想要的结果。而使用内联函数实现得到的输出如下：</p>

<p><code>
Called g, count=0.
Called g, count=1.
Called g, count=2.
Called g, count=3.
Called g, count=4.
Called g, count=5.
Called g, count=6.
Called g, count=7.
Called g, count=8.
Called g, count=9.
</code></p>

<p>这才是我们想要的结果。根据这两个输出结果，我们可以分析宏定义和内联的区别。通过宏定义时，直接使用 <code>(g(),++count);</code> 替换 <code>EXEC_BUMP(g);</code> 即可，这样每次调用 <code>g()</code> 函数时输出的 <code>count</code> 是全局的变量，所以都是0；而调用完 <code>g()</code> 函数之后，对局部变量 <code>count</code> 进行了自加操作，所以循环了5次。然而使用内联函数实现时，是按照函数调用的方式展开的，首先将全局变量和内联函数的传入参数压栈，然后是执行函数体，最后参数出栈；因此，内联函数中调用 <code>g()</code> 函数时输出的 <code>count</code> 也是全局变量，而且在内联函数中的 <code>++count</code> 也是对全局变量的操作，因此每次调用时输出的计数变量是递增的。  由此，我们可以更清楚的理解内联函数的替换原理了，它是由编译器显式地将函数调用中的压栈、函数体、出栈等步骤生成到可执行文件中，而不是像普通函数那样，函数体与调用该函数的代码部分是分离的，在调用内联函数时不需要跳转，因而执行效率会比普通的函数要高。（然而，如果函数本身代码较多，如果使用内联，就会在可执行文件中多个地方有该内联函数的函数体，这样可执行文件的大小就会比不使用内联的大。因此，一般不会将函数体复杂的函数定义为内联函数，除非特殊情况下，为了运行时间性能的考虑）</p>

<h2>宏定义的典型应用场景</h2>

<p>上面主要是对宏定义的贬低和歧视，其实宏定义也并非毫无用武之地，下面几种情况下宏定义还是不可替代的：</p>

<p>（1）用于实现局部函数<br/>
此时无法用内联函数替代宏定义。因为宏定义代码块中的自动变量可以和引用宏的前后代码块互为使用，即宏引用前的代码快中的自动变量可以在宏中直接使用，而宏中定义的自动变量可以在宏引用的代码块之后使用。例如，比较常见是：</p>

<p>```</p>

<h1>include &lt;stdio.h></h1>

<h1>define FOR(i,n) for(int i=0;i&lt;n;i++)  // 宏定义部分</h1>

<p>int main(){</p>

<pre><code>int a[]={1,2,3,4,5};
FOR(j,5) // 宏引用，这里j是在宏中才定义的自动变量
    printf("%d ",a[j]);  // 但是可以在宏引用之后的代码中使用
return 0;
</code></pre>

<p>}
```</p>

<p>其中对临时变量 <code>j</code> 的声明是在宏中定义的，可以在宏调用完后使用这个变量。同样的，也可以在宏定义前声明临时变量，而直接在宏中使用（不需要作为参数传递给宏）。</p>

<p>（2）宏可以支持某种形式的惰式计算
例如：</p>

<p>```</p>

<h1>define SELECT(s,v1,v2) ((s)?(v1):(v2))</h1>

<p>```</p>

<p>这个是无法用内联实现的。</p>

<p>(3)宏定义可以产生编译时常量
例如：</p>

<p>```</p>

<h1>define ADD(a,b) ((a)+(b))</h1>

<p>```</p>

<p>调用 <code>ADD(3,4)</code> 会产生一个常量表达式 <code>3+4</code> ，而内联无此效果。</p>

<p>（4）实现类型通用的函数<br/>
如果不借助C++模板这样的机制，C语言内联是无法实现这样的功能的，而只能针对不同的数据类型定义不同名的函数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ 应用程序性能优化之 new/delete 操作符]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/11/cpp-program-optimization-new-delete-operator/"/>
    <updated>2014-05-11T20:33:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/11/cpp-program-optimization-new-delete-operator</id>
    <content type="html"><![CDATA[<h2>1.概述</h2>

<p>C++ 程序的存储空间可以分为静态/全局存储区、栈区和堆区。下图展示了一个典型的Linux C/C++ 程序内存空间布局：</p>

<center><img src="/images/2014/IMAG2014051101.png"></center>


<p>其中，每一部分的具体涵义如下：<br/>
- <strong>代码段（.text）</strong>：这里存放的是CPU要执行的指令。代码段是可共享的，相同的代码在内存中只会有一个拷贝，同时这个段是<strong>只读</strong>的，防止程序由于错误而修改自身的指令。<br/>
- <strong>初始化数据段（.data）</strong>：这里存放的是程序中需要明确赋初始值的变量，例如位于所有函数之外的全局变量：<code>int val=100;</code> 。 需要强调的是，以上两段都是位于程序的可执行文件中，内核在调用 exec 函数启动该程序时从源程序文件中读入。<br/>
- <strong>未初始化数据段（.bss）</strong>：位于这一段中的数据，内核在执行该程序前，将其初始化为0或者null。例如出现在任何函数之外的全局变量：<code>int sum;</code><br/>
- <strong>堆（Heap）</strong>：这个段用于在程序中进行动态内存申请，例如经常用到的 malloc，new 系列函数就是从这个段中申请内存。<br/>
- <strong>栈（Stack）</strong>：函数中的局部变量以及在函数调用过程中产生的临时变量都保存在此段中。<br/>
静态/全局存储区和栈区一般在程序编译阶段决定；而堆区则随着程序的运行而动态变化，每一次程序运行都会有不同的行为，因此动态内存管理对于一个程序在运行过程中占用的内存大小及程序运行性能有非常重要的影响。 本文主要探讨在C++中如何管理动态内存，以及如何使用 C++ 的语言特性来提高动态内存的管理效率，减少错误的发生。</p>

<!-- more -->


<h2>2. new/delete 操作符</h2>

<h4>2.1 C++内置new/delete的原型</h4>

<p>一般来说 C++ 的运行库提供了默认的全局 <code>new/new[]</code> 和 <code>delete/delete[]</code> 的实现，程序也可以用自定义的实现来取代运行库的实现。 下面是 C++ 标准中定义的 <code>new/new[]</code> 和 <code>delete/delete[]</code> 的声明（位于 <code>include/c++/new</code> 文件中）：</p>

<p>```
namespace std {
  class bad_alloc : public exception {</p>

<pre><code>public:
  bad_alloc() throw() { }
  virtual ~bad_alloc() throw();
  virtual const char* what() const throw();
</code></pre>

<p>  };
  struct nothrow_t { };
  extern const nothrow_t nothrow;
  typedef void (*new_handler)();
  new_handler set_new_handler(new_handler) throw();
} // namespace std</p>

<p>void<em> operator new(std::size_t) throw (std::bad_alloc);  // (1)
void</em> operator new<a href="std::size_t"></a> throw (std::bad_alloc);
void operator delete(void<em>) throw();
void operator delete<a href="void*"></a> throw();
void</em> operator new(std::size_t, const std::nothrow_t&amp;) throw();  // (2)
void<em> operator new<a href="std::size_t,%20const%20std::nothrow_t&amp;"></a> throw();
void operator delete(void</em>, const std::nothrow_t&amp;) throw();
void operator delete<a href="void*,%20const%20std::nothrow_t&amp;"></a> throw();
// Default placement versions of operator new.
inline void<em> operator new(std::size_t, void</em> <strong>p) throw() { return </strong>p; }  // (3)
inline void<em> operator new<a href="std::size_t,%20void*%20__p"></a> throw() { return __p; }
// Default placement versions of operator delete.
inline void  operator delete  (void</em>, void*) throw() { }
inline void  operator delete<a href="void*,%20void*"></a> throw() { }
```</p>

<p>其中最后的 <code>inline</code> 函数是 <code>placement</code> 版本的 new/delete 操作，其特点在于分配的内存块的起始地址由用户给定（通过参数 <code>void* __p</code>）。 而前面两种 <code>new/delete</code> （(1)和(2)处）是系统决定待分配内存块的起始地址，区别在于：第一个在分配失败是会抛出 <code>bad_alloc</code> 异常（这是C++标准要求的）；而第二个则不抛出异常，返回0。 很多应用程序都没有处理内存分配的失败情况，但相对于一个需要长期稳定运行的系统来说，这种处理是必不可少的。 应用程序可以通过捕获 <code>bad_alloc</code> 异常或者检查返回值来检查内存分配是否成功，而更好的方法是使用C++中的 <code>new_handler()</code> 函数。 C++规定 <code>new_handler</code> 要执行如下操作中的一种：</p>

<ul>
<li>使 <code>new</code> 有更多的内存可用，然后返回</li>
<li>抛出一个 <code>bad_alloc</code> 或其派生类的异常</li>
<li>调用 <code>abort()</code> 或者 <code>exit()</code> 退出</li>
</ul>


<h4>2.2 使用 <code>new_handler</code> 自定义异常处理</h4>

<p>下面看一个例子，看看如何使用 <code>new_handler</code> 处理内存分配失败的情况：</p>

<p>```</p>

<h1>include<new></h1>

<h1>include<cstdio></h1>

<h1>include&lt;Windows.h></h1>

<p>using namespace std;
char *gPool = NULL;
void my_new_handler();</p>

<p>int main(){</p>

<pre><code>set_new_handler(my_new_handler);
gPool = new char[512*1024*1024];
if(gPool!=NULL){
    printf("Preserve 512MB memory at %x.\n",gPool);
}
char *p = NULL;
for(int i=0;i&lt;4;i++){
    p = new char[512*1024*1024];
    printf("%d * 512M, p = %x\n",i+1,p);
    Sleep(5000); // 休眠5s
}
printf("Done.\n");
return 0;
</code></pre>

<p>}</p>

<p>void my_new_handler(){</p>

<pre><code>if(gPool!=NULL){
    printf("try to get more memory...\n");
    delete[] gPool; // 释放512MB内存空间
    gPool = NULL;
    return;
}else{
    printf("I can not help...\n");
    throw bad_alloc();  // 分配失败，抛出异常
}
return;
</code></pre>

<p>}
```</p>

<p>在 Windows 上编译并运行（使用Code::Blocks 13.12 IDE），得到如下输出：</p>

<p>```
Preserve 512MB memory at 7e0020.
1 * 512M, p = 207f0020
2 * 512M, p = 40800020
try to get more memory...
3 * 512M, p = 7e0020
I can not help...
terminate called after throwing an instance of 'std::bad_alloc'
  what():  std::bad_alloc</p>

<p>This application has requested the Runtime to terminate it in an unusual way.
Please contact the application's support team for more information.
```</p>

<p>在 Windows 的 win32 程序中，一个进程可以访问的内存空间是 4GB，但可以用来动态分配的最大内存是 2GB，因而上面的程序执行到第3次（为神马不是第4次？）动态内存分配时由于内存不够，调用了 <code>my_new_handler</code> 获得了内存（可以看到第3次分配的内存的地址和Preserve的内存地址是一样的），而当执行第4次内存分配时，<code>gPool</code> 已被分配，于是 <code>my_new_handler</code> 中抛出了 <code>bad_alloc</code> 异常，导致程序退出。 另外，在程序实际运行过程当中，会发现任务管理器中内存占用不会往上飙，这可能是因为操作系统的动态内存管理策略在作怪，不会说你一申请就立马全部给你，只是建立了一个映射表，只有当你真正用的时候才会给你。</p>

<h4>2.3 使用 placement new</h4>

<p>在 C++ 内置 <code>new/delete</code> 中最后的一种是 placement 形式的 <code>new/delete</code> ，即分配的内存地址有用户给定。下面是一个最简单的实例：</p>

<p>```</p>

<h1>include <cstdio></h1>

<h1>include <new></h1>

<p>using namespace std;</p>

<p>int main()
{</p>

<pre><code>char buffer[100];
char *p = new(buffer) char[20]; // call placement new
printf("Address of buffer: %x, and p: %x.\n",buffer,p);
return 0;
</code></pre>

<p>}
// output: Address of buffer: 28feb8, and p: 28feb8.
```</p>

<p>可以看到 <code>buffer</code> 和 <code>p</code> 的地址是一样的。在大型应用程序中，我们可以充分利用 <code>placement new</code> 的特性，实现自己管理（分配、释放等）本应用的内存空间，基本思路就是： 首先申请一大片内存，然后对每个小的动态内存分配都使用 <code>placement new</code> 的方式进行申请。</p>

<h4>2.4 重载 placement new</h4>

<p>在 <code>new</code> 操作符中，除了可以使用自定义申请的内存的大小及位置，我们还可以通过重载系统的 <code>new/delete</code> 操作符来加入其它一些附加参数，但仍称之为 <code>placement new</code> 。例如：</p>

<p>```</p>

<h1>include<cstdio></h1>

<h1>include<new></h1>

<p>using namespace std;</p>

<h1>define DEBUG</h1>

<h1>ifdef DEBUG</h1>

<p>// 自定义 new 操作符
void *operator new<a href="unsigned%20int%20n,%20const%20char*%20file,%20int%20line"></a>{</p>

<pre><code>printf("Alloc size: %d at file %s, in line %d\n",n,file,line);
return ::operator new(n);
</code></pre>

<p>}
// 自定义 delete 操作符
// void operator delete(void <em>p,const char </em>file, int line){
void operator delete<a href="void%20*p,const%20char%20*file,%20int%20line"></a>{</p>

<pre><code>printf("delete at file %s, in line %d\n",file,line);
::operator delete(p);
return;
</code></pre>

<p>}
// 宏定义，必须放在重载函数之后</p>

<h1>define new new(<strong>FILE</strong>, <strong>LINE</strong>)</h1>

<h1>define delete delete(<strong>FILE</strong>, <strong>LINE</strong>)</h1>

<h1>endif</h1>

<p>int main(){</p>

<pre><code>char *p = new char[10];
//delete p;  // delete 的重载还有问题 "error: type 'int' argument given to 'delete', expected pointer"
delete[] p;  // 直接报语法错误，"error: expected primary-expression before ']' token"
return 0;
</code></pre>

<p>}
// output: Alloc size: 10 at file D:\Programs\test\main.cpp, in line 22
```</p>

<p>这在 <code>DEBUG</code> 模式下非常好使。</p>

<p>更新：关于 <code>placement new</code> 的 demo 改为如下代码后就没问题了：</p>

<p>```</p>

<h1>include<cstdio></h1>

<h1>include<new></h1>

<p>using namespace std;</p>

<h1>define DEBUG</h1>

<h1>ifdef DEBUG</h1>

<p>// 自定义 new 操作符
void *operator new<a href="unsigned%20int%20n,%20const%20char*%20file,%20int%20line"></a>{</p>

<pre><code>printf("Alloc size: %d at file %s, in line %d\n",n,file,line);
return ::operator new(n);
</code></pre>

<p>}
// 自定义 delete 操作符
void operator delete(void <em>p,char </em>file, int line){</p>

<pre><code>printf("Delete at file %s, in line %d\n",file,line);
::operator delete(p);
return;
</code></pre>

<p>}
// 宏定义，必须放在重载函数之后</p>

<h1>define new new(<strong>FILE</strong>, <strong>LINE</strong>)</h1>

<h1>define delete(ptr) delete(ptr,<strong>FILE</strong>, <strong>LINE</strong>)</h1>

<h1>endif</h1>

<p>int main(){</p>

<pre><code>char *p = new char[10];
operator delete(p);
return 0;
</code></pre>

<p>}
```</p>

<p>但是还是不知道之前的代码为什么会出现这个错误，已在 <a href="http://stackoverflow.com/questions/23614215/destructor-error-in-c-type-int-argument-given-to-delete-expected-pointer">StackOverFlow上提问</a>，希望能得到满意的答案。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu 下 Android NDK 开发入门]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/04/android-ndk-development/"/>
    <updated>2014-05-04T23:53:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/04/android-ndk-development</id>
    <content type="html"><![CDATA[<p>本文首先介绍一下在 Ubuntu 下如何配置 Android NDK 开发环境，然后用一个简单的 hello-jni 项目来介绍 NDK 开发流程，本文的全部代码下载链接：<a href="http://ibillxia.github.io/upload/code/20140504-HelloJni.tar.gz">HelloJni.tar.gz</a>，也可以在我的 <a href="https://github.com/ibillxia/Demo/tree/master/HelloJni">GitHub</a> 上下载。</p>

<h2>1. 简介</h2>

<p>什么是 Android NDK 呢？ NDK(Native Development Kit) 是一个允许开发者用一些本地语言(C/C++)编写 Android App 的部分功能的工具集。对于一些特定的 App，NDK 非常有利于我们直接使用现成的用 C/C++ 编写的代码库（但对于大多数 App 来说，NDK 是没有必要的）。使用 NDK 进行 C/C++ Android 开发的基本结构和流程如下图（来自<a href="http://shihongzhi.com/ndk/">shihongzhi博客</a> ）：</p>

<center> <img src="/images/2014/IMAG2014050401.jpg"> </center>


<p>在开始之前，这里要提醒大家：NDK 对大多数 App 而言是不会有太多的好处的，在 Android 上使用原生 C/C++ 代码并不会很明显的提升应用的性能，但却增加了你开发应用的复杂度。所以，仅仅在需要使用 NDK 时才使用它 —— 不要因为你更喜欢用 C/C++。典型的 NDK 应用场景是一些 CPU 操作密集而不需要太多内存的场合，如信号处理、物理模拟等等，很多这些处理过程都已经封装到了 Android 系统内部，所以当你不确定是否要使用本地 C/C++ 代码时，先看看你的需求，以及 Android 框架中的 API 是否已经提供你需要的功能。</p>

<!-- more -->


<h2>2.开发环境配置</h2>

<p>由于 NDK 开发过程中涉及到将 C/C++ 程序编译为动态库(.so文件)，所以首先系统中需要安装 C/C++ 的编译工具 gcc/g++，还要有 make 工具，一般情况下 Linux 系统会默认安装，如果没有安装请先安装这几个工具。然后是 Java 和 Android 开发相关环境的配置。首先需要安装 JDK，并配置 Java 的环境变量，然后是集成开发环境如 Eclipse 的安装和配置，这些也不是本文的重点，如果你没有安装，请自行 google 并安装配置好。</p>

<p>下面重点讲讲 Android 相关 SDK 的安装和配置，主要涉及到 Android SDK，ADT，NDK等。要进行 Android 开发，首先需要安装 Android SDK，要在 Eclipse 中进行开发的话，还需在 Eclipse 中安装 ADT(Android Develop Tools)，在 Android 官网上提供了 SDK 和 包含 ADT 的 Eclipse 的集成开发包，可以一起下载：<a href="http://dl.google.com/android/adt/22.6.2/adt-bundle-linux-x86-20140321.zip">adt-bundle-linux-x86-20140321.zip</a>。另外，还需要安装 NDK，下载地址：<a href="http://dl.google.com/android/ndk/android-ndk-r9d-linux-x86.tar.bz2">android-ndk-r9d-linux-x86.tar.bz2</a>。下载完这两个压缩包后解压并移动到 /usr/local 目录下：</p>

<p><code>
sudo mv Downloads/adt-bundle-x86-20140321/ /usr/local/adt-x86-20140321
mv Downloads/android-ndk-r9d/ /usr/local/adt-x86-20140321/ndk-r9d
</code></p>

<p>然后配置环境变量：</p>

<p><code>
sudo vim /etc/profile
</code></p>

<p>在 /etc/profile 最后添加如下两行：</p>

<p><code>
export PATH=/usr/local/adt-x86-20140321/sdk/tools:/usr/local/adt-x86-20140321/sdk/platform-tools:$PATH
export PATH=/usr/local/adt-x86-20140321/ndk-r9d:$PATH
</code></p>

<p>保存并退出，并用如下命令使设置生效：</p>

<p><code>
source /etc/profile
</code></p>

<p>完了可以执行如下命令看看设置是否生效：</p>

<p><code>
echo $PATH
adb --version
emulator -version
ndk-build --version
</code></p>

<p>至此，开发环境已经配置完成了，接下来我们看一个 hello-jni 的例子。</p>

<h2>3.NDK 开发实例 hello-jni</h2>

<h4>3.1 JNI 简介</h4>

<p>首先我们了解一下什么是JNI。JNI(Java Native Interface)是一种在Java虚拟机控制下执行代码的标准机制。 代码被编写成汇编程序或者C/C++程序，并组装为动态库，从而提供了一个在Java平台上调用C/C++的一种途径。 JNI主要的竞争优势在于：它在设计之初就确保了二进制的兼容性，JNI编写的应用程序兼容性以及在某些具体平台上的Java虚拟机兼容性（当谈及JNI，这里并不特别针对Dalvik；JNI由Oracle开发，适用于所有Java虚拟机）。 关于JNI的更多内容可以参见该文：<a href="http://www.importnew.com/8038.html">Android NDK介绍</a>。</p>

<h4>3.2 Eclipse 配置</h4>

<p>下面以参考 Android NDK 自带的 hello-jni 示例程序改写的我自己的 hello-jni 来介绍开发流程。首先打开 Eclipse 并配置 Android SDK 和 NDK 的路径。 选择 Eclipse 的如下菜单：Window =&gt; Preferences =&gt; Android，点击浏览按钮设置 SDK 路径；Window =&gt; Preferences =&gt; Android =&gt; NDK，点击浏览按钮设置 NDK 路径。接下来按照简介中的开发流程图来一步一步介绍 NDK 开发步骤。</p>

<h4>3.3 创建 Android App 并添加 Native Support</h4>

<p>首先用Eclipse 创建一个空的 Android App，命名为 HelloJni。在项目上点击右键，选择 Android Tools =&gt; Add Native Support... ，在弹出的对话框中填入 HelloJni 并确定，会发现项目中多了一个 jni 目录，并自动生成了 HelloJni.cpp 和 Android.mk 文件，分别是我们需要封装的native C++ 代码和编译它的 Makefile 文件。</p>

<h4>3.4 编写 java API</h4>

<p>原本按照图一中的流程我们需要先编写一些 C/C++ 原生的代码，但实际中，为了简便起见，我们可以使用 jdk 的 javah 工具（如果没有， <code>sudo apt-get update</code> 一下）来根据 java 调用 C/C++ API 的接口类来自动生成 jni 的头文件。因此，我们需要先做第3步的内容，这里编写的 Java API 接口 HelloCal 类（在 <code>src/io.ibillxia.hellojni</code> 路径下）如下：</p>

<p>```
//HelloCal.java
package io.ibillxia.hellojni;</p>

<p>public class HelloCal {</p>

<pre><code>static { 
    System.loadLibrary("HelloJni"); // 加载 jni 动态库 
} 

public native String helloSay(); // 返回字符串 
public native int helloAdd(int a,int b); // 两个整数相加 
public native int helloSub(int a,int b); // 两个整数相减 
public native int helloMul(int a,int b); // 两个整数相乘 
public native int helloDiv(int a,int b); // 两个整数相除 
</code></pre>

<p>}
```</p>

<h4>3.5 使用 javah 生成 jni 格式的 C/C++ API</h4>

<p>编写完 java API 后在 Eclipse 中 build 一下生成对应 .class 文件，然后使用 javah 工具根据该 class 文件自动生成 jni API 的头文件。在 HelloJni App 根目录下执行如下命令：</p>

<p><code>
javah -classpath ./bin/classes -d jni io.ibillxia.hellojni.HelloCal
</code></p>

<p>其中 <code>-classpath ./bin/classes</code> 表示类的路径，<code>-d jni</code> 表示生成的头文件存放的目录， <code>io.ibillxia.hellojni.HelloCal</code> 则是完整类名，如果不出意外，在 <code>~/workspace/HelloJni/jni</code> 目录下生成了 <code>io_ibillxia_hellojni_HelloCal.h</code> 。然后根据这个头文件的内容，编写 <code>HelloCal.cpp</code> 文件实现头文件中声明的接口，具体的头文件和 cpp 源文件内容见源码压缩包。值得一提的是，在 cpp 源文件中，对数据运算后可能产生溢出进行了判断，对于溢出异常这里处理的办法是，如果上溢则返回最大值，下溢则返回最小值。实际中，这样做可能还不是很合理，比较好的做法是，在 cpp 中处理并返回异常值，并在相应的 Java API 中针对返回的异常值进行不同的处理，即在 cpp 中只检查异常，而真正处理异常则由 Java API 来处理。</p>

<p>注意，这里需要添加一下 C/C++ 的包含目录，否则会报错。选中 jni文件夹，右键选择 Properties =&gt; C/C++ General =&gt; Paths and Symbols =&gt; Includes，点击 Add 一个一个添加如下依赖库：</p>

<blockquote><p>/usr/include<br/>
/usr/include/c++/4.8<br/>
/usr/include/c++/4.8/backward<br/>
/usr/include/i386-linux-gnu<br/>
/usr/include/i386-linux-gnu/c++/4.8<br/>
/usr/lib/gcc/i686-linux-gnu/4.8/include<br/>
/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed<br/>
/usr/local/include<br/>
/usr/local/adt-x86-20140321/ndk-r9d/platforms/android-19/arch-arm/usr/include</p></blockquote>

<p>添加完后 build 一下，看看是否有错误，如果不出意外，应该在 <code>HelloJni/libs/armeabi/</code> 目录下生成了 <code>libHelloJni.so</code> 文件。</p>

<h4>3.6 编写 Android App</h4>

<p>最后是编写 Android App，并在 App 中调用 Jni 接口函数。在 <code>io.ibillxia.hellojni</code> 包中新建一个 Java 类 HelloJni ，编写如下代码（import 内容省略，具体见源码压缩包）：</p>

<p>```
//HelloJni.java
public class HelloJni extends Activity {</p>

<pre><code>/** Called when the activity is first created. */
@Override
public void onCreate(Bundle savedInstanceState)
{
    super.onCreate(savedInstanceState);
    setContentView(R.layout.hello_jni);

    Button btn = (Button)findViewById(R.id.btn_cal);
    btn.setOnClickListener(new Button.OnClickListener() {
        @Override
        public void onClick(View v) {
            // TODO Auto-generated method stub
            TextView tv1 = (TextView) findViewById(R.id.textView1);
            TextView tv2 = (TextView) findViewById(R.id.textView2);
            TextView tv3 = (TextView) findViewById(R.id.textView3);

            int a = Integer.parseInt(tv1.getText().toString());
            int b = Integer.parseInt(tv2.getText().toString());
            HelloCal cal = new HelloCal();
            int c = cal.helloAdd(a,b);
            String str = cal.helloSay();  
            tv3.setText(str + Integer.toString(c));
        }
    });
}
</code></pre>

<p>}
```</p>

<p>另外，还需要设计对应的 layout xml 文件，具体见源码压缩包。 最后上一张运行效果截图：
<img src="/images/2014/IMAG2014050402.png">
图中输入的两个数的和超过了 int 能表示的最大值，出现上溢，但返回的是最大值。如果输入的两个数本身就超出范围将出现
<code>Unfortunately, HelloJni has stopped.</code> 的异常的对话框。实际过程中，究竟在哪一步检测并处理异常，还是一个值得商讨的问题。如果是引用第三方的库，可能需要对相应的接口提供充分的测试，对于可以并且方便在 native code 层面解决的异常就在 native code 层面上处理掉，实在不行也要在 Java API 层面上解决掉，比如这里需要在 Java 中判断输入参数本身的合法性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给Octopress博客配置Twitter Bootstrap主题]]></title>
    <link href="http://ibillxia.github.io/blog/2014/04/28/configure-twitter-bootstrap-theme-in-octopress/"/>
    <updated>2014-04-28T22:37:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/04/28/configure-twitter-bootstrap-theme-in-octopress</id>
    <content type="html"><![CDATA[<p>很长一段时间以来就看到各种基于 Twitter Bootstrap 主题的博客很清爽，而且对 Tag 的归档也做得很赞，于是很想将自己的博客也换成 Bootstrap 的主题，随着看到的博客越来越多，自己的 Octopress 主题先得越来越臃肿，而 Tags 归档功能也相形见绌，更换主题的欲望越来越强烈了。于是乎，趁这个周末捣鼓了一番，最终大功告成，在这里分享一下具体过程。</p>

<h2>Bootstrap 主题的安装</h2>

<p>首先下载适用于 Octopress 的 <a href="https://github.com/bkutil/bootstrap-theme">Bootstrap主题</a> 并解压缩到博客的 .theme 目录，然后安装：</p>

<p><code>
rake install['bootstrap']
</code></p>

<p>安装的过程中可能会提示有 sass 或其他依赖库的语法错误神马的，这是因为 sass 的版本过低，可以通过如下命令来跟新：</p>

<p><code>
bundle update sass
</code></p>

<!-- more -->


<p>其他库的升级类推。升级完这些依赖后，要修改你的 Octopress 博客的根目录下的 Gemfile 中的版本说明。最后再重新运行上上条的 rake install 指令。这样就完成主体的安装了，是不是很简单（实际操作中遇到问题的话，一般都是 jekyll 等各种的库的版本及相互间的依赖问题，通过 bundle update 基本上都能搞定）。安装完了之后，可以运行 rake generate 和 rake preview 来看看效果了。</p>

<h2>配置 Tags 归档</h2>

<p>接下来是配置类似 <a href="http://ibillxia.github.io/blog/tags/">这种显示结果</a> 的 Tags 归档页面了。</p>

<p>首先，需要安装 <a href="https://github.com/plusjade/jekyll-bootstrap">jekyll-bootstrap</a> 的一些东西，请先下载并解压。主要是 <em>includes/JB/ 目录下的内容，将 JB 文件夹拷贝到 $BLOG_HOME/source/</em>includes/ 目录下，还有 jekyll-bootstrap 根目录下的 tags.html 拷贝到你想展示 Tags 的目录，并在 _config.yml 文件中配置 tag_dir 项的值为该目录，例如我这里的配置是：</p>

<p><code>
tag_dir: blog/tags
</code></p>

<p>所以我的 tags.html 文件放在了 $BLOG_HOME/source/blog/tags 目录下，并将 tags.html 重命名为 index.html。</p>

<p>这些配置好了后，你就可以先运行 rake generate 和 rake preview 来看看效果。可以发现 Tags 归档页的显示还是不太友好。那么我们需要加入一些自己的 css 样式。这里我参考了 pluskid 师兄的博客的 css 代码并略有修改，在我新建的 $BLOG_HOME/source/stylesheets/style.css 文件中加入如下代码：</p>

<p><code>
/* tag_box */
.tag_box {
  list-style:none;
  margin:0;
  padding:2px 0 ;
  overflow:hidden;
}
.tag_box li {
  line-height:20px;
  margin:0;
}
.tag_box.inline li {
  float:left;
  padding:2px 0 ;
}
.tag_box a {
  padding: 2px;
  margin: 2px;
  background: #eee;
  color:#005F6B;
  border-radius: 3px;
  text-decoration:none;
}
.tag_box a span{
  vertical-align:super;
  font-size:0.8em;
}
.tag_box a.active {
  background:#57A957;
  border:1px solid #4C964D;
  color:#FFF;
}
/* tag_box end */
</code></p>

<p>注意，这里由于新加了 css 文件，要让其生效，需要在 html 模板中加入引用，具体我是在 $BLOG_HOME/source/_includes/head.html 文件中加入如下代码：</p>

<p><code>
&lt;link href="/stylesheets/style.css" media="screen, projection" rel="stylesheet" type="text/css"&gt;
</code></p>

<p>你也可以直接在 html 模板中加入 css 代码而不用新建 css 文件并添加引用。</p>

<p>至此，已经配置完成了 ^_^ 可以运行 rake generate 和 rake preview 来看看最终效果了。</p>

<p>PS：本博客的主题及插件相关文件和代码可以看我的 GitHub Repo：<a href="https://github.com/ibillxia/xoctopress/tree/master">xoctopress</a>. 如有问题，可以参考这些代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[全排列及某排列的后继的求解及其STL实现的分析]]></title>
    <link href="http://ibillxia.github.io/blog/2014/04/24/next-permutation-and-analysis-of-its-stl-implementation/"/>
    <updated>2014-04-24T23:24:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/04/24/next-permutation-and-analysis-of-its-stl-implementation</id>
    <content type="html"><![CDATA[<p>在Leetcode上有好几道全排列相关的题，一直以来只是会写基于递归的全排列生成算法，遇到这几道题后，搜了下一些非递归的实现方法，发现其实全排列的生成还是很有规律的有木有！这里就总结一下递归和非递归的全排列生成方法，并分析一下 STL 的实现。</p>

<p>递归和非递归实现全排列生成的方法也分别有多种，递归法有基于交换的，有基于链接的，还有回溯，非递归法有排序、回溯、求模等，关于所有这些方法的具体实现参见 <a href="http://mengliao.blog.51cto.com/876134/824079">全排列的六种算法</a>. 本文只实现一种递归和一种非递归算法，并在最后对 STL 的非递归算法进行分析。</p>

<p>本文的全部代码下载：<a href="http://ibillxia.github.io/upload/code/20140424.cpp">code</a>.</p>

<h2>递归法求全排列</h2>

<p>递归法的基本思路是这样的：</p>

<blockquote><p>首先选一个元素排在第一个（有 n 中选法）；
然后递归的对剩下的所有元素进行全排列；
直到一个元素的全排列是其本身。</p></blockquote>

<p>假设给定的元素序列为 &lt;e1, e2, ..., en>，其全排列表示为 P(e1, e2, ..., en)，则对递归的第一步展开有：</p>

<blockquote><p>P(e1, e2, ..., en) = {
&lt;e1, P(e2, e3, ..., en)>,
&lt;e2, P(e1, e3, ..., en)>,
... ...
&lt;en, P(e1, e2, ..., e(n-1))> }</p></blockquote>

<!-- more -->


<p> 一个简单的实现如下：</p>

<p>```
void recursive_permute(int A[],int i,int n){</p>

<pre><code>if(i==n-1){
    for(int j=0;j&lt;n;j++)
        cout&lt;&lt;A[j]&lt;&lt;" ";
    cout&lt;&lt;endl;
    return;
}
for(int j=i;j&lt;n;j++){
    swap(A[i],A[j]);  // choose A[j] as the ith element
    recursive_permute(A,i+1,n);
    swap(A[i],A[j]);  // reset to enter next for
}
</code></pre>

<p>}
```</p>

<p>这个实现非常精简易懂，但却存在一个问题，那就是当数组 A 中存在重复元素时，得到的排列是有重复的，这是因为在第8行的循环中，可能会选取重复的 A[j] 值。 为了去掉重复排列，我们可以在选取第 i 个数 A[j] 之前（即交换 A[i] 和 A[j] 之前），判断值为 A[j] 的元素是否选取过，即要判断在 A[i] 到 A[j-1] 中是否存在与 A[j] 相等的元素，如果出现过，说明 A[i] 选 A[j] 这个排列已经生成过了，可以直接跳过当前的 A[j] 看看是否可以选取 A[j+1] 作为 A[i] 了。比如上面的 e1 = e2，那么无重复的全排列应该是：</p>

<blockquote><p>P(e1, e2, ..., en) = {
&lt;e1, P(e2, e3, ..., en)>,
&lt;e3, P(e1, e2, e4, ..., en)>,
... ...
&lt;en, P(e1, e2, ..., e(n-1))> }</p></blockquote>

<p>添加这个限制的递归实现代码如下：</p>

<p>```
void recursive_permute2(int A[],int i,int n){</p>

<pre><code>if(i==n-1){
    for(int j=0;j&lt;n;j++)
        cout&lt;&lt;A[j]&lt;&lt;" ";
    cout&lt;&lt;endl;
    return;
}
for(int j=i;j&lt;n;j++){
    int k;
    for(k=i;k&lt;j;k++)if(A[k]==A[j])break; // A[j] already used
    if(k&lt;j)continue;
    swap(A[i],A[j]);  // choose A[j] as the ith element
    recursive_permute2(A,i+1,n);
    swap(A[i],A[j]);  // reset to enter next for
}
</code></pre>

<p>}
```</p>

<p>至此，递归法实现全排列的求解就总结到这儿了，下面来看看非递归怎么实现。</p>

<h2>非递归法求全排列</h2>

<p>非递归法求全排列的一种最常用算法是基于字典序的全排列生成算法，其基本思路为，先解决生成一个序列在字典序下的下一个排列这个问题，然后利用这个来一次求解每一个排列。其中求解给定序列在字典序下的下一个排列序列的基本思想如下：</p>

<blockquote><ol>
<li>对于给定序列 &lt;e1, e2, ..., en> 从右往左找到第一个非递增点，设下标为 i；</li>
<li>从右往左查找第一个比 e[i] 大的数，设其下标为 j;</li>
<li>交换 e[i] 和 e[j] 的值；</li>
<li>将序列 e[i+1..n] 逆置。</li>
</ol>
</blockquote>

<p>举个例子，如下图（修改自 <a href="http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html">Next Permutation 解题报告</a> ）所示：</p>

<center><img src="/images/2014/IMAG2014042401.png"></center>


<p>上面的说明已经很接近伪代码了，具体实现如下：</p>

<p>```
bool next_permute(int A[],int n){</p>

<pre><code>int i,j;
// step .1
if(n&lt;2)return false;
for(i=n-2;i&gt;=0;i--){
    if(A[i]&lt;A[i+1])break;
}
if(i&lt;0)return false; // A[0] is maximum, no next permute for it
// step .2
for(j=n-1;j&gt;i;j--){
    if(A[j]&gt;A[i])break;
}
// step .3
swap(A[i],A[j]);
// step .4
while(++i &lt; --n){
    swap(A[i],A[n]);
}
return true;
</code></pre>

<p>}
```</p>

<p>这里将其返回值定义为 bool 类型，可以方便后面求解全排列时调用：</p>

<p>```
void non_recursive_permute(int A[],int n){</p>

<pre><code>sort(A,A+n);
int i;
do{
    for(i=0;i&lt;n;i++)cout&lt;&lt;A[i]&lt;&lt;" ";
    cout&lt;&lt;endl;
}while(next_permute(A,n));
</code></pre>

<p>}
```</p>

<p>上面这个函数即实现了按字典序生成全排列的功能，而且对于输入含有重复值的情况，不会生成重复的排列。对于非递归实现，很容易分析其时间复杂度，next_permute 的时间复杂度为 O(n)，而 non_recursive_permute 的时间复杂度为 O(n*n!)。</p>

<h2>STL 中 next permute 的实现</h2>

<p>下面来分析一下 STL 中是如何实现 next permute 的，在 stl_algo.h 中我们可以找到 next_permutation 的实现，基本思路也是按照上面的四步走来实现的，具体见如下代码及注释：</p>

<p>```
/<em>*
 *  @brief  Permute range into the next @a dictionary ordering.
 *  @ingroup sorting_algorithms
 *  @param  first  Start of range.
 *  @param  last   End of range.
 *  @return  False if wrapped to first permutation, true otherwise.
 *
 *  Treats all permutations of the range as a set of @a dictionary sorted
 *  sequences.  Permutes the current sequence into the next one of this set.
 *  Returns true if there are more sequences to generate.  If the sequence
 *  is the largest of the set, the smallest is generated and false returned.
</em>/
template<typename _BidirectionalIterator>
bool
next_permutation(_BidirectionalIterator __first,</p>

<pre><code>             _BidirectionalIterator __last)
</code></pre>

<p>{</p>

<pre><code>// concept requirements
__glibcxx_function_requires(_BidirectionalIteratorConcept&lt;
                            _BidirectionalIterator&gt;)
__glibcxx_function_requires(_LessThanComparableConcept&lt;
                            typename iterator_traits&lt;_BidirectionalIterator&gt;::value_type&gt;)
__glibcxx_requires_valid_range(__first, __last);

if (__first == __last)  // 容器中没有元素，没有 next permute
    return false;
_BidirectionalIterator __i = __first;
++__i;
if (__i == __last)  // 容器中只有一个元素，同没有
    return false;
__i = __last;
--__i;  // 将 __i 指向最后一个元素

for(;;) {
    _BidirectionalIterator __ii = __i;  
    --__i;
    if (*__i &lt; *__ii) {  // step .1, 这里的 __i 就相当于上面step 1中的i
        _BidirectionalIterator __j = __last;
        while (!(*__i &lt; *--__j)) {  // step .2, 这里的 __j 就相当上面 step 2中的j
        }
        std::iter_swap(__i, __j);  // step .3 交换
        std::reverse(__ii, __last);  // step .4 逆置
        return true;
    }
    if (__i == __first) {  // 直到 __i = __first 还是没有 *__i &lt; *__ii ，说明序列是递减排列的
        std::reverse(__first, __last); // 本应该没有下一个排列，但这里将字典序中第一个排列作为最后一个排列的 next permute
        return false; // 这里返回 false 而不是 true
    }
}
</code></pre>

<p>}
```</p>

<p>这里是用双向迭代器对容器中的元素进行操作的，一个调用的实例如下：</p>

<p>```
vector&lt;vector<int> > permute(vector<int> &amp;num) {</p>

<pre><code>vector&lt;vector&lt;int&gt; &gt; ans;
sort(num.begin(),num.end());
do{
    ans.push_back(num);
}while(next_permutation(num.begin(),num.end()));
return ans;
</code></pre>

<p>}
```</p>

<p>可以看到，其实 STL 的 next permute 的实现跟我们的非递归算法是一致的。但这里有两个问题：一是，这里看似有二重循环（在 for 中套 while ），但实际上复杂度是 n+n =》 O(n) 的（可以为什么要写成这种二重循环的形式捏？不解）；二是，我们可以看到在 for 循环中，对 __ii 这个变量进行了多次声明，为什么不将其声明放在 for 外面捏？（虽然待排列的元素数 n 不会很大，但这样多次声明一个迭代器变量，虽不会占用过多内存，但在声明时调用构造函数和析构函数也是有一定的时间开销的吧，虽然相对于求全排列的复杂度 O(n*n!) 几乎可以忽略不计）</p>
]]></content>
  </entry>
  
</feed>
