<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2014-04-28T23:12:20+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[给Octopress博客配置Twitter Bootstrap主题]]></title>
    <link href="http://ibillxia.github.io/blog/2014/04/28/configure-twitter-bootstrap-theme-in-octopress/"/>
    <updated>2014-04-28T22:37:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/04/28/configure-twitter-bootstrap-theme-in-octopress</id>
    <content type="html"><![CDATA[<p>很长一段时间以来就看到各种基于 Twitter Bootstrap 主题的博客很清爽，而且对 Tag 的归档也做得很赞，于是很想将自己的博客也换成 Bootstrap 的主题，随着看到的博客越来越多，自己的 Octopress 主题先得越来越臃肿，而 Tags 归档功能也相形见绌，更换主题的欲望越来越强烈了。于是乎，趁这个周末捣鼓了一番，最终大功告成，在这里分享一下具体过程。</p>

<h2>Bootstrap 主题的安装</h2>

<p>首先下载适用于 Octopress 的 <a href="https://github.com/bkutil/bootstrap-theme">Bootstrap主题</a> 并解压缩到博客的 .theme 目录，然后安装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake install['bootstrap']</span></code></pre></td></tr></table></div></figure>


<p>安装的过程中可能会提示有 sass 或其他依赖库的语法错误神马的，这是因为 sass 的版本过低，可以通过如下命令来跟新：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bundle update sass</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>其他库的升级类推。升级完这些依赖后，要修改你的 Octopress 博客的根目录下的 Gemfile 中的版本说明。最后再重新运行上上条的 rake install 指令。这样就完成主体的安装了，是不是很简单（实际操作中遇到问题的话，一般都是 jekyll 等各种的库的版本及相互间的依赖问题，通过 bundle update 基本上都能搞定）。安装完了之后，可以运行 rake generate 和 rake preview 来看看效果了。</p>

<h2>配置 Tags 归档</h2>

<p>接下来是配置类似 <a href="http://ibillxia.github.io/blog/tags/">这种显示结果</a> 的 Tags 归档页面了。</p>

<p>首先，需要安装 <a href="https://github.com/plusjade/jekyll-bootstrap">jekyll-bootstrap</a> 的一些东西，请先下载并解压。主要是 <em>includes/JB/ 目录下的内容，将 JB 文件夹拷贝到 $BLOG_HOME/source/</em>includes/ 目录下，还有 jekyll-bootstrap 根目录下的 tags.html 拷贝到你想展示 Tags 的目录，并在 _config.yml 文件中配置 tag_dir 项的值为该目录，例如我这里的配置是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tag_dir: blog/tags</span></code></pre></td></tr></table></div></figure>


<p>所以我的 tags.html 文件放在了 $BLOG_HOME/source/blog/tags 目录下，并将 tags.html 重命名为 index.html。</p>

<p>这些配置好了后，你就可以先运行 rake generate 和 rake preview 来看看效果。可以发现 Tags 归档页的显示还是不太友好。那么我们需要加入一些自己的 css 样式。这里我参考了 pluskid 师兄的博客的 css 代码并略有修改，在我新建的 $BLOG_HOME/source/stylesheets/style.css 文件中加入如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* tag_box */
</span><span class='line'>.tag_box {
</span><span class='line'>  list-style:none;
</span><span class='line'>  margin:0;
</span><span class='line'>  padding:2px 0 ;
</span><span class='line'>  overflow:hidden;
</span><span class='line'>}
</span><span class='line'>.tag_box li {
</span><span class='line'>  line-height:20px;
</span><span class='line'>  margin:0;
</span><span class='line'>}
</span><span class='line'>.tag_box.inline li {
</span><span class='line'>  float:left;
</span><span class='line'>  padding:2px 0 ;
</span><span class='line'>}
</span><span class='line'>.tag_box a {
</span><span class='line'>  padding: 2px;
</span><span class='line'>  margin: 2px;
</span><span class='line'>  background: #eee;
</span><span class='line'>  color:#005F6B;
</span><span class='line'>  border-radius: 3px;
</span><span class='line'>  text-decoration:none;
</span><span class='line'>}
</span><span class='line'>.tag_box a span{
</span><span class='line'>  vertical-align:super;
</span><span class='line'>  font-size:0.8em;
</span><span class='line'>}
</span><span class='line'>.tag_box a.active {
</span><span class='line'>  background:#57A957;
</span><span class='line'>  border:1px solid #4C964D;
</span><span class='line'>  color:#FFF;
</span><span class='line'>}
</span><span class='line'>/* tag_box end */</span></code></pre></td></tr></table></div></figure>


<p>注意，这里由于新加了 css 文件，要让其生效，需要在 html 模板中加入引用，具体我是在 $BLOG_HOME/source/_includes/head.html 文件中加入如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;link href="http://ibillxia.github.io/stylesheets/style.css" media="screen, projection" rel="stylesheet" type="text/css"&gt;</span></code></pre></td></tr></table></div></figure>


<p>你也可以直接在 html 模板中加入 css 代码而不用新建 css 文件并添加引用。</p>

<p>至此，已经配置完成了 ^_^ 可以运行 rake generate 和 rake preview 来看看最终效果了。</p>

<p>PS：本博客的主题及插件相关文件和代码可以看我的 GitHub Repo：<a href="https://github.com/ibillxia/xoctopress">xoctopress</a>. 如有问题，可以参考这些代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[全排列及某排列的后继的求解及其STL实现的分析]]></title>
    <link href="http://ibillxia.github.io/blog/2014/04/24/next-permutation-and-analysis-of-its-stl-implementation/"/>
    <updated>2014-04-24T23:24:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/04/24/next-permutation-and-analysis-of-its-stl-implementation</id>
    <content type="html"><![CDATA[<p>在Leetcode上有好几道全排列相关的题，一直以来只是会写基于递归的全排列生成算法，遇到这几道题后，搜了下一些非递归的实现方法，发现其实全排列的生成还是很有规律的有木有！这里就总结一下递归和非递归的全排列生成方法，并分析一下 STL 的实现。</p>

<p>递归和非递归实现全排列生成的方法也分别有多种，递归法有基于交换的，有基于链接的，还有回溯，非递归法有排序、回溯、求模等，关于所有这些方法的具体实现参见 <a href="http://mengliao.blog.51cto.com/876134/824079">全排列的六种算法</a>. 本文只实现一种递归和一种非递归算法，并在最后对 STL 的非递归算法进行分析。</p>

<h2>递归法求全排列</h2>

<p>递归法的基本思路是这样的：</p>

<blockquote><p>首先选一个元素排在第一个（有 n 中选法）；
然后递归的对剩下的所有元素进行全排列；
直到一个元素的全排列是其本身。</p></blockquote>

<p>假设给定的元素序列为 &lt;e1, e2, &#8230;, en>，其全排列表示为 P(e1, e2, &#8230;, en)，则对递归的第一步展开有：</p>

<blockquote><p>P(e1, e2, &#8230;, en) = {
&lt;e1, P(e2, e3, &#8230;, en)>,
&lt;e2, P(e1, e3, &#8230;, en)>,
&#8230; &#8230;
&lt;en, P(e1, e2, &#8230;, e(n-1))> }</p></blockquote>

<!-- more -->


<p> 一个简单的实现如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void recursive_permute(int A[],int i,int n){
</span><span class='line'>  if(i==n-1){
</span><span class='line'>      for(int j=0;j&lt;n;j++)
</span><span class='line'>          cout&lt;&lt;A[j]&lt;&lt;" ";
</span><span class='line'>      cout&lt;&lt;endl;
</span><span class='line'>      return;
</span><span class='line'>  }
</span><span class='line'>  for(int j=i;j&lt;n;j++){
</span><span class='line'>      swap(A[i],A[j]);  // choose A[j] as the ith element
</span><span class='line'>      recursive_permute(A,i+1,n);
</span><span class='line'>      swap(A[i],A[j]);  // reset to enter next for
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个实现非常精简易懂，但却存在一个问题，那就是当数组 A 中存在重复元素时，得到的排列是有重复的，这是因为在第8行的循环中，可能会选取重复的 A[j] 值。 为了去掉重复排列，我们可以在选取第 i 个数 A[j] 之前（即交换 A[i] 和 A[j] 之前），判断值为 A[j] 的元素是否选取过，即要判断在 A[i] 到 A[j-1] 中是否存在与 A[j] 相等的元素，如果出现过，说明 A[i] 选 A[j] 这个排列已经生成过了，可以直接跳过当前的 A[j] 看看是否可以选取 A[j+1] 作为 A[i] 了。比如上面的 e1 = e2，那么无重复的全排列应该是：</p>

<blockquote><p>P(e1, e2, &#8230;, en) = {
&lt;e1, P(e2, e3, &#8230;, en)>,
&lt;e3, P(e1, e2, e4, &#8230;, en)>,
&#8230; &#8230;
&lt;en, P(e1, e2, &#8230;, e(n-1))> }</p></blockquote>

<p>添加这个限制的递归实现代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void recursive_permute2(int A[],int i,int n){
</span><span class='line'>  if(i==n-1){
</span><span class='line'>      for(int j=0;j&lt;n;j++)
</span><span class='line'>          cout&lt;&lt;A[j]&lt;&lt;" ";
</span><span class='line'>      cout&lt;&lt;endl;
</span><span class='line'>      return;
</span><span class='line'>  }
</span><span class='line'>  for(int j=i;j&lt;n;j++){
</span><span class='line'>      int k;
</span><span class='line'>      for(k=i;k&lt;j;k++)if(A[k]==A[j])break; // A[j] already used
</span><span class='line'>      if(k&lt;j)continue;
</span><span class='line'>      swap(A[i],A[j]);  // choose A[j] as the ith element
</span><span class='line'>      recursive_permute2(A,i+1,n);
</span><span class='line'>      swap(A[i],A[j]);  // reset to enter next for
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>至此，递归法实现全排列的求解就总结到这儿了，下面来看看非递归怎么实现。</p>

<h2>非递归法求全排列</h2>

<p>非递归法求全排列的一种最常用算法是基于字典序的全排列生成算法，其基本思路为，先解决生成一个序列在字典序下的下一个排列这个问题，然后利用这个来一次求解每一个排列。其中求解给定序列在字典序下的下一个排列序列的基本思想如下：</p>

<blockquote><ol>
<li>对于给定序列 &lt;e1, e2, &#8230;, en> 从右往左找到第一个非递增点，设下标为 i；</li>
<li>从右往左查找第一个比 e[i] 大的数，设其下标为 j;</li>
<li>交换 e[i] 和 e[j] 的值；</li>
<li>将序列 e[i+1..n] 逆置。</li>
</ol>
</blockquote>

<p>举个例子，如下图（修改自 <a href="http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html">Next Permutation 解题报告</a> ）所示：</p>

<center><img src="http://ibillxia.github.io/images/2014/IMAG2014042401.png"></center>


<p>上面的说明已经很接近伪代码了，具体实现如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bool next_permute(int A[],int n){
</span><span class='line'>  int i,j;
</span><span class='line'>  // step .1
</span><span class='line'>  if(n&lt;2)return false;
</span><span class='line'>  for(i=n-2;i&gt;=0;i--){
</span><span class='line'>      if(A[i]&lt;A[i+1])break;
</span><span class='line'>  }
</span><span class='line'>  if(i&lt;0)return false; // A[0] is maximum, no next permute for it
</span><span class='line'>  // step .2
</span><span class='line'>  for(j=n-1;j&gt;i;j--){
</span><span class='line'>      if(A[j]&gt;A[i])break;
</span><span class='line'>  }
</span><span class='line'>  // step .3
</span><span class='line'>  swap(A[i],A[j]);
</span><span class='line'>  // step .4
</span><span class='line'>  while(++i &lt; --n){
</span><span class='line'>      swap(A[i],A[n]);
</span><span class='line'>  }
</span><span class='line'>  return true;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里将其返回值定义为 bool 类型，可以方便后面求解全排列时调用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void non_recursive_permute(int A[],int n){
</span><span class='line'>  sort(A,A+n);
</span><span class='line'>  int i;
</span><span class='line'>  do{
</span><span class='line'>      for(i=0;i&lt;n;i++)cout&lt;&lt;A[i]&lt;&lt;" ";
</span><span class='line'>      cout&lt;&lt;endl;
</span><span class='line'>  }while(next_permute(A,n));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面这个函数即实现了按字典序生成全排列的功能，而且对于输入含有重复值的情况，不会生成重复的排列。对于非递归实现，很容易分析其时间复杂度，next_permute 的时间复杂度为 O(n)，而 non_recursive_permute 的时间复杂度为 O(n*n!)。</p>

<h2>STL 中 next permute 的实现</h2>

<p>下面来分析一下 STL 中是如何实现 next permute 的，在 stl_algo.h 中我们可以找到 next_permutation 的实现，基本思路也是按照上面的四步走来实现的，具体见如下代码及注释：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  @brief  Permute range into the next @a dictionary ordering.
</span><span class='line'> *  @ingroup sorting_algorithms
</span><span class='line'> *  @param  first  Start of range.
</span><span class='line'> *  @param  last   End of range.
</span><span class='line'> *  @return  False if wrapped to first permutation, true otherwise.
</span><span class='line'> *
</span><span class='line'> *  Treats all permutations of the range as a set of @a dictionary sorted
</span><span class='line'> *  sequences.  Permutes the current sequence into the next one of this set.
</span><span class='line'> *  Returns true if there are more sequences to generate.  If the sequence
</span><span class='line'> *  is the largest of the set, the smallest is generated and false returned.
</span><span class='line'>*/
</span><span class='line'>template&lt;typename _BidirectionalIterator&gt;
</span><span class='line'>bool
</span><span class='line'>next_permutation(_BidirectionalIterator __first,
</span><span class='line'>                 _BidirectionalIterator __last)
</span><span class='line'>{
</span><span class='line'>    // concept requirements
</span><span class='line'>    __glibcxx_function_requires(_BidirectionalIteratorConcept&lt;
</span><span class='line'>                                _BidirectionalIterator&gt;)
</span><span class='line'>    __glibcxx_function_requires(_LessThanComparableConcept&lt;
</span><span class='line'>                                typename iterator_traits&lt;_BidirectionalIterator&gt;::value_type&gt;)
</span><span class='line'>    __glibcxx_requires_valid_range(__first, __last);
</span><span class='line'>
</span><span class='line'>    if (__first == __last)  // 容器中没有元素，没有 next permute
</span><span class='line'>        return false;
</span><span class='line'>    _BidirectionalIterator __i = __first;
</span><span class='line'>    ++__i;
</span><span class='line'>    if (__i == __last)  // 容器中只有一个元素，同没有
</span><span class='line'>        return false;
</span><span class='line'>    __i = __last;
</span><span class='line'>    --__i;  // 将 __i 指向最后一个元素
</span><span class='line'>
</span><span class='line'>    for(;;) {
</span><span class='line'>        _BidirectionalIterator __ii = __i;  
</span><span class='line'>        --__i;
</span><span class='line'>        if (*__i &lt; *__ii) {  // step .1, 这里的 __i 就相当于上面step 1中的i
</span><span class='line'>            _BidirectionalIterator __j = __last;
</span><span class='line'>            while (!(*__i &lt; *--__j)) {  // step .2, 这里的 __j 就相当上面 step 2中的j
</span><span class='line'>            }
</span><span class='line'>            std::iter_swap(__i, __j);  // step .3 交换
</span><span class='line'>            std::reverse(__ii, __last);  // step .4 逆置
</span><span class='line'>            return true;
</span><span class='line'>        }
</span><span class='line'>        if (__i == __first) {  // 直到 __i = __first 还是没有 *__i &lt; *__ii ，说明序列是递减排列的
</span><span class='line'>            std::reverse(__first, __last); // 本应该没有下一个排列，但这里将字典序中第一个排列作为最后一个排列的 next permute
</span><span class='line'>            return false; // 这里返回 false 而不是 true
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里是用双向迭代器对容器中的元素进行操作的，一个调用的实例如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &num) {
</span><span class='line'>  vector&lt;vector&lt;int&gt; &gt; ans;
</span><span class='line'>  sort(num.begin(),num.end());
</span><span class='line'>  do{
</span><span class='line'>      ans.push_back(num);
</span><span class='line'>  }while(next_permutation(num.begin(),num.end()));
</span><span class='line'>  return ans;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到，其实 STL 的 next permute 的实现跟我们的非递归算法是一致的。但这里有两个问题：一是，这里看似有二重循环（在 for 中套 while ），但实际上复杂度是 n+n =》 O(n) 的（可以为什么要写成这种二重循环的形式捏？不解）；二是，我们可以看到在 for 循环中，对 __ii 这个变量进行了多次声明，为什么不将其声明放在 for 外面捏？（虽然待排列的元素数 n 不会很大，但这样多次声明一个迭代器变量，虽不会占用过多内存，但在声明时调用构造函数和析构函数也是有一定的时间开销的吧，虽然相对于求全排列的复杂度 O(n*n!) 几乎可以忽略不计）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[原地交换两个变量的值]]></title>
    <link href="http://ibillxia.github.io/blog/2014/04/11/swap-two-variables-in-place/"/>
    <updated>2014-04-11T22:27:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/04/11/swap-two-variables-in-place</id>
    <content type="html"><![CDATA[<h2>引子</h2>

<p>在码代码的过程中，不经意间就会遇到需要交换两个变量的情况，一般情况下都是通过新定义一个同类型的变量来中转，但自己也知道可以不用定义新变量直接原地交换，但具体如何原地交换以及其中可能隐藏的bug却了解得不是很清楚，于是乎google了一下，发现这里面还真是有很多学问呢，这里整理和总结一下。</p>

<p>原地交换两个变量，最主要有加减法和异或法。</p>

<p>本文完整代码链接：<a href="../upload/code/20140411.cpp">20140411.cpp</a></p>

<h2>加减法</h2>

<p>加减法最简单、最好理解了，设待交换的两个变量分别为 a 和 b ，首先将两者的和赋给 a ；然后将 a 与 b的差赋给 b ，这样 b 就是 a 原来的值了；最后再将 a 与 b 的差赋给 a ，这样 a 就是 b 原来的值了。具体代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>inline template &lt;class T&gt;
</span><span class='line'>void xswap(T &a,T &b){
</span><span class='line'>    a=a+b;
</span><span class='line'>  //printf("a=%u\n",a);
</span><span class='line'>    b=a-b;
</span><span class='line'>    a=a-b;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>当然也可以先减后加：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>inline template &lt;class T&gt;
</span><span class='line'>void xswap2(T &a,T &b){
</span><span class='line'>    a=a-b;
</span><span class='line'>  //printf("a=%u\n",a);
</span><span class='line'>    b=a+b;
</span><span class='line'>    a=b-a;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里实现的原理与先加后减类似。粗一看，这样实现两个变量的原地交换很简单有效。但是，这其中有一个很隐秘的bug，就是溢出的问题，在先加后减的实现中，如果 a 与 b 的和大于该类型的能表示的最大值，会发生神马捏？我写了一个 main 函数来简单的测试了一下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>    unsigned char a=255,b=1;
</span><span class='line'>    printf("a=%u,b=%u\n",a,b);
</span><span class='line'>    xswap(a,b);
</span><span class='line'>    printf("a=%u,b=%u\n",a,b);
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>将上面的 xswap 函数中的注释取消，编译运行后（使用Code::Blocks 13.12 MinGW g++编译），得到如下输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a=255,b=1
</span><span class='line'>a=0
</span><span class='line'>a=1,b=255</span></code></pre></td></tr></table></div></figure>


<p>可以看到其中第2行输出的 a 的值为 0，产生了上溢（如果 a , b 同为负，可能产生下溢）。虽然最后交换的结果还是对的，但溢出的部分可能对内存中其他变量产生不可预测的后果。因此，不建议这么实现原地交换两个变量，如果实在需要用这种方法，一定要在进行加或减之前，判断时候回产生溢出。</p>

<h2>异或法</h2>

<p>异或法的基本原理类似，但还利用了异或的如下两个特性： a ^ 0 = a, a ^ a = 0. 用异或来实现两个变量的交换如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class T&gt;
</span><span class='line'>inline void xswap3(T &a,T &b){
</span><span class='line'>    a=a^b;
</span><span class='line'>    b=a^b;
</span><span class='line'>    a=b^a;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>由于异或是按位运算的，所以不存在溢出问题。因此，如果一定要原地实现两个变量的交换的话，建议用异或的方法。</p>

<h2>原地交换多个变量</h2>

<p>实际上，我们还可以利用上面的思想，将两个变量扩展到多个变量的原地交换，例如三个变量的交换：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class T&gt;
</span><span class='line'>inline void swap3(T &a,T &b,T &c){
</span><span class='line'>    a=a^b;
</span><span class='line'>    b=a^b;
</span><span class='line'>    a=b^a;
</span><span class='line'>    b=b^c;
</span><span class='line'>    c=b^c;
</span><span class='line'>    b=b^c;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>即先交换 a 和 b，再交换 b (=a) 和 c。另外，上面的式子可以简化和压缩到一个式子，具体的技巧读者可以自行google，这里不提倡这么做。</p>

<h2>STL是如何实现swap的</h2>

<p>最后，我们来看看STL标准库是如何实现swap的（这里的实现版本是 move.h 文件中的一个，在 STL 中还有针对 vector, string, tree, map, multimap, deque 的 swap 函数）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'>*  @brief Swaps two values.
</span><span class='line'>*  @ingroup mutating_algorithms
</span><span class='line'>*  @param  __a  A thing of arbitrary type.
</span><span class='line'>*  @param  __b  Another thing of arbitrary type.
</span><span class='line'>*  @return   Nothing.
</span><span class='line'>*/
</span><span class='line'>template&lt;typename _Tp&gt;
</span><span class='line'>inline void
</span><span class='line'>swap(_Tp& __a, _Tp& __b)
</span><span class='line'>{
</span><span class='line'>  // concept requirements
</span><span class='line'>  __glibcxx_function_requires(_SGIAssignableConcept&lt;_Tp&gt;)
</span><span class='line'>
</span><span class='line'>  _Tp __tmp = _GLIBCXX_MOVE(__a);
</span><span class='line'>  __a = _GLIBCXX_MOVE(__b);
</span><span class='line'>  __b = _GLIBCXX_MOVE(__tmp);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到，这里新声明了一个变量 __tmp 来中转。至于为什么没有原地进行交换，一个可能的解释是：对于 inline 函数来说，函数调用的代码会直接被改函数体替换，再经过编译优化，最后可能只需要借助一个寄存器变量就可以实现两个变量的交换了，这是非常快的，与通过按位的异或运算的实现，在性能上区别不是太大。</p>

<h2>update</h2>

<p>关于溢出的更深入的讨论，可以看看陈浩的最新博文 <a href="http://coolshell.cn/articles/11466.html">C语言的整型溢出问题</a> . 这里面有提到溢出的几个危害，还有关于 C 语言标准、编译器对溢出是如何处理和对待的，以及如何写代码实现预先判断溢出。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go并发编程初探]]></title>
    <link href="http://ibillxia.github.io/blog/2014/03/16/go-concurrent-programming-first-try/"/>
    <updated>2014-03-16T23:35:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/03/16/go-concurrent-programming-first-try</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>最近在做的一个项目，需要对大量数据进行一些基本的统计和处理，整个程序的思路很简单，但处理起来却很慢，特别是有二重循环的地方，龟速前进，眼看着16核32线程
的服务器只有一个线程被利用，束手无策。之前一直听说Go是一门对并发编程有很好的支持的语言，七牛的许牛大力推崇Go语言，于是就开始了对Go并行编程的探索之旅。</p>


<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031601.jpg"></center>




<!--more-->




<h2>一些准备工作</h2>


<p>在正式开始Go并行编程之前，首先我们需要准备Go的编程开发环境：Go编译器、Go编辑器。</br>
在<a href="http://golang.org/">golang的官网</a>上有go的下载链接：</br>
<a href="http://code.google.com/p/go/downloads/list">http://code.google.com/p/go/downloads/list</a></br>
我选择的是go1.2.1.windows-amd64.msi安装包，下载完后直接点击该安装包，按照默认选项安装即可。安装完后，可以在命令行中查看go版本以检查是否安装成功：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\Users\Bill&gt;go version
</span><span class='line'>go version go1.2.1 windows/amd64</span></code></pre></td></tr></table></div></figure>

然后，我们需要安装一个用于Go开发的IDE。当然也可以用通用的文本编辑器就可以，比如notepad、vi等，但这都是一些轻量级的，对于初学者来说还是不太合适的。
网上有很多推荐的IDE，主要有LiteIDE、Eclipse+Goclipse、GoIde等，以及vim/emacs搭配go插件等，这里我选择的是LiteIDE，下载地址：</br>
<a href="http://sourceforge.net/projects/liteide/files/x21/">http://sourceforge.net/projects/liteide/files/x21/</a></br>
下载安装后，我们就可以开始go编程了。可以先运行一个Hello world程序，这里就不演示了，具体见：<a href="http://tour.golangtc.com/#1">Go 指南</a>
</p>




<p>关于Go的一些特性的介绍这里也不讲了，有兴趣的可以移步酷壳的这两篇文章<a href="http://coolshell.cn/articles/8460.html">Go 语言简介（上）— 语法</a> 
和 <a href="http://coolshell.cn/articles/8489.html">Go 语言简介（下）— 特性</a>。下面我们直接进入Go并发编程。</p>




<h2>Go并发编程</h2>


<h4>#0x01.goroutine</h4>


<p>优雅的并发编程范式，完善的并发支持，出色的并发性能是Go语言区别于其他语言的一大特色。在Go中，通过一种叫做goroutine的go协程这种轻量级线程来支持
并发编程范式。协程是比进程和线程更轻量级的线程，go语言标准库提供的所有系统调用操作都会出让CPU给其他goroutine，协程的切换管理不依赖于系统的线程和
进程，也不依赖于CPU的核心数量。下面我们来看一个简单的goroutine的实例。

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package main
</span><span class='line'>
</span><span class='line'>import "fmt"
</span><span class='line'>
</span><span class='line'>func main() {
</span><span class='line'>  arr := [10]int{}
</span><span class='line'>  for i := 0; i &lt; 10; i++ {
</span><span class='line'>      fmt.Print("Result of ", i, ":")
</span><span class='line'>      go func() {
</span><span class='line'>          arr[i] = i + i*i
</span><span class='line'>          fmt.Println(arr[i])
</span><span class='line'>      }()
</span><span class='line'>  }
</span><span class='line'>  fmt.Println("Done")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

Go从main package的main()函数开始执行，这段代码的功能是计算arr[i]=i+i*i，其中i取值从0到9，每一个i计算完后立即输出。其中go为golang的关键字，启动
一个协程（goroutine）。程序的运行的结果是什么呢？我们期望的结果应该是这样的吧：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Result of 0:0
</span><span class='line'>Result of 1:2
</span><span class='line'>Result of 2:6
</span><span class='line'>Result of 3:12
</span><span class='line'>Result of 4:20
</span><span class='line'>Result of 5:30
</span><span class='line'>Result of 6:42
</span><span class='line'>Result of 7:56
</span><span class='line'>Result of 8:72
</span><span class='line'>Result of 9:90
</span><span class='line'>Done</span></code></pre></td></tr></table></div></figure>

可是在LiteIDE中运行后，却会发现结果是这样子的：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Result of 0:Result of 1:Result of 2:Result of 3:Result of 4:Result of 5:Result of 6:Result of 7:Result of 8:Result of 9:Done</span></code></pre></td></tr></table></div></figure>

这是为神马捏？怎么第9~12行的go func(){&#8230;}() 这段代码好像更笨就没有执行嘛？！莫非这是golang的bug？</p>




<p>其实，这与golang的程序执行顺序有关。go程序从初始化main package并执行main()函数开始，当main()函数返回时，程序退出，且程序并不等待其他goroutine
（非主goroutine）结束。于是上面的程序中，主函数虽然启动了10gegoroutine，但都没来得及执行，程序就已经退出了。那么怎么解决这个问题捏？很显然，我们
在退出程序之前，需要判断这些创建的goroutine执行完了没。我们可以用一个全局变量来计数执行了的协程数，如果计数变量小于10，我们就等待或sleep。</p>




<h4>#0x02.并发通讯</h4>


<p>等一等，多个协程读写同一个变量，我们是不是需要对这个变量枷锁呀？答案是肯定的，我们可以采用类似与C/C++的线程通讯、数据共享的思路来实现，如下：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package main
</span><span class='line'>
</span><span class='line'>import (
</span><span class='line'>  "fmt"
</span><span class='line'>  "runtime"
</span><span class='line'>  "sync"
</span><span class='line'>)
</span><span class='line'>
</span><span class='line'>func main() {
</span><span class='line'>  var cnt int = 0  // 全局计数器
</span><span class='line'>  mylock := &sync.Mutex{}  // 互斥锁
</span><span class='line'>  arr := [10]int{}
</span><span class='line'>  for i := 0; i &lt; 10; i++ {
</span><span class='line'>      fmt.Print("Result of ", i, ":")
</span><span class='line'>      go func() {
</span><span class='line'>          arr[i] = i + i*i
</span><span class='line'>          fmt.Println(arr[i])
</span><span class='line'>          mylock.Lock() // 写之前枷锁
</span><span class='line'>          cnt++
</span><span class='line'>          mylock.Unlock() // 写之后释放锁
</span><span class='line'>      }()
</span><span class='line'>  }
</span><span class='line'>  for {
</span><span class='line'>      mylock.Lock() // 读之前枷锁
</span><span class='line'>      temp := cnt
</span><span class='line'>      mylock.Unlock() // 读之后释放锁
</span><span class='line'>      runtime.Gosched() // 协程切换
</span><span class='line'>      if temp &gt;= 10 {
</span><span class='line'>          break
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  fmt.Println("Done")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

执行以上程序，应该能够得到我们之前预期的那样的结果吧？可以运行之后，我们发现，结果却是这样的：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Result of 0:Result of 1:Result of 2:Result of 3:Result of 4:Result of 5:Result of 6:Result of 7:Result of 8:Result of 9:panic: runtime error: index out of range
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>

出现了运行时错误，数组下表越界了？！第17行还是没有输出？！经过一番修改，得到如下代码：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package main
</span><span class='line'>
</span><span class='line'>import (
</span><span class='line'>  "fmt"
</span><span class='line'>  "runtime"
</span><span class='line'>  "sync"
</span><span class='line'>)
</span><span class='line'>
</span><span class='line'>func main() {
</span><span class='line'>  var cnt int = 0  // 全局计数器
</span><span class='line'>  mylock := &sync.Mutex{}  // 互斥锁
</span><span class='line'>  arr := [11]int{}
</span><span class='line'>  for i := 0; i &lt; 10; i++ {
</span><span class='line'>      go func() {
</span><span class='line'>          arr[i] = i + i*i
</span><span class='line'>          mylock.Lock() // 写之前枷锁
</span><span class='line'>          cnt++
</span><span class='line'>          mylock.Unlock() // 写之后释放锁
</span><span class='line'>      }()
</span><span class='line'>  }
</span><span class='line'>  for {
</span><span class='line'>      mylock.Lock() // 读之前枷锁
</span><span class='line'>      temp := cnt
</span><span class='line'>      mylock.Unlock() // 读之后释放锁
</span><span class='line'>      runtime.Gosched() // 协程切换
</span><span class='line'>      if temp &gt;= 10 {
</span><span class='line'>          break
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  for i := 0; i &lt; 11; i++ {
</span><span class='line'>      fmt.Println("Result of ", i, ":", arr[i])
</span><span class='line'>  }
</span><span class='line'>  fmt.Println("Done")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

这下应该能得到预期的结果了吧。可以运行程序后，有傻眼了，结果是：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Result of  0 : 0
</span><span class='line'>Result of  1 : 0
</span><span class='line'>Result of  2 : 0
</span><span class='line'>Result of  3 : 0
</span><span class='line'>Result of  4 : 0
</span><span class='line'>Result of  5 : 0
</span><span class='line'>Result of  6 : 0
</span><span class='line'>Result of  7 : 0
</span><span class='line'>Result of  8 : 0
</span><span class='line'>Result of  9 : 0
</span><span class='line'>Result of  10 : 110
</span><span class='line'>Done</span></code></pre></td></tr></table></div></figure>

神马？arr[0]~arr[9]肿么都是0，肿么会冒出一个arr[10]=110？！即使把第15、16行顺序互换，得到的结果还是一样！！！这真是一场噩梦啊！！！仔细对比许书上的例子，
我们发现，这里使用的是匿名函数创建协程，匿名函数中使用了全局的变量，而每次使用go关键字创建协程后，程序不是继续往下执行，而是继续返回到for这一行来执行，首先i++，
然后判断i<10，成立就继续执行并创建协程，10个协程创建完了之后，才真正开始匿名函数的执行，而此时i已经是10了，对于每一个协程i都是10，因此最终只计算了一个arr[10]=110，
这也是为什么申请10个单位的数组时会出现运行时错误。而这完全不是我们所要的结果，那么怎么办呢？我们不妨用带参数的匿名函数来试试？如下：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package main
</span><span class='line'>
</span><span class='line'>import (
</span><span class='line'>  "fmt"
</span><span class='line'>  "runtime"
</span><span class='line'>  "sync"
</span><span class='line'>)
</span><span class='line'>
</span><span class='line'>func main() {
</span><span class='line'>  var cnt int = 0  // 全局计数器
</span><span class='line'>  mylock := &sync.Mutex{}  // 互斥锁
</span><span class='line'>  arr := [11]int{}
</span><span class='line'>  for i := 0; i &lt; 10; i++ {
</span><span class='line'>      go func(i int) { // 这里的i是形参
</span><span class='line'>          arr[i] = i + i*i
</span><span class='line'>          mylock.Lock() // 写之前枷锁
</span><span class='line'>          cnt++
</span><span class='line'>          mylock.Unlock() // 写之后释放锁
</span><span class='line'>      }(i) // 这里的i是实参
</span><span class='line'>  }
</span><span class='line'>  for {
</span><span class='line'>      mylock.Lock() // 读之前枷锁
</span><span class='line'>      temp := cnt
</span><span class='line'>      mylock.Unlock() // 读之后释放锁
</span><span class='line'>      runtime.Gosched() // 协程切换
</span><span class='line'>      if temp &gt;= 10 {
</span><span class='line'>          break
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  for i := 0; i &lt; 11; i++ {
</span><span class='line'>      fmt.Println("Result of ", i, ":", arr[i])
</span><span class='line'>  }
</span><span class='line'>  fmt.Println("Done")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

终于，我们总算得到了想要的结果了，经过不懈努力终于大功告成。这里没创建一个协程，都有一个实参值传给形参，在匿名函数中就不存在共享的全局变量i了。
然而，在让我们回头看看我们的代码，却会发现，这与一般的多线程程序有什么区别的，而且写起来会感觉更麻烦，有过之而无不及啊！</p>




<p>想象一下，在一个大的系统中具有无数的锁、无数的共享变量、无数的业务逻辑与错误处理分支，那将是一场噩梦。这噩梦就是众多C/C++开发者正在经历的，其实Java和C#开发
者也好不到哪里去。Go语言既然以并发编程作为语言的最核心优势，当然不至于将这样的问题用这么无奈的方式来解决。Go语言提供的是另一种通信模型，即以消息机制而非共享
内存作为通信方式。</p>




<h4>#0x03.channel</h4>


<p>Go语言提供的消息通信机制被称为channel，接下来我们将详细介绍channel。现在，让我们用Go语言社区的那句著名的口号来开始这一小节： </br>
<blockquote><p>不要通过共享内存来通信，而应该通过通信来共享内存。</p></blockquote>
channel是Go语言在语言级别提供的goroutine间的通信方式，可以使用channel在两个或多个goroutine之间传递消息。channel是进程内的通信方式，因此通过channel传递
对象的过程和调用函数时的参数传递行为比较一致，比如也可以传递指针等。如果需要跨进程通信，建议用分布式系统的方法来解决，比如使用Socket或者HTTP等通信协议。
channel是类型相关的。也就是说，一个channel只能传递一种类型的值，这个类型需要在声明channel时指定。我们先看下用channel的方式重写上面的例子是什么样子的

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package main
</span><span class='line'>
</span><span class='line'>import "fmt"
</span><span class='line'>
</span><span class='line'>func main() {
</span><span class='line'>  chs := make([]chan int, 10) // 申请一个10维的channel数组
</span><span class='line'>  arr := [11]int{}
</span><span class='line'>  for i := 0; i &lt; 10; i++ {
</span><span class='line'>      chs[i] = make(chan int) // 对每个channel初始化
</span><span class='line'>      go func(ch chan int, i int) {
</span><span class='line'>          arr[i] = i + i*i
</span><span class='line'>          ch &lt;- 1  // 写channel，应该在函数体的最后一行，许书（P94，代码清单4-4）上有bug
</span><span class='line'>      }(chs[i], i)
</span><span class='line'>  }
</span><span class='line'>  for _, ch := range chs {
</span><span class='line'>      &lt;-ch // 读channel
</span><span class='line'>  }
</span><span class='line'>  for i := 0; i &lt; 11; i++ {
</span><span class='line'>      fmt.Println("Result of ", i, ":", arr[i])
</span><span class='line'>  }
</span><span class='line'>  fmt.Println("Done")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

在这段代码中，我们给每个goroutine分配了一个channel，在每个goroutine执行完时对该goroutine的channel进行写操作，而在第16行进行读操作，对于每个channel，
只有完成了写操作之后，才可以进行读取，否则会处于阻塞状态。因此在10个goroutine没有执行完之前，main函数是不会退出的。这样是不是比共享内存的方式更简单
而优雅呢？其实，我们还可以对代码继续进行简化，可以将匿名函数的传递的channel参数省去，而在匿名函数内部直接使用全局的chs[i]，匿名函数可以修改为如下：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>go func(i int) {
</span><span class='line'>  arr[i] = i + i*i
</span><span class='line'>  chs[i] &lt;- 1  // 写channel
</span><span class='line'>}(i)</span></code></pre></td></tr></table></div></figure>

</p>




<p>到这里，go的并行编程基本已经入门了，关于channel的更多详细的用法可以参见参考资料。</p>




<h2>参考资料</h2>


<p>[1] golang 官方主页：<a href="http://golang.org/">http://golang.org/</a></br>
[2] go语言编程，许世伟
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TOP 10开源的推荐系统简介]]></title>
    <link href="http://ibillxia.github.io/blog/2014/03/10/top-10-open-source-recommendation-systems/"/>
    <updated>2014-03-10T22:29:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/03/10/top-10-open-source-recommendation-systems</id>
    <content type="html"><![CDATA[<p>最近这两年推荐系统特别火，本文搜集整理了一些比较好的开源推荐系统，即有轻量级的适用于做研究的SVDFeature、LibMF、LibFM等，也有重量级的适用于工业系统的
Mahout、Oryx、EasyRecd等，供大家参考。PS：这里的top 10仅代表个人观点。</p>


<h2>#1.SVDFeature</h2>


<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031001.png"></center>


<p>主页：<a href="http://svdfeature.apexlab.org/wiki/Main_Page">http://svdfeature.apexlab.org/wiki/Main_Page</a> 语言：C++</br>
一个feature-based协同过滤和排序工具，由上海交大Apex实验室开发，代码质量较高。在KDD Cup 2012中获得第一名，KDD Cup 2011中获得第三名，相关论文
发表在2012的JMLR中，这足以说明它的高大上。</br>
SVDFeature包含一个很灵活的Matrix Factorization推荐框架，能方便的实现SVD、SVD++等方法, 是单模型推荐算法中精度最高的一种。SVDFeature代码精炼，可以用
相对较少的内存实现较大规模的单机版矩阵分解运算。另外含有Logistic regression的model，可以很方便的用来进行ensemble。</p>




<!--more-->




<h2>#2.LibMF</h2>


<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031002.gif"></center>


<p>主页：<a href="http://www.csie.ntu.edu.tw/~cjlin/libmf/">http://www.csie.ntu.edu.tw/~cjlin/libmf/</a> 语言：C++</br>
作者<a href="http://www.csie.ntu.edu.tw/~cjlin/">Chih-Jen Lin</a>来自大名鼎鼎的台湾国立大学，他们在机器学习领域享有盛名，近年连续多届KDD Cup竞赛上均
获得优异成绩，并曾连续多年获得冠军。台湾大学的风格非常务实，业界常用的LibSVM， Liblinear等都是他们开发的，开源代码的效率和质量都非常高。</br>
LibMF在矩阵分解的并行化方面作出了很好的贡献，针对SGD（随即梯度下降）优化方法在并行计算中存在的locking problem和memory discontinuity问题，提出了一种
矩阵分解的高效算法FPSGD（Fast Parallel SGD），根据计算节点的个数来划分评分矩阵block，并分配计算节点。系统介绍可以见这篇
<a href="http://www.csie.ntu.edu.tw/~cjlin/papers/libmf.pdf">论文</a>（ACM Recsys 2013的 Best paper Award）。</p>




<h2>#3.LibFM</h2>


<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031003.jpg"></center>


<p>主页：<a href="http://www.libfm.org/">http://www.libfm.org/</a> 语言：C++</br>
作者是德国Konstanz大学的Steffen Rendle，他用LibFM同时玩转KDD Cup 2012 Track1和Track2两个子竞赛单元，都取得了很好的成绩，说明LibFM是非常管用的利器。</br>
LibFM是专门用于矩阵分解的利器，尤其是其中实现了MCMC（Markov Chain Monte Carlo）优化算法，比常见的SGD优化方法精度要高，但运算速度要慢一些。当然LibFM中还
实现了SGD、SGDA（Adaptive SGD）、ALS（Alternating Least Squares）等算法。</p>




<h2>#4.Lenskit</h2>


<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031004.png"></center>


<p>主页：<a href="http://lenskit.grouplens.org/">http://lenskit.grouplens.org/</a> 语言Java</br>
<p>这个Java开发的开源推荐系统，来自美国的明尼苏达大学的GroupLens团队，也是推荐领域知名的测试数据集Movielens的作者。</br>
该源码托管在GitHub上，<a href="https://github.com/grouplens/lenskit">https://github.com/grouplens/lenskit</a>。主要包含lenskit-api,lenskit-core,
lenskit-knn,lenskit-svd,lenskit-slopone,lenskit-parent,lenskit-data-structures,lenskit-eval,lenskit-test等模块，主要实现了k-NN，SVD，Slope-One等
典型的推荐系统算法。</p>

<h2>#5.GraphLab</h2>
<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031005.png"></center>
<p>主页：<a href="http://docs.graphlab.org/collaborative_filtering.html">GraphLab - Collaborative Filtering</a> 语言：C++</br>
Graphlab是基于C++开发的一个高性能分布式graph处理挖掘系统，特点是对迭代的并行计算处理能力强（这方面是hadoop的弱项），由于功能独到，GraphLab在业界名声很响。
用GraphLab来进行大数据量的random walk或graph-based的推荐算法非常有效。Graphlab虽然名气比较响亮（CMU开发），但是对一般数据量的应用来说可能还用不上。</br>
GraphLab主要实现了ALS，CCD++，SGD，Bias-SGD，SVD++，Weighted-ALS，Sparse-ALS，Non-negative Matrix Factorization，Restarted Lanczos Algorithm等算法。</p>

<h2>#6.Mahout</h2>
<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031006.png"></center>
<p>主页：<a href="http://mahout.apache.org/">http://mahout.apache.org/</a> 语言：Java</br>
Mahout 是 Apache Software Foundation (ASF) 开发的一个全新的开源项目，其主要目标是创建一些可伸缩的机器学习算法，供开发人员在 Apache 在许可下免费
使用。Mahout项目是由 Apache Lucene社区中对机器学习感兴趣的一些成员发起的，他们希望建立一个可靠、文档翔实、可伸缩的项目，在其中实现一些常见的用于
聚类和分类的机器学习算法。该社区最初基于 Ngetal. 的文章 “Map-Reduce for Machine Learning on Multicore”，但此后在发展中又并入了更多广泛的机器学习
方法，包括Collaborative Filtering（CF），Dimensionality Reduction，Topic Models等。此外，通过使用 Apache Hadoop 库，Mahout 可以有效地扩展到云中。</br>
在Mahout的Recommendation类算法中，主要有User-Based CF，Item-Based CF，ALS，ALS on Implicit Feedback，Weighted MF，SVD++，Parallel SGD等。</p>

<h2>#7.Myrrix</h2>
<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031007.png"></center>
<p>主页：<a href="http://myrrix.com/">http://myrrix.com/</a> 语言：Java</br>
Myrrix最初是Mahout的作者之一Sean Owen基于Mahout开发的一个试验性质的推荐系统。目前Myrrix已经是一个完整的、实时的、可扩展的集群和推荐系统，主要
架构分为两部分：服务层：在线服务，响应请求、数据读入、提供实时推荐；计算层：用于分布式离线计算，在后台使用分布式机器学习算法为服务层更新机器学习
模型。Myrrix使用这两个层构建了一个完整的推荐系统，服务层是一个HTTP服务器，能够接收更新，并在毫秒级别内计算出更新结果。服务层可以单独使用，无需
计算层，它会在本地运行机器学习算法。计算层也可以单独使用，其本质是一系列的Hadoop jobs。目前Myrrix以被 Cloudera 并入Oryx项目。</p>

<h2>#8.EasyRec</h2>
<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031008.png"></center>
<p>主页：<a href="http://easyrec.org/">http://easyrec.org/</a> 语言：Java</br>
EasyRec是一个易集成、易扩展、功能强大且具有可视化管理的推荐系统，更像一个完整的推荐产品，包括了数据录入模块、管理模块、推荐挖掘、离线分析等。
EasyRec可以同时给多个不同的网站提供推荐服务，通过tenant来区分不同的网站。架设EasyRec服务器，为网站申请tenant，通过tenant就可以很方便的集成到
网站中。通过各种不同的数据收集（view,buy.rating）API收集到网站的用户行为，EasyRec通过离线分析，就可以产生推荐信息，您的网站就可以通过
Recommendations和Community Rankings来进行推荐业务的实现。</p>

<h2>#9.Waffles</h2>
<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031009.png"></center>
<p>主页：<a href="http://waffles.sourceforge.net/">http://waffles.sourceforge.net/</a> 语言：C++</br>
Waffles英文原意是蜂蜜甜饼，在这里却指代一个非常强大的机器学习的开源工具包。Waffles里包含的算法特别多，涉及机器学习的方方面面，推荐系统位于
其中的Waffles_recommend tool，大概只占整个Waffles的1/10的内容，其它还有分类、聚类、采样、降维、数据可视化、音频处理等许许多多工具包，估计
能与之媲美的也就数Weka了。</p>

<h2>#10.RapidMiner</h2>
<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031010.png"></center>
<p>主页：<a href="http://rapidminer.com/">http://rapidminer.com/</a> 语言：Java</br>
RapidMiner（前身是Yale）是一个比较成熟的数据挖掘解决方案，包括常见的机器学习、NLP、推荐、预测等方法（推荐只占其中很小一部分），而且带有GUI的
数据分析环境，数据ETL、预处理、可视化、评估、部署等整套系统都有。另外RapidMiner提供commercial license，提供R语言接口，感觉在向着一个商用的
数据挖掘公司的方向在前进。</br>
======================================分割线======================================</p>

<p>开源的推荐系统大大小小的还有很多，以上只是介绍了一些在学术界和工业界比较流行的TOP 10，而且基本上都是用C++/Java实现的，在参考资料[1]、[2]中还提
到的有Crab（Python）、CofiRank（C++）、MyMediaLite（.NET/C#）、PREA（Java）、Python-recsys（Python）、Recommendable（Ruby）、Recommenderlab（R）、
Oryx（Java）、recommendify（Ruby）、RecDB（SQL）等等，当然GitHub上还有更多。。。即有适合单机运行的，也有适合集群的。虽然使用的编程语言不同，但实现
的算法都大同小异，主要是SVD、SGD、ALS、MF、CF及其改进算法等。</p>

<h2>参考资料</h2>
<p>[1]<a href="http://blog.csdn.net/cserchen/article/details/14231153">推荐系统开源软件列表汇总和点评</a></br>
[2]<a href="http://www.oschina.net/search?scope=project&tag1=0&tag2=0&lang=0&os=0&q=%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F">开源中国社区 - 搜索：推荐系统</a>
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Koding——一个惊艳的在线编程开发平台]]></title>
    <link href="http://ibillxia.github.io/blog/2014/03/01/koding-an-amazing-online-development-environment/"/>
    <updated>2014-03-01T22:43:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/03/01/koding-an-amazing-online-development-environment</id>
    <content type="html"><![CDATA[<p>最近在v2ex上发现了一个非常酷的云编程发开平台——Koding，与大家分享一下，主要介绍一下它的基本功能和操作。</p>


<h2>What is Koding?</h2>


<p>Koding是一个在线的编程开发平台，致力于简化全球化的合作项目开发，并为每个人提供免费计算和开发资源。它已不仅仅是一个在线的编辑器那么简单，
而是通过提供免费的虚拟机（vm），上面安装了ubuntu操作系统，有真实的终端，允许开发者进行go、nodejs、ruby、python、php、js、C/C++等语言的开发，
可以安装各种工具和应用，。更主要的是，它是完全在线的，可以从世界上的任何地方访问，只需要一个浏览器。不仅如此，他还具有完美的社交功能，
可以和团队成员在线协作。</p>


<center><img src="http://ibillxia.github.io/images/2014/IMAG2014030101.png"></center>


<!--more-->




<h2>Activity Feed</h2>


<p>在Koding的<a href="https://koding.com/Activity">Activity面板</a>，是用户间交流的媒介，在这里可以看到一系列的状态更新、代码片段或用户动态。在这里你可以
创建主题，参与某些主题的讨论，可以关注他人，基本的社交功能都一应俱全。</p>




<h2>Development on Koding</h2>


<p>这是Koding的主体部分。在这里你可以像在本地计算机进行开发一样，当然这个可以在线操作，可以实现云同步，随时随地都可以访问，有木有很高大上？
在这里你可以导入自己的GitHub项目，在浏览器中进行项目开发，可以向GitHub push你的项目更新。这里有在线终端，有在线文本编辑器，还有内置浏览器。
除了和在本地编程开发一样的功能以外，还可以自行配置和添加vm，设置自己的独立域名等。下面我们来看看vm的一些硬件参数，主要是cpu、内存、硬盘、网络等。</p>


<p>硬件信息概要，要加sudo使用根权限并输入密码，不加short参数可以查看详细信息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ibillxia@vm-0:~$ sudo lshw -short 
</span><span class='line'>[sudo] password for ibillxia:         
</span><span class='line'>H/W path    Device   Class      Description
</span><span class='line'>===========================================
</span><span class='line'>                     system     Computer
</span><span class='line'>/0                   bus        Motherboard
</span><span class='line'>/0/0                 memory     15GiB System memory
</span><span class='line'>/0/1                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>/0/2                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>/0/3                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>/0/4                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>/0/5                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>/0/6                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>/0/7                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>/0/8                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>/0/100               bridge     440FX - 82441FX PMC [Natoma]
</span><span class='line'>/0/100/1             bridge     82371SB PIIX3 ISA [Natoma/Triton II]
</span><span class='line'>/0/100/1.1           storage    82371SB PIIX3 IDE [Natoma/Triton II]
</span><span class='line'>/0/100/1.2           bus        82371SB PIIX3 USB [Natoma/Triton II]
</span><span class='line'>/0/100/1.3           bridge     82371AB/EB/MB PIIX4 ACPI
</span><span class='line'>/0/100/2             display    GD 5446
</span><span class='line'>/0/100/3             network    Virtio network device
</span><span class='line'>/0/100/4             storage    Virtio block device
</span><span class='line'>/0/100/5             memory     RAM memory
</span><span class='line'>/1          eth0     network    Ethernet interface
</span><span class='line'>/2          gretap0  network    Ethernet interface</span></code></pre></td></tr></table></div></figure>


<p>查看cpu信息，E5-2630 8核2.30GHz，本文只摘取第1个核的信息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ibillxia@vm-0:~$ cat /proc/cpuinfo 
</span><span class='line'>processor       : 0
</span><span class='line'>vendor_id       : GenuineIntel
</span><span class='line'>cpu family      : 6
</span><span class='line'>model           : 45
</span><span class='line'>model name      : Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>stepping        : 7
</span><span class='line'>microcode       : 0x1
</span><span class='line'>cpu MHz         : 2299.998
</span><span class='line'>cache size      : 4096 KB
</span><span class='line'>physical id     : 0
</span><span class='line'>siblings        : 1
</span><span class='line'>core id         : 0
</span><span class='line'>cpu cores       : 1
</span><span class='line'>apicid          : 0
</span><span class='line'>initial apicid  : 0
</span><span class='line'>fpu             : yes
</span><span class='line'>fpu_exception   : yes
</span><span class='line'>cpuid level     : 13
</span><span class='line'>wp              : yes
</span><span class='line'>flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 cx16 pcid sse4_1 sse4_2 x2apic popcnt aes xsave avx hyperv
</span><span class='line'>isor lahf_lm xsaveopt
</span><span class='line'>bogomips        : 4599.99
</span><span class='line'>clflush size    : 64
</span><span class='line'>cache_alignment : 64
</span><span class='line'>address sizes   : 40 bits physical, 48 bits virtual
</span><span class='line'>power management:</span></code></pre></td></tr></table></div></figure>


<p>查看内存信息，共16GB内存</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ibillxia@vm-0:~$ cat /proc/meminfo                                                                                                                                                                                                                             
</span><span class='line'>MemTotal:       16433708 kB
</span><span class='line'>MemFree:         8506472 kB
</span><span class='line'>Buffers:          332884 kB
</span><span class='line'>Cached:          5334908 kB
</span><span class='line'>SwapCached:            0 kB
</span><span class='line'>Active:          3936496 kB
</span><span class='line'>Inactive:        2222980 kB
</span><span class='line'>Active(anon):    2093920 kB
</span><span class='line'>Inactive(anon):    10856 kB
</span><span class='line'>Active(file):    1842576 kB
</span><span class='line'>Inactive(file):  2212124 kB
</span><span class='line'>Unevictable:        5552 kB
</span><span class='line'>Mlocked:            5552 kB
</span><span class='line'>SwapTotal:             0 kB
</span><span class='line'>SwapFree:              0 kB
</span><span class='line'>Dirty:                 0 kB
</span><span class='line'>Writeback:             8 kB
</span><span class='line'>AnonPages:        482832 kB
</span><span class='line'>Mapped:            41668 kB
</span><span class='line'>Shmem:           1623556 kB
</span><span class='line'>Slab:            1522048 kB
</span><span class='line'>SReclaimable:    1225180 kB
</span><span class='line'>SUnreclaim:       296868 kB
</span><span class='line'>KernelStack:        6312 kB
</span><span class='line'>PageTables:        84660 kB
</span><span class='line'>NFS_Unstable:          0 kB
</span><span class='line'>Bounce:                0 kB
</span><span class='line'>WritebackTmp:          0 kB
</span><span class='line'>CommitLimit:     8216852 kB
</span><span class='line'>Committed_AS:    5225664 kB
</span><span class='line'>VmallocTotal:   34359738367 kB
</span><span class='line'>VmallocUsed:       45688 kB
</span><span class='line'>VmallocChunk:   34359561000 kB
</span><span class='line'>HardwareCorrupted:     0 kB
</span><span class='line'>AnonHugePages:     18432 kB
</span><span class='line'>HugePages_Total:       0
</span><span class='line'>HugePages_Free:        0
</span><span class='line'>HugePages_Rsvd:        0
</span><span class='line'>HugePages_Surp:        0
</span><span class='line'>Hugepagesize:       2048 kB
</span><span class='line'>DirectMap4k:      245748 kB
</span><span class='line'>DirectMap2M:     7094272 kB
</span><span class='line'>DirectMap1G:     9437184 kB</span></code></pre></td></tr></table></div></figure>


<p>硬盘测速，才219kB/s，不是一般的慢啊</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ibillxia@vm-0:~$ dd if=/dev/zero of=test bs=64k count=2k oflag=dsync
</span><span class='line'>2048+0 records in
</span><span class='line'>2048+0 records out
</span><span class='line'>134217728 bytes (134 MB) copied, 612.942 s, 219 kB/s</span></code></pre></td></tr></table></div></figure>


<p>网速测试，一般般</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ibillxia@vm-0:~$ ping www.github.com  # 测试1
</span><span class='line'>PING github.com (192.30.252.129) 56(84) bytes of data.
</span><span class='line'>64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=1 ttl=54 time=73.2 ms
</span><span class='line'>64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=2 ttl=54 time=75.9 ms
</span><span class='line'>64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=3 ttl=54 time=72.4 ms
</span><span class='line'>64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=4 ttl=54 time=72.3 ms
</span><span class='line'>64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=5 ttl=54 time=66.2 ms
</span><span class='line'>64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=6 ttl=54 time=66.1 ms
</span><span class='line'>^C
</span><span class='line'>--- github.com ping statistics ---
</span><span class='line'>6 packets transmitted, 6 received, 0% packet loss, time 5001ms
</span><span class='line'>rtt min/avg/max/mdev = 66.117/71.077/75.947/3.656 ms
</span><span class='line'>ibillxia@vm-0:~$ ping www.stackoverflow.com    # 测试2
</span><span class='line'>PING stackoverflow.com (198.252.206.140) 56(84) bytes of data.
</span><span class='line'>64 bytes from stackoverflow.com (198.252.206.140): icmp_req=1 ttl=49 time=76.1 ms
</span><span class='line'>64 bytes from stackoverflow.com (198.252.206.140): icmp_req=2 ttl=49 time=88.4 ms
</span><span class='line'>64 bytes from stackoverflow.com (198.252.206.140): icmp_req=3 ttl=49 time=75.1 ms
</span><span class='line'>64 bytes from stackoverflow.com (198.252.206.140): icmp_req=4 ttl=49 time=75.1 ms
</span><span class='line'>64 bytes from stackoverflow.com (198.252.206.140): icmp_req=5 ttl=49 time=75.3 ms
</span><span class='line'>64 bytes from stackoverflow.com (198.252.206.140): icmp_req=6 ttl=49 time=82.6 ms
</span><span class='line'>^C
</span><span class='line'>--- stackoverflow.com ping statistics ---
</span><span class='line'>6 packets transmitted, 6 received, 0% packet loss, time 5005ms
</span><span class='line'>rtt min/avg/max/mdev = 75.130/78.813/88.437/5.061 ms
</span><span class='line'>ibillxia@vm-0:~$ ping www.facebook.com     # 测试3
</span><span class='line'>PING star.c10r.facebook.com (31.13.77.81) 56(84) bytes of data.
</span><span class='line'>64 bytes from edge-star-shv-06-sjc1.facebook.com (31.13.77.81): icmp_req=1 ttl=81 time=153 ms
</span><span class='line'>64 bytes from edge-star-shv-06-sjc1.facebook.com (31.13.77.81): icmp_req=2 ttl=81 time=153 ms
</span><span class='line'>64 bytes from edge-star-shv-06-sjc1.facebook.com (31.13.77.81): icmp_req=3 ttl=81 time=153 ms
</span><span class='line'>64 bytes from edge-star-shv-06-sjc1.facebook.com (31.13.77.81): icmp_req=4 ttl=81 time=153 ms
</span><span class='line'>64 bytes from edge-star-shv-06-sjc1.facebook.com (31.13.77.81): icmp_req=5 ttl=81 time=153 ms
</span><span class='line'>^C
</span><span class='line'>--- star.c10r.facebook.com ping statistics ---
</span><span class='line'>6 packets transmitted, 5 received, 16% packet loss, time 5006ms
</span><span class='line'>rtt min/avg/max/mdev = 153.577/153.740/153.951/0.449 ms</span></code></pre></td></tr></table></div></figure>




<p>再来看看一些系统和软件信息。</p>


<p>查看linux内核版本、系统体系结构及预安装软件版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ibillxia@vm-0:~$ uname -a 
</span><span class='line'>Linux vm-0.ibillxia.koding.kd.io 3.13.0-5-generic #20 SMP Mon Jan 20 19:56:12 PST 2014 x86_64 x86_64 x86_64 GNU/Linux
</span><span class='line'>ibillxia@vm-0:~$ git --version
</span><span class='line'>git version 1.8.1.2
</span><span class='line'>ibillxia@vm-0:~$ mysql --version
</span><span class='line'>mysql  Ver 14.14 Distrib 5.5.32, for debian-linux-gnu (x86_64) using readline 6.2
</span><span class='line'>ibillxia@vm-0:~$ apache2 -v
</span><span class='line'>Server version: Apache/2.2.22 (Ubuntu)
</span><span class='line'>Server built:   Jul 12 2013 13:18:14</span></code></pre></td></tr></table></div></figure>


<p>常用编程语言版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ibillxia@vm-0:~$ gcc --version
</span><span class='line'>gcc (Ubuntu/Linaro 4.7.3-1ubuntu1) 4.7.3
</span><span class='line'>Copyright (C) 2012 Free Software Foundation, Inc.
</span><span class='line'>This is free software; see the source for copying conditions.  There is NO
</span><span class='line'>warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</span><span class='line'>
</span><span class='line'>ibillxia@vm-0:~$ g++ --version
</span><span class='line'>g++ (Ubuntu/Linaro 4.7.3-1ubuntu1) 4.7.3
</span><span class='line'>Copyright (C) 2012 Free Software Foundation, Inc.
</span><span class='line'>This is free software; see the source for copying conditions.  There is NO
</span><span class='line'>warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</span><span class='line'>
</span><span class='line'>ibillxia@vm-0:~$ java -version
</span><span class='line'>java version "1.7.0_25"
</span><span class='line'>OpenJDK Runtime Environment (IcedTea 2.3.10) (7u25-2.3.10-1ubuntu0.13.04.2)
</span><span class='line'>OpenJDK 64-Bit Server VM (build 23.7-b01, mixed mode)
</span><span class='line'>ibillxia@vm-0:~$ go version  
</span><span class='line'>go version go1.1.1 linux/amd64
</span><span class='line'>ibillxia@vm-0:~$ ruby --version
</span><span class='line'>ruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-linux]
</span><span class='line'>ibillxia@vm-0:~$ php --version
</span><span class='line'>PHP 5.4.9-4ubuntu2.3 (cli) (built: Sep  4 2013 19:32:25) 
</span><span class='line'>Copyright (c) 1997-2012 The PHP Group
</span><span class='line'>Zend Engine v2.4.0, Copyright (c) 1998-2012 Zend Technologies
</span><span class='line'>ibillxia@vm-0:~$ python --version                                                                                                                                                                                                                                     
</span><span class='line'>Python 2.7.4
</span><span class='line'>ibillxia@vm-0:~$ perl --version
</span><span class='line'> 
</span><span class='line'>This is perl 5, version 14, subversion 2 (v5.14.2) built for x86_64-linux-gnu-thread-multi
</span><span class='line'>(with 80 registered patches, see perl -V for more detail)
</span><span class='line'> 
</span><span class='line'>Copyright 1987-2011, Larry Wall
</span><span class='line'> 
</span><span class='line'>Perl may be copied only under the terms of either the Artistic License or the
</span><span class='line'>GNU General Public License, which may be found in the Perl 5 source kit.
</span><span class='line'> 
</span><span class='line'>Complete documentation for Perl, including FAQ lists, should be found on
</span><span class='line'>this system using "man perl" or "perldoc perl".  If you have access to the
</span><span class='line'>Internet, point your browser at http://www.perl.org/, the Perl Home Page.</span></code></pre></td></tr></table></div></figure>




<h2>Installing and Using KDApps</h2>


<p>除了系统已安装的基本应用外，用户还可以在<a href="https://koding.com/Apps">Koding/Apps</a>上选择一些官方的apps安装到自己的vm上。可以
在线绘图、编辑照片等等。</p>




<h2>Online Teamwork</h2>


<p>Koding还具有团退协作功能，你可以创建自己的group或参加到别人的group中。加入到一个team后，系统会分配你一个Session ID，通过这个ID你可以进入
到队友的vm当中，然后你们相互之间都可以看到对方的编码动态。</p>




<p>关于Koding的更多内容，请戳<a href="http://learn.koding.com/getting-started/">Learn Koding</a>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[互联网引发的制造业革命——读《创客》]]></title>
    <link href="http://ibillxia.github.io/blog/2014/02/23/makers-the-new-industrial-evolution/"/>
    <updated>2014-02-23T22:07:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/02/23/makers-the-new-industrial-evolution</id>
    <content type="html"><![CDATA[<p>其实很早之前就买了这本书，是在13年6月份和『看见』、『黑客与画家』等一起买的吧，看完这两本书后也就开始看『创客』了，
但都是断断续续的看，没有花比较集中的时间，而且感觉前面几章将的内容没有那么大的吸引力。后来双11做活动，又买了10来本书，
其中有雷军、周鸿祎等IT大佬的传记，还有几本成功励志类、文学类的书，就又跳着去看这些书了。开学初闲着无聊就又拿起这本书
来看了，看到了第二部分后，才发现原来这本书是如此之好，特别是开源硬件、众筹、云工厂等新兴工业和商业模式，让人印象深刻。</p>




<h2>作者&内容简介</h2>


<p>这本书的作者是克里斯•安德森，一个很多人耳熟能详的名字。现任『连线』杂志主编，是3D Robotics和DIY Drones的联合创始人，
也是『纽约时报』畅销书『长尾理论』及『免费：商业的未来』的作者。</p>


<center><img src="http://ibillxia.github.io/images/2014/IMAG2014022301.jpg"></center>


<p>『创客：新工业革命』一书以独特的视角分析了传统的制造业在汹涌澎湃的互联网浪潮中发生的翻天覆地的变化。在互联网这个广阔媒介的
笼罩下，每个人都可以分享自己的idea、设计方案和产品原型，也可以评论和完善他人的idea、方案和产品，每个人都可以DIY，都可以自己动手
创造出新的东西。只要你敢想敢做，nothing is impossible！在长尾效应无法避免的情况下，每个人都可以设计个性化的产品，解决个性化的
问题，新发明不断涌现。3D打印的兴起，使得新产品的制造更加模块化，更加便捷。硬件设计的开源，又加剧了产品的分化和个性化，也使得其
更新换代和性能提升更快。云工厂又使得发明者可以不用白手起家建立加工厂，从而更加便捷的将自己的设计付诸实践。而众筹这种新的集资模式
又解决了发明者自尽缺乏的后顾之忧，而且提前为之提供了市场需求情况。所有的这些因素，使得制造业空前的繁荣，一场新的工业革命正在萌发。</p>


<!--more-->




<h2>长尾效应&DIY&发明革命</h2>


<p>长尾（The Long Tail），或译长尾效应，最初由克里斯·安德森（Chris Anderson）于2004年发表于自家的<a href="http://www.wired.com/wired/archive/12.10/tail.html">杂志</a>，
用来描述诸如亚马逊公司、Netflix和Real.com/Rhapsody之类的网站之商业和经济模式。是指那些不受到重视的、销量小但种类多的产品或服务
由于总量巨大，累积起来的总收益超过主流产品的现象。下图中纵轴为“人气”，横轴为“产品”，黄色部分即为长尾。
<center><img src="http://ibillxia.github.io/images/2014/IMAG2014022302.png"></center>
在互联网领域，长尾效应尤为显著。比如亚马逊上的书籍的销售情况，<a href="http://papers.ssrn.com/sol3/papers.cfm?abstract_id=400940">Erik</a>等
用指数曲线研究了亚马逊网站的书本销售量和销售排名的关系，并发现亚马逊40%的书本销售来自于**本地书店里不卖**的书本。在亚马逊这个案例上，
可应用“长尾”概念解释：它一半左右的销售来自于比较热门的商品，而另一半却来自相对不那么热门的商品。这跟传统
的“<a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%AB%E5%AE%9A%E5%BE%8B">二八定律</a>”完全相反。这使得我们可以逆向的思考，不再紧盯着
那20%的大众化产品，而去关注后80%的“长尾巴”，同样也可以很有前途。</p>


<p>在小众产品市场中，DIY（即do it yourself）可谓独树一帜，占据着举足轻重的地位。在这个充满个性化的时代里，个性就是时尚，独一无二
永远是时尚一族的追求。虽然DIY已经有半个多世纪的历史，但在如今的互联网环境下，DIY更是发挥到了极致：DIY电脑、音箱、手机，DIY网站、个人博客，
DIY首饰、工艺品，DIY家具、房屋，DIY台历、杯子、布偶、玩具。。。可以自己设计个性化的服装图案，可以自己组装各种硬件设备。书中作者
的外公DIY了自家的garden的灌溉系统，使之自动化甚至可以远程遥控，并将系统申请了专利。书中还有对玩具DIY、对乐高机器人DIY的例子。</p>


<p>互联网的存在，使得DIY的产品无论从数量还是质量上，都产生了很大的飞跃，很多新的设计方法和实现方式都具有申请专利或发明的资质，
每个人都可以成为名副其实的发明家，只要你敢于发现、敢于创造。互联网的资源与idea分享的开放环境，使得发明创造的空间急剧膨胀，而时间逐渐
缩短，各种新技术不断涌现，创业的浪潮居高不下，创业和发明甚至已成为一种时尚。</p>




<h2>3D打印&开源软硬件</h2>


<p>最近两年3D打印还挺火的，只需要向3D打印机输入三维的设计模型，即可打印出一个三维的产品。随着技术的更新、新材料的研制，3D打印机能够
制作的东西越来越多、越来越复杂，各种小型的装饰品、日用品、玩具模型等，都是小case，在不远的未来连汽车都可以打印了，多么神奇！3D打印的
兴起，使得产品的设计者们只需要使用CAD软件，对产品进行三维建模，然后将数字化的模型输入到打印机，即可得到成型的产品，不用另外话时间去
组装。对产品进行改进，只需要在CAD软件中对模型设计进行修改和优化，产品的生产周期大大压缩。</p>


<p>在书中，作者将开源硬件单独设立了一张，篇幅还不小。现如今，硬件电路都可以用计算机代码（如硬件描述语言VHDL等）和图文来描述和设计，
硬件的设计方案都数字化、信息化了，开源出它的设计方案在互联网上，人们可以随意对其进行添加新模块或删改或组合，形成新的硬件，实现新的
应用场景。书中提到的比较典型的开源硬件要数Arduino了，这是包含很多常见功能模块的硬件开发板，有很多可自选的组件（甚至可以和智能手机互联），
可以编程，从而可以实现各种很酷的功能，比如爬行机器人、小飞行器、智能垃圾桶、音乐魔方等等，比如Arduino中文社区中展示的一个非常酷的
<a href="http://www.arduino.cn/article-3-1.html">万向轴语音机器人</a>。</p>




<h2>云工厂&众筹</h2>


<p>也许我们要DIY的产品还无法用3D打印机来制造，也许我们要hack的东西也不是通过现成的开源软硬件就能实现，现在我们不用担心这些了，因为
现在的互联网可谓无所不能，我们可以通过云工厂来为我们生产定制的产品。互联网的存在，使得我们不用亲临工厂，在网络上就可以寻找合适的代
工厂，无论它在国内还是海外。网上开店开工厂，早已不是什么新鲜事了。早在90年代末，互联网才刚刚兴起的时候，本书的作者就认识了当今中国
网上商城的大佬——马云，当时马云就开始将各种公司信息搬到网上。而现如今，很多网上商城不仅可以提供现成的产品，而且可以接受私人定制的产
品。</p>


<p>也许我们没有资金来购买昂贵原材料，也许我们没有能力去做产品的市场调查，因为现在我们有了众筹这种新的互联网集资模式。众筹的思路是，
发明者在网络上发布自己的产品方案和原型，寻求需要该产品的网友的支持，无论是对你进行资金支持，还是对你进行精神鼓励。有需求者还可以提前
以优惠的价格预定，提前支付。现在网上这样的众筹平台已经有很多了，作者在书中提到了Kickstarter等，国内有点名时间(demotime)等等，上面有
很多很有意思的项目，大家可以去看看。在众筹平台上，创意的发布者需要提供产品的方案及可行性，需要筹集的资金量，以及筹集周期，然后让网友
来投票，提供意见，预定产品。如果在筹集结束前能够达到预定的金额，那么就可以顺利进入实质生产阶段了。人们不用再去寻找非常困难而且风险
很大的贷款或风险投资。</p>


<p>有了云工厂和众筹这些完美的平台，创意的实现可谓零门槛，所有你需要做的就是展开思维的翅膀，在生活中去发现、去创造。</p>




<h2>未来</h2>


<p>互联网的普及，新技术、新思维的不断涌现，互联网正在对传统制造业产生巨大的冲击，特别是处于80%的长尾部分的传统制造业。“创客运动”的
天平偏向于最佳创新模式，而非最廉价的劳动力，人才与创新对企业的发展越来越重要，制造业正在发生深刻的变革，未来充满着机遇和挑战！Are you READY？！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如果长颈鹿哭了，它会不会要哽咽好久]]></title>
    <link href="http://ibillxia.github.io/blog/2013/12/24/if-giraffe-cried-would-it-choking-so-long/"/>
    <updated>2013-12-24T19:29:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/12/24/if-giraffe-cried-would-it-choking-so-long</id>
    <content type="html"><![CDATA[<p>一篇很唯美的文章，来自豆瓣相册：<a href="http://www.douban.com/photos/album/63673280/?start=0">如果长颈鹿哭了，它会不会要哽咽好久</a>，有微小删改。<br/>
在酷我调频的莫萱日记“<a href="http://www.kuwo.cn/yinyue/3619660/">关于我爱你这件小事</a>”这一期中听到的，分享给大家，顺祝大家圣诞快乐！</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122401.jpg"></center>


<p>长颈鹿的脖子那么长 哽咽的时候是不是很难受<br/>
我没有长长的脖子 却哽咽的说不出话<br/>
章鱼有三颗心脏 心痛的时候是不是很疼<br/>
我没有三颗心脏 体会不到无法忍受的痛再多三倍<br/>
乌鸦可以学人说话 尴尬的时候会不会装咳嗽<br/>
我假装咳嗽 假装被沙子迷了眼 你也没有看我一眼<br/>
骆驼有长长的睫毛 想哭的时候能不能说眼睛进了沙<br/>
我假装咳嗽 假装被沙子迷了眼 你也没有看我一眼<br/>
蛇没有宽宽的肩膀 她累的时候给不了能够依靠的温暖<br/>
是因为我太弱小 没有很可靠的肩膀么<br/>
小强有两个大脑 孤单的时候会不会一起想着谁<br/>
无时无刻的清澈的想念 一定比两个大脑一起想你还多吧<br/>
蜉蝣只能活很短 可能一辈子都来不及和心里珍藏的那个人说一些想说的话<br/>
我又能活多久 时间会不会给我可以开口的勇气<br/>
把人生看做是自己独一无二的创作 便不会频频回首<br/>
你会不会忽然地出现 在旧时光的风景里 成为珍藏一生的美丽</p>

<!--more-->




<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122402.jpg"></center>


<p>夏天过去　你没有消息<br/>
说会再见终究我相信了你<br/>
秋天来临，我想等下去<br/>
你最爱的叶子花语是关心<br/>
咖啡色的鞋子 灰色毛衣 从以前到现在的玩具<br/>
你的表情 太没志气　说我很想你<br/>
把握太轻，却让人沉重地无法逃离<br/>
我只是觉得 这种牵挂放着无趣丢了可惜</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122403.jpg"></center>


<p>两个人一起是为了快乐，分手是为了减轻痛苦<br/>
你无法再令我快乐，我也唯有离开<br/>
我离开的时候，也很痛苦<br/>
只是，你肯定比我痛苦<br/>
因为我首先说再见，首先追求快乐的是我。<br/>
爱上一个人的时候，总会有点害怕<br/>
怕得到他，怕失掉他<br/>
有时候，我们愿意原谅一个人<br/>
并不是我们真的愿意原谅他<br/>
而是我们不想失去他<br/>
不想失去他，唯有假装原谅他<br/>
恨，也是一种爱<br/>
岁月漫长，装着装着也许真的就能够原谅与遗忘。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122404.jpg"></center>


<p>所有单向的爱情，是不是终归也会有悄然落幕的一天？<br/>
所有寂寞的影子，是不是终究走不出黑夜之后的黎明？<br/>
我爱你，可以跟你无关<br/>
可是，我希望它是跟你有关的。<br/>
单恋也是爱情吧？<br/>
只是，这种爱情与人无尤<br/>
爱你是我一个人的事<br/>
我自己回答自己，自己荣耀自己，自己呼应自己<br/>
在我悄悄单恋着的那个人身后，我多么像个寂寞的影子？<br/>
时而甜蜜，时而苦涩<br/>
那不是懦弱，那只是不被允许的爱情<br/>
于是，我只能选择沉默。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122405.jpg"></center>


<p>一段爱情，两个人成长<br/>
无论是否能够和你终老<br/>
那么投入地爱过彼此<br/>
流过那么多的眼泪，我们都长大了。<br/>
因为曾经那样喜欢一个人，<br/>
所以无法接受自己稍微不喜欢的人。</p>

<p>为什么要急着长大呢？正如你不会急着老去<br/>
总有一天，你会长大<br/>
要是可以一直不长大<br/>
不需要面对人生汹涌的波涛<br/>
不需要把棱角磨平<br/>
也是一种幸福啊！</p>

<p>我以为爱情可以克服一切<br/>
谁知道它有时毫无力量<br/>
我以为爱情可以填满人生的遗憾<br/>
然而，制造更多遗憾的，偏偏是爱情本身<br/>
阴晴圆缺，在一段爱情里不断重演<br/>
换一个人，也不会天色常蓝。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122406.jpg"></center>


<p>既然未曾拥有，又怎知道它有多好？<br/>
因为错过了<br/>
所以，当我们觉得不幸福的时候<br/>
总会为那段错过了的感情和那个错过了的人加入许多幻想和诗意<br/>
念念不忘的，不过是自己想象的画面。</p>

<p>那个长夜，漫天星宿<br/>
得睹芳容，魂摧魄折<br/>
想认识你，想爱你，想守护你<br/>
换几声欢笑，一场热泪，告别飘摇无根的生活<br/>
我不是暗影，我是归人<br/>
我，终究是爱你的</p>

<p>曾经，你苦苦以为<br/>
没有了这个人，也就活不成了<br/>
到了后来，不是活得好好的吗？<br/>
一个不爱你的人，决不会比你的生命重要<br/>
一个爱你的人，会告诉你，你的生命比你对他的爱情重要。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122407.jpg"></center>


<p>&#8220;你问我喜欢那声音不───若是现在，我一定说喜欢了。&#8221;<br/>
你说过这是你高中时最爱的新诗<br/>
岁暮总是无故想起，无由来地感动<br/>
又到岁暮了，我想把它送你<br/>
尘世的声音很多<br/>
亲人的、爱人的、知己的、幸福的、悲伤的<br/>
到后来又有哪些永留心中却或许有一天再也听不到了？<br/>
你的声音是我的天籁，会一直在我心头。</p>

<p>假如想念是一张地图<br/>
打开想念的地图<br/>
你也许会发现<br/>
不管这张地图有多么复杂<br/>
想念的起点也是终点<br/>
小孩子想念的是亲人<br/>
长大了，想念的是恋人<br/>
后来的后来，想念的对象又变成了亲人<br/>
人生最初和最后的想念几乎是一样的</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122408.jpg"></center>


<p>对男人来说<br/>
旧情人所生的女儿都是漂亮的<br/>
因为她长得像她妈妈<br/>
旧情人所生的儿子却很难看，因为他长得像他爸爸。──《想念》</p>

<p>每个人都带着童年故事和许多过去去爱上一个人<br/>
被渴求、被迁就、被照顾、被荣耀<br/>
也许都是一个过程<br/>
千回百转，直到不年轻了<br/>
才终于学会爱<br/>
却又不一定能遇到可以相爱的人<br/>
遇到了又是否可以厮守呢？无常世间没有圆满；</p>

<p>可是，幸运的话<br/>
会遇到你说的那个人<br/>
他完整了我<br/>
也是他让我看到我所有的缺失。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122409.jpg"></center>


<p>两个人最初走在一起的时候<br/>
对方为自己做一件很小的事情<br/>
我们也会感动<br/>
后来，他要做更多事情，我们才会感动<br/>
再后来，他要付出更多更多，我们才肯感动<br/>
人是多么贪婪的动物？<br/>
无论我们一生撒过多少谎<br/>
自欺终究比欺人的时候多<br/>
我对你说谎的时候<br/>
眼睛也许微笑颤抖，害怕你看出来<br/>
我对自己说谎的时候<br/>
却连眉头也不会皱一下<br/>
要面对人生种种痛苦和真相<br/>
委实太残忍了，我难道不能对自己说谎吗？<br/>
可惜，人有时还是骗不了自己<br/>
终于，我不得不苦涩地承认<br/>
你已经不爱我了。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122410.jpg"></center>


<p>他不是不爱你，也不是对你不好<br/>
他只是更爱自己，永远把自己放在第一位<br/>
他可爱的时候很可爱，自私的时候却又很自私<br/>
你恨透他的自私，心里却知道他改不了<br/>
他就是这样的一个人，天性如此<br/>
爱上一个自私的人，这样的爱是孤单还是无奈？<br/>
你终于明白，自私的人是比较快乐的<br/>
要是可以自私，那该多好。<br/>
所有处在恋爱年龄的女孩子，总是分成两派：<br/>
一派说，爱对方多一点，是幸福的；<br/>
另一派说，对方爱我多一点，才是幸福的<br/>
也许，我们都错了<br/>
爱的形式与分量从来不是设定在我们心里<br/>
你遇到一个怎样的男人<br/>
你便会谈一段怎样的恋爱。<br/>
希望有个人，在我嘴里说没事的时候，看出我不是真的没事<br/>
有个人，在我强颜欢笑的时候，知道我不是真的开心<br/>
也是这个人，在我拚了命憋住眼泪的时候<br/>
偏偏挨过来摸摸我的头，对我说：&#8221; 别哭，别哭，&#8221; <br/>
结果害我把脸埋在他身上稀哩哗啦哭得更惨，却也不会生他的气。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122411.jpg"></center>


<p>爱情是什么？不就是有个人<br/>
有些失望是不可避免的<br/>
但大部分的失望，都是因为你高估了自己<br/>
又或者是高估了你爱的那个人<br/>
无论高估的是谁，终也难免失望。<br/>
梦想有时候多么像爱情？<br/>
假若不是痴心相信，是无法坚持到底的<br/>
只是，失落了的梦想也像失落了的爱情<br/>
始于如此的兴奋与渴望，又终于如此的挫败与荒凉。<br/>
时间似乎一直在我们眼前流逝<br/>
它像无情的小鸟，拍翅高飞，永不回首<br/>
而其实，我们才是那只小小鸟，短暂勾留，倏忽飞逝<br/>
时间亘古长存，它一直都在那儿，从未飞渡<br/>
惟有我们自己与所爱的人，终会成为过去<br/>
所有的相依与相聚、所有的阴晴圆缺，也如飞似逝，永不复还。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122412.jpg"></center>


<p>爱情总是想象比现实美丽<br/>
相逢如是，告别亦如是<br/>
我们以为爱得很深很深<br/>
来日岁月，会让你知道，它不过很浅很浅<br/>
最深最重的爱，必须和时日一起成长。<br/>
“我不要你管！” <br/>
女人的这句话好像总是冲她最在乎的那个人说，<br/>
也总是言不由衷<br/>
她真正的意思也许是：<br/>
“要是你不爱我，你就别管我！”</p>

<p>想和你一起变老，<br/>
老得地老天荒，<br/>
老得这世界把我俩都忘掉了，<br/>
惟独你记得我年轻的容颜。<br/>
当所爱的人骤然离世，<br/>
那份伤痛是不会离去的，<br/>
它会沉淀、会改变你。<br/>
伤痛过后，<br/>
他会想你坚强地活下去，<br/>
想你幸福地活着。<br/>
因为他知道，<br/>
他也活在你心里，<br/>
成了你的一部分，<br/>
是你的血肉，你活得好，他才会好。<br/>
生于斯世，我们不都是旅人吗？<br/>
他不会回来了；但是，你终归会回去。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122413.jpg"></center>


<p>樱花如风转眼去，惟有拜拜是人生<br/>
曾经以为，拥有是不容易的；后来才知道，舍弃更难。<br/>
有些人，你不敢接近他，可能是因为你爱他，你害怕被拒绝，害怕受伤害<br/>
有些人，你不想接近他，是真的不想<br/>
说不上讨厌这个人，倒是很想微笑对他说：<br/>
“你走开吧你！麻烦你离我远一点。我不是傻的，我也没那么好骗。”<br/>
一天，我们不无惊讶地发现<br/>
过去所有的日子都恍若昨日<br/>
时间永远比我们以为的走得快<br/>
但是，我已经不是昨日那个年少青涩的人了<br/>
我爱过和我爱着的人<br/>
也和我一样，一点点老去<br/>
活着就是要经历这些。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122414.jpg"></center>


<p>童话故事不一定都美好，安徒生有些童话就很悲伤。<br/>
快乐王子只是子虚乌有，阿拉丁神灯不过是天方夜谭。<br/>
我们还要继续相信童话吗？<br/>
童话只属于真正的小孩而不是老小孩<br/>
可是，每个老小孩心中都有一个不朽的童话<br/>
它一直在那儿，遥远而美好，天真却也荒凉，不曾老去，从未被现实消磨。<br/>
你的那个童话又是什么<br/>
一切事物，包括感情，也有它最好的时机。<br/>
某年某天某一刻，你很想对他说：“ 我爱你 ”<br/>
可是，他脸上的神情似乎没有准备好听到这句话<br/>
一瞬间，说到唇边的话消逝了。 <br/>
以后的以后，或许再也不会说了</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122415.jpg"></center>


<p>千回百转，幸福原来一直在自己手里。<br/>
机遇降临时，努力把握；<br/>
缘分来时，好好抱住它。<br/>
再难再苦也要拍拍胸膛迎上去，<br/>
擦干眼泪，我会微笑到最后。<br/>
执子之手，红尘终老。<br/>
卑微的爱无法爱到地老天荒，它总难免会有终结的一天。<br/>
但是，战战兢兢地爱着一个人的时候，<br/>
多么像一只没有自信的丑小鸭？<br/>
害怕自己配不上对方。<br/>
直到一天，羽化成天鹅了，<br/>
也许会怀念丑小鸭的那些傻痴痴的日子<br/>
爱情是一百年的孤独，<br/>
直到遇上那个矢志不渝守护着你的人，<br/>
那一刻，<br/>
所有枯涩的孤独，<br/>
都有了归途</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122416.jpg"></center>


<p>你问：“没有爱情我们到底能不能活得很潇洒？”<br/>
人往往因为爱情而活得很不潇洒。<br/>
当你了解男人都是小孩子，<br/>
你就了解人生所有的事情<br/>
你问：“如何信任一个人呢？在有过失望之后，怎样才能好好去相信别人？”<br/>
我相信真心是会有回报的。<br/>
付出真心去相信一个人，<br/>
即使会受伤害，<br/>
那是我的劫难。<br/>
我也无愧了</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122417.jpg"></center>


<p>年轻就是会高估了爱情的寿命<br/>
年轻就是不懂说不<br/>
年轻就是会为了讨好你爱的那个人而扭曲自己<br/>
年轻就是会错爱<br/>
年轻就是会相信谎言<br/>
年轻就是会天真到笨<br/>
江湖老了每一个曾经青涩的少年，<br/>
江湖也老了每一个爱做梦的少女。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122418.jpg"></center>


<p>爱情终究是两厢情愿的事，你留不住一个不爱你的人；<br/>
你也不会愿意留住一个已经不爱你、只是可怜你的人<br/>
有这样的日子,还没起床,就知道今天会非常想念你；<br/>
也有这样的日子,一直忙到半夜,才惊觉一整天连一秒都没有想过你。<br/>
这都是由不得我的事,<br/>
在清晨并没有人会预报给我听:<br/>
今天到底下哪一种雨,飘哪一朵云。<br/>
这只是我每天要经历的,我一个人的小天气。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122419.jpg"></center>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[36氪开放日杭州站回顾与总结]]></title>
    <link href="http://ibillxia.github.io/blog/2013/11/11/36kr-open-day-hangzhou-station-review-and-summary/"/>
    <updated>2013-11-11T19:10:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/11/11/36kr-open-day-hangzhou-station-review-and-summary</id>
    <content type="html"><![CDATA[<p>11月10日，36氪开放日第二次来到杭州站，首次进入大学，进行互联网行业创业和投资的机遇、观点和经验分享。这次开放日主要包含三个部分：</br>
（1）成功创业者/投资者的主题分享；</br>
（2）初创团队的产品发布与展示；</br>
（3）观众参与: 10位观众每人1分钟demo展示。</br>
本文回顾并总结一下这次活动的主要观点。</p>




<center><img src="http://ibillxia.github.io/images/2013/IMAG2013111101.jpg"></center>




<p>主题分享的特邀嘉宾有来自阿里的副总裁纪纲，来自阿米巴的资本合伙人、挖财董事长李治国，来自丁香园的CTO、微信「小道消息」作者冯大辉@Fenng，
毕业于浙大的个推创始人方毅@方毅_个推，来自网易杭研院的产品经理、目前负责易信的章行，来自Nokia的体验创新中心总经理傅蕾。</p>


<p>初创团队的产品展示有7个，分别是——金亦冶-Kivvi收银平板：时尚店主的POS收银机，徐文俊-找大巴：首创BO2O大巴招投标预订直销模式、大巴预订神器，何翱翔-九漫：交互式动态漫画，
袁一伦-要出发旅行：主打周边自驾游，李军-微洽：面向企业的社交化工作平台，胡笃晟-阿姨厨房：为厨艺爱好者提供在家创业、P2P模式的餐饮服务电子商务平台，凌曙-同船渡：位置景点
创建和结伴出游的旅行产品。</p>




<!--more-->




<p>而现场观众的1分钟demo部分，有14 位观众带着他们的产品或者idea来跟大家分享：画吧、快读、37 度、比比、氢学习、Omygod、Tipix—照片编辑App、配配、
微信公众账号杭电助手、车纷享、穿戴式智能设备、享赢棋牌联盟、爱扫货、微博书等。</p>




<h2>特邀嘉宾的主题分享</h2>


<p>主题分享有6个，在正式分享开始之前，『36氪联合创始人·主编（第二帅[偷笑]）王壮@truant 分享 1.创业公司的理想和坚持：传递正能量 ，帮助创业者，“我们是不收车马费的媒体人”；
2.大学生互联网行业的就业：一要开阔视野，培养兴趣点；二要有展现自己能力的作品，掌握独特技能。』（<a href="http://e.weibo.com/2863376813/Ai52PFTkN">微博</a>）感到比较吃惊的
是36kr的创业团队都是88后的，而且能够做得如此之好。分享的第二点也很有启发意义，既要有开阔的视野又要掌握独特技能，寻找自己的兴趣和特长、培养独特的技能是重中之重。</p>




<p>第一个主题分享是阿里副总裁纪纲的分享。『嘉宾分享之 阿里巴巴集团副总裁纪纲：首先是对战略投资的理解——公司业务先遣队，而VC和创业者关系也同样很重要。他强调了生态圈的概念：互联网是
生机勃勃的生态；纪纲谈到值得关注的两个方向：垂直性入口、软硬件结合。初创团队基因很重要，更要关注解决问题和寻找机会的平衡。』（<a href="http://e.weibo.com/2863376813/Ai5a3DfMh">微博</a>）
我个人也总结了3点：『1.阿里的收购观点分享；2.移动互联网创业潮已过，但真正的浪潮还没到来；3.移动互联网的机会还很多，垂直入口还有希望。』（<a href="http://weibo.com/2704795533/Ai5cz2iCF">微博</a>）
对于创业者而言，垂直性入口和软硬件结合这两个方向确实还有很多机遇。</p>




<p>第二个主题分享来自阿米巴的资本合伙人李治国。『嘉宾分享之 阿米巴资本合伙人、挖财董事长李治国：投资和融资经验。投资不仅要有眼光，而且要有运气。当今时代，投资的心态也需转变。
被投资的团队要有承载资金的能力，双方需判断方向和坚持方向；有些时候做事情只要赌对了方向，刚性需求+好的团队就等于成功的一半。』（<a href="http://e.weibo.com/2863376813/Ai5iLvRkg">微博</a>）
主要是投资方面的观点分享：『判断和经验很重要，坚持也很重要！』（<a href="http://weibo.com/2704795533/Ai5f8kdb2">微博</a>），『赌对方向+nb团队。投过@蘑菇街 和@快的打车』
（<a href="http://weibo.com/2704795533/Ai5ixheZx">微博</a>）。</p>




<p>第三个主题分享来自个推的 @方毅_个推。『嘉宾分享之 个推创始总经理方毅：要变，还得是绝活——如何在业务迁移中保持竞争力？快到极致，爽到极致，“帅”到极致。[威武]』
（<a href="http://e.weibo.com/2863376813/Ai5Jqdcff">微博</a>）。@北隐_BEIYIN的这个总结也不错：『方总@方毅_个推 在做分享“要变还得有绝活”，满口的“苦逼”“屌丝”
“让你爽到极致”“生理反应”“就要给你想要的”…哈哈哈哈[哈哈][哈哈] 不过话糙理直 ①学会在夹缝中生存发展 ②能够把握住深层次的需求痛点 “我们就是为了方总来的” [围观][围观]』
（<a href="http://weibo.com/3410997984/Ai5JJ4AfO">微博</a>）上次在一个创业圆桌分享会上见识过了方总，这次方师兄从自己苦逼的创业历程讲如何在业务迁移中保持竞争力，
要变，还要是绝活！给挣扎在创业道路上同样苦逼奋斗的年轻创业者们一个很好的警示。
<center><img src="http://ibillxia.github.io/images/2013/IMAG2013111102.jpg"></center>
</p>




<p>第四个分享来自Nokia的体验创新中心总经理傅蕾。『嘉宾分享之 诺基亚体验创新中心总经理傅蕾从NEIC的愿景、职能、工作模式、资源、最新进展和动态六个方面讲述
了NEIC如何帮助创业者、开发者开发Windows Phone 平台APP，提出了“3000+300+30”的目标，和“体验创新-扶持-成长-产出”的工作模式。』（<a href="http://e.weibo.com/2863376813/Ai5UHkUO8">微博</a>）。
主要介绍了Nokia的体验创新中心的一些目标和愿望，这种亡羊补牢，为时晚矣？ 还是为时未晚？拭目以待~
</p>




<p>第五个分享来自网易杭研院的产品经理、目前负责易信的章行。『嘉宾分享之 网易杭州研究院产品经理章行：移动IM社交思考。什么是社交？社交的本质——人与人的“资源”交换。
章行认为，中国人没社交，只有消遣，是移动网络降低了交换成本；而在IM下的SNS永远只是补充。社交产品的核心任务是建立健康长久的用户关系链；团队需要取得多方面平衡。[害羞]』
（<a href="http://e.weibo.com/2863376813/Ai6oppHi1">微博</a>）。很有理性很有深度的一个分享，相比于来往没节操的广告，易信还是比较脚踏实地的在做。
</p>




<p>第六个分享来自丁香园的CTO、微信「小道消息」作者冯大辉@Fenng。『嘉宾分享之 丁香园网站CTO冯大辉：问题与痛点。1.找到用户的问题：了解用户困境、理解用户行为、
理解商业逻辑；以用户思维分析问题、以互联网思维解决问题，未必需要技术。2. 用户的痛点：痛点是用户解决不了的问题、承受不了的成本、麻烦快要死的事，更可能不存在。
“发现比想更重要”。』（<a href="http://e.weibo.com/2863376813/Ai6zi2jXi">微博</a>）。辉哥@Fenng 吐槽了很多，把很多公司贬为“狗屎”，也从“问题与痛点”深入细致的
分析了在创业过程中，创业者们在解决问题和消除痛点时要思考的一些问题。
<center><img src="http://ibillxia.github.io/images/2013/IMAG2013111103.jpg"></center>
</p>




<h2>初创团队的产品展示</h2>


<p>『演讲团队之 “水果的牌子”Kivvi收银平板：时尚店主的第一台POS收银机。将收银系统和POS机完美结合，内置磁卡条、IC卡刷卡两种支付功能并预留NFC；简约一体的外观
设计为商户提供了宽敞的收银环境。商家可直接通过Kivvi编辑商品信息，完成现金和刷卡支付，查询交易记录销售报表@Gokivvi』（<a href="http://e.weibo.com/2863376813/Ai5lGCO99">微博</a>）。
『一个包含 硬件 互联网 金融 3个关键字的很炫的创业项目，赞一个~』（<a href="http://weibo.com/2704795533/Ai5lrfl11">微博</a>）。很好的一个创业点，也是这次产品展示中我最看好的项目之一。
</p>




<p>『演讲团队之 “数字时代让用户更爽”的九漫 交互式动态漫画：以自主研发的创新型交互式阅读引擎为依托，将静态的数字漫画改编成可交互的动态数字漫画。
九漫创新开发工具和完备的制作流程确保生产效率是传统2D动画的10倍以上，所以只需要不到1/10的成本，就可达到动画60%~70%的效果。[good]』
（<a href="http://e.weibo.com/2863376813/Ai5savoGs">微博</a>）。『交互式动态漫画，demo不错的样子，不过国内动漫2C的思路确实很难盈利，国外2B的
话还是有机会的~ 』（<a href="http://weibo.com/2704795533/Ai5tjFyA2">微博</a>）。
</p>




<p>『演讲团队之 要出发旅行网：针对都市白领、年轻一族，围绕周边自驾游，提供精品特价的度假产品。精选主流城市周边的优质“酒店+吃喝玩乐”搭配。
由旅行记者实地考察亲身体验，保证酒店品质及服务的高品质，也有特派摄影师实地拍照，专业设计团队制作文案，为用户提供齐全的游玩攻略。[给力]』
（<a href="http://e.weibo.com/2863376813/Ai5vNn0HA">微博</a>）。『周边自驾游，用DS能够接受的钱享受GFS般的服务，但是价格战不是小公司的致胜之道啊~』
（<a href="http://weibo.com/2704795533/Ai5yJFySh">微博</a>）。
</p>




<p>『演讲团队之 找大巴网——首创BO2O大巴招投标预订直销模式：专注打造大巴预订直销平台和最方便好用的大巴预订神器。托酒店管理公司平台，
找大巴网拥有自己的车队和百家合作车队。提供大巴供应商直销管理系统，方便大巴车队调度人员管理车辆库存，提高出租率，增加车队收入。[给力]』
（<a href="http://e.weibo.com/2863376813/Ai5CJ2FXd">微博</a>）。『大巴预定神奇，可以比价，有评论，审核系统。。。 』（<a href="http://weibo.com/2704795533/Ai5CMg2ss">微博</a>）。
大巴版快的打车，比较看好~
</p>




<p>『演讲团队之 微洽，做工作社交阶段的引领者——一款基于企业2.0理念设计的企业社交化工作平台。对企业而言，用全新的产品体验，改变工作沟通、
协作和分享方式，促进工作目标的达成；对个人而言，通过满足基于工作的社交需求，实现个人在工作和职业上的存在感。[可爱]』
（<a href="http://e.weibo.com/2863376813/Ai5Y4xKGG">微博</a>）。『企业社交，又一个有意思的垂直入口～』（<a href="http://weibo.com/2704795533/Ai5WKmJlY">微博</a>）。
企业版的微信，但推广有难度，2B or 2C，That&#8217;s a question。
</p>




<p>『演讲团队之 阿姨厨房，“寻找您身边的私房菜”——P2P模式的餐饮创业平台。阿姨厨房整合闲置的厨房、让有手艺的家庭从事餐饮服务，为周边的白领、
邻居提供私房菜。阿姨厨房建立标准化体系、整合物流、线上营销为创业者提供用户、物流服务。明天有没有糖醋小排？[花心]』
（<a href="http://e.weibo.com/2863376813/Ai61MpZuA">微博</a>）。『很有意思，但确实推广难度很大啊，不过吃货有福利了～』
（<a href="http://weibo.com/2704795533/Ai65YpONI">微博</a>）。感觉用户群的年龄偏大，确实不太好推广，从小区和菜市场入手进行推广，很不错的切入点。
</p>




<p>『演讲团队之 同船渡——帮你来一场说走就走的旅行。同船渡通过支持用户根据爱好、玩法、自定义路线等创造新的旅行点打造“旅游wiki”；并且提供功能让
用户根据自身需求邀约旅行，让熟悉创建旅行点数据的用户成为向导，实现旅游从Do It Yourself到Design It Yourself的改变。』
（<a href="http://e.weibo.com/2863376813/Ai66Jsc4f">微博</a>）。『信息量确实很大，节操掉了一地啊～』（<a href="http://weibo.com/2704795533/Ai66S0n1S">微博</a>）。

</p>




<p>PS: 这几个创业项目在36kr上都有过报道，可以参见 <a href="http://www.36kr.com/events/oday-201311-hz#posts_list">列表</a>.</br>
相关的PPT微盘资源如下：<a href="http://vdisk.weibo.com/u/2863376813?page=1">演讲PPT合集</a></p>




<h2>观众参与的开放演讲</h2>


<p>每个人1分钟的开放演讲很短，包括如下项目：画吧、快读、37 度、比比、氢学习、Omygod、Tipix—照片编辑App、配配、微信公众账号杭电助手、车纷享、穿戴式智能设备、享赢棋牌联盟、
爱扫货、微博书等，其中一些已经有成品发布，有些则还处于开发测试阶段。这其中以下几个项目已被36kr创业数据库收录或者被报道过：</br>
<a href="http://www.36kr.net/huaba">画吧</a></br>
<a href="http://www.36kr.net/kuaiduyueduqi">快读</a></br>
<a href="http://www.36kr.net/qingxuexi">氢学习</a></br>
<a href="http://www.36kr.net/Tipix">Tipix—照片编辑App</a></br>
<a href="http://www.36kr.net/peipei">配配</a></br>
<a href="http://www.36kr.net/chefenxiang">车纷享</a></br>
可以点击以上链接获得这些项目更加详细的信息。
</p>




<p>后记：第一次参加这样高大上的创业分享盛会，还是挺激动的，非常感谢@36氪 和 @36氪开放日。创业是一件很刺激、需要激情和果敢的事，也是一件需要理性、需要毅力的事。
创业是一种追求，一种价值观，一种生活方式。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[互联网公司为什么都在玩硬件？]]></title>
    <link href="http://ibillxia.github.io/blog/2013/10/30/why-web-companies-all-are-beginning-to-play-hardware-products/"/>
    <updated>2013-10-30T21:07:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/10/30/why-web-companies-all-are-beginning-to-play-hardware-products</id>
    <content type="html"><![CDATA[<p>昨天360高调推出安全手环，延续着去年以来互联网公司进军硬件行业的风气。小米手机一炮而红后，互联网公司纷纷进军手机硬件行业，
百度、阿里、盛大、360等等都推出了自己的定制手机，不过巨头们发现原来硬件并没有想象中那般好玩。但不好玩也得玩，你不玩别人也
会玩。</p>




<center><img src="http://ibillxia.github.io/images/2013/IMAG2013103001.jpeg"></center>




<p>但今年，巨头们不玩手机了，改玩其他了，有的是自己独立生产，有的是与厂家合作，内嵌自己的服务。这其中的玩家包括百度、360、小米、盛大、乐视等。</p>




<!--more-->


<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;分割线&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>


<p><strong>先不妨梳理一下巨头们都推出了哪些硬件.</strong></p>


<h4>1、百度</h4>


<p>咕咚手环：一款健康设备，用于检测运动和睡眠信息，了解在自身的健康状况。</br>
inWatch智能腕表：提供时间、音乐、上网、拨打电话等功能，与智能手机无异。</br>
小度WiFi：一个简易的WiFi共享装置。</br>
小度路由，小度影棒：即将推出，都是网络看片用的。</p>


<h4>2、腾讯</h4>


<p>Q影：是一款口袋式的互动投影，可以在几乎任何你需要的场景中使用，任何一个平面，Q影都可以投影能够触控的画面，让任一平面瞬间变身触控Touch Pad。</br>
小Q机器人：小Q机器人（Qrobot）是智能互联网机器人产品，是中国科学院与腾讯公司重大战略合作项目。它能够通过语音指令等多维交互方式为用户提供新闻、
天气、音乐、股票、教育、娱乐、办公等资讯和服务应用。同时，Qrobot有丰富的应用平台，通过互联网即可下载更多的功能。</p>


<h4>3、360</h4>


<p>360随身WiFi：一个简易的WiFi共享设备。</br>
360安全手环：用户孩童的安全设备，更像一个GPS+对讲机的结合。</p>


<h4>4、盛大</h4>


<p>果壳手表（Geak Watch）：同样是智能手表，其独特之处是可以独立上网，功能更全面。</br>
果壳魔戒（Geak Ring）：提供解锁、传递个人信息等功能，功能比较杂糅，定位略显模糊。</p>


<h4>5、小米</h4>


<p>小米盒子和小米电视，就不在此赘述了，大家应该比我了解。</p>


<h4>6、乐视</h4>


<p>乐视盒子和乐视电视，同样不再赘述。</p>


<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;分割线&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>




<p><strong>互联网巨头们推出的硬件看似杂乱无章，其实不外乎以下几种类型：</strong></p>


<h4>1、独立的可穿戴设备</h4>


<p>顺应国外可穿戴设备的潮流，可与人体或衣物整合的互联网设备，利用人体的行为与设备产生交互。</br>
代表：百度咕咚手环，360安全手环，盛大果壳手表</p>


<h4>2、创新性的配件</h4>


<p>作为传统的硬件或传统的互联网服务的配件存在，更多的是微创新，起到细节优化的作用</br>
代表：小米盒子，小度WiFi，360随身WiFi</p>


<h4>3、传统的大众家电等</h4>


<p>互联网企业进军传统家电绝不只是贴一个自己Logo就完事儿了，而是在其中增加更多满足用户需求的互联网因素</br>
代表：小米电视，乐视TV</p>


<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;分割线&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>




<p><strong>那么互联网企业进入硬件行业的目的是什么呢？</strong></p>


<h4>1、抢占入口</h4>


<p>这也是行业普遍的观点，互联网公司进军硬件行业是为了给自己的互联网服务找更多的入口。在当下，互联网服务同质化非常严重，很难在内容上吸引到更多的用户，所以互联网企业只能在渠道入口上下功夫。</p>


<p>PC上，浏览器和网址导航是入口，而用户已经在逃离PC，不仅手机，更多的电子设备以及接入了互联网，包括平板电脑、电子书等，这些设备不仅分流了用户的上网时间，
一定程度上也形成了新的入口。所以巨头的战略就是通过硬件切入，抢占入口，输出自己的互联网服务，获取利益。</p>


<p>举个例子，假设用户想看视频。在传统PC端，用户会习惯性地打开优酷土豆搜索或者去百度搜索（很可能被导入到爱奇艺或者PPS），这样优酷土豆和百度就是个强劲的入口；
在移动端，用户可能会选取App Store、豌豆荚、360手机助手、91助手或者其他应用商店下，这样控制应用分发的百度和360 很可能强推自己的百度视频（以及爱奇艺和PPS的移动APP）和360视频搜索。</p>


<p>而PC和移动端都无法满足你看视频的需求，假设你购买了小度影棒或者乐视盒子，高清大屏，更好的用户体验吸引了你，这时你浏览的视频一定来自于百度系爱奇艺、PPS或者乐视网的内容，这也就是硬件的价值所在。</p>




<h4>2、再造新的入口</h4>


<p>一切都在互联网化，人与互联网的界限也在逐渐变得模糊，在不断互联网化的过程中我们总会挖掘更多地需求，这种需求可能是原来就有的，现在只是把其互联网化了；
也可能是原来没有的，现在借用互联网将其挖掘了出来。很多互联网公司涉足这样的硬件可能并不是推广自己的服务，因为其本身的服务并不一定契合硬件产品功能，
其目的是提前布局，或许用户，建立新的互联网服务，再造一个入口，而不是抢夺原来的入口。</p>


<p>就拿昨天推出的360安全手环举例。儿童安全这个市场一定有不少产品了，但周鸿祎让这个市场及产品互联网化了。除了网络上的新闻报道，笔者对这款产品的细节及后续的更新还不是很了解，
但我认为360此举肯定不是为了推广自己的互联网服务，内置个360杀毒未免太low了吧。</p>


<p>这款产品自身在通话、录音、定位等方面有着广泛的互联网需求，而这些需求一旦被接受，就会带来价值，这才是很多互联网公司推出硬件的目的，开辟一款处女地，再重新开荒耕耘。</p>




<h4>3、获取数据</h4>


<p>很多互联网公司已经获取到足够多的数据了，但对于数据永远是嫌少不嫌多的，更何况，可穿戴设备下的数据是不同于传统的网络浏览数据的，可穿戴设备下的数据由于在交互上离人的真实更接近，
这样的数据其实更立体直观、更接近现实，也就更有价值。</p>


<p>举个例子，假设你用百度或者微博搜索一些关于运动健康的关键词，通过一定的数据处理分析，可能你以后会在百度右侧广告栏或者微博推广橱窗中看到运动健康相关的广告，
这就是一个简单的大数据分析，但这样的分析大部分情况下是不准确的。而假设你用了百度的咕咚手环，它有效记录了你的睡眠和运动情况，这样分析的结果可能更接近真实，
由于你用了同一个账户体系，以后再使用百度的时候，推广的广告可能就精准了。</p>


<p>我再做一个猜测，假如这个手环通过分析你的心跳、血液循环流动监测到了你潜在的疾病，并提醒了你，是不是这样的数据更有价值？因为这个手环离你更近，不只是空间上，
更是生理心理上。所以，可穿戴设备的数据的价值不在于更多，而在于更精确。</p>




<h4>4、硬件盈利</h4>


<p>好吧，笔者开了个玩笑。Kindle都在赔钱卖吆喝，当下用硬件盈利未免太反科学了。而周鸿祎也已经预言未来是一个硬件免费的时代，笔者希望那一天快点到来吧。</p>


<p>互联网企业进军硬件已经成为大势所趋，而进军硬件只是表象，本质原因是因为随着互联网的全面普及和深化，我们需要更多的新设备来连接或者呈现新的功能，所以就有了这一波硬件的潮流，
这有点像电灯、电话、电视那个百花齐放的时代，对应的是电的利用。</p>


<p>所以，在去年一股脑扎进手机圈后，今年互联网巨头对硬件制造更加理性了，推出的产品也更有市场针对性和前瞻性。这些硬件产品或是互联网企业传统服务的入口，
或是承担试水新领域的任务，或是大数据采集的深化，或是几者叠加重合。总之，对于硬件，我是不嫌多的。</p>




<p>转载自钛媒体：<a href="http://www.tmtpost.com/74476.html">互联网公司为什么都在玩硬件？</a>， 有删改。</p>


<p>知乎相关问答：</br>
[1] <a href="http://www.zhihu.com/question/21337805">2013年国内有哪些互联网公司在做硬件？</a></br>
[2] <a href="http://www.zhihu.com/question/21661422">怎么看待现在国内互联网公司纷纷开始发力硬件产品？</a>
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux的OSS和ALSA声音系统简介及其比较]]></title>
    <link href="http://ibillxia.github.io/blog/2013/09/08/brief-introduction-of-alsa-and-oss-and-its-comparision/"/>
    <updated>2013-09-08T19:46:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/09/08/brief-introduction-of-alsa-and-oss-and-its-comparision</id>
    <content type="html"><![CDATA[<h2>概述</h2>


<p>昨天想在Ubuntu上用一下HTK工具包来绘制语音信号的频谱图和提取MFCC的结果，但由于前段时间把Ubuntu升级到13.04，系统的声卡驱动
是ALSA（Advanced Linux Sound Architecture，高级Linux声音体系），而不是HTK中所使用的OSS（Open Sound System，开放声音系统）。
网上查阅了大半天，按照 http://forum.ubuntu.org.cn/viewtopic.php?t=316792 中提供的方法用OSS4来替换ALSA，结果OSS4没替换成功，
而原来的ALSA也不好使了，真坑爹啊！到现在还没办法完全复原，现在只能通过alsamixer来设置音量了，系统的音量设置根本无法用，而且
声音设置中的输入设备和输出设备都是空的。（现在将系统升级到13.10版，系统的音量设置可以用了，哈哈）捣鼓了半天也没还原回来唉，
整个人都快崩溃了，都是由于对Linux不熟悉才被虐至如此地步，得恶补啊！！！下面本文就主要介绍一下OSS和ALSA，并将二者进行比较。</p>




<p>在介绍OSS和ALSA之前，先介绍一下音频设备的一些基础知识。</br>
数字音频设备，有时也称codec，PCM，DSP，ADC/DAC设备，用来播放或录制数字化的声音。它的指标主要有：采样速率（电话为8K，DVD为96K）、
channel数目（单声道，立体声）、采样分辨率（8-bit，16-bit）等。</br>
mixer（混频器）：用来控制多个输入、输出的音量，也控制输入（microphone，line-in，CD）之间的切换。</br>
synthesizer（合成器）：通过一些预先定义好的波形来合成声音，有时用在游戏中声音效果的产生。</br>
MIDI接口：MIDI接口是为了连接舞台上的synthesizer、键盘、道具、灯光控制器的一种串行接口。</p>




<!--more-->




<h2>OSS开放声音系统简介</h2>


<p>Open Sound System是一个类Unix和POSIX兼容系统上一个可选的声音架构。OSSv3是Linux下原始的声音系统并集成在内核里，但是OSSv4
在2002年OSS成为商业软件时它地位被ALSA所取代。OSSv4在2007年又成为了开源软件，4Front Technologies以GPL协议发布了它的源码。</p>




<p>OSS（Open Sound System）是unix平台上一个统一的音频接口。以前，每个Unix厂商都会提供一个自己专有的API，用来处理音频。这就
意味着为一种Unix平台编写的音频处理应用程序，在移植到另外一种Unix平台上时，必须要重写。不仅如此，在一种平台上具备的功能，
可能在另外一个平台上无法实现。但是，OSS出现以后情况就大不一样了，只要音频处理应用程序按照OSS的API来编写，那么在移植到另外
一个平台时，只需要重新编译即可。因此，OSS提供了源代码级的可移植性。</p>




<p>同时，很多的Unix工作站中，只能提供录音与放音的功能。有了OSS后，给这些工作站带来了MIDI功能，加上音频流、语音识别/生成、
计算机电话（CT）、JAVA以及其它的多媒体技术，在Unix工作站中，同样可以享受到同Windows、Macintosh环境一样的音频世界。另外，
OSS还提供了与视频和动画播放同步的音频能力，这对在Unix中实现动画、游戏提供了帮助。</p>




<p>在Unix系统中，所有的设备都被统一成文件，通过对文件的访问方式（首先open，然后read/write，同时可以使用ioctl读取/设置参数，
最后close）来访问设备.在OSS中，主要有以下的几种设备文件：</br>
/dev/mixer：访问声卡中内置的mixer，调整音量大小，选择音源。</br>
/dev/sndstat：测试声卡，执行cat /dev/sndstat会显示声卡驱动的信息。</br>
/dev/dsp、/dev/dspW、/dev/audio：读这个设备就相当于录音，写这个设备就相当于放音。/dev/dsp与/dev/audio之间的区别在于采样的编码
不同，/dev/audio使用μ律编码，/dev/dsp使用8-bit（无符号）线性编码，/dev/dspW使用16-bit（有符号）线形编码。/dev/audio主要是为了
与SunOS兼容，所以尽量不要使用。</br>
/dev/sequencer：访问声卡内置的，或者连接在MIDI接口的synthesizer。</p>




<p>OSS为音频编程提供三种设备，分别是/dev/dsp，/dev/dspW和/dev/audio，用户可以直接使用Unix的命令来放音和录音，命令cat /dev/dsp >xyz
可用来录音，录音的结果放在xyz文件中；命令cat xyz >/dev/dsp播放声音文件xyz。如果通过编程的方式来使用这些设备，那么Unix平台通过
文件系统提供了统一的访问接口。程序员可以通过文件的操作函数直接控制这些设备，这些操作函数包括：open、close、read、write、ioctl等。</p>




<h2>ALSA高级Linux声音系统简介</h2>


<p>高级Linux声音体系（英语：Advanced Linux Sound Architecture，缩写为ALSA）是Linux内核中，为声卡提供的驱动组件，以替代原先的
OSS（开放声音系统）。一部分的目的是支持声卡的自动配置，以及完美的处理系统中的多个声音设备，这些目的大多都已达到。另一个声音
框架JACK使用ALSA提供低延迟的专业级音频编辑和混音能力。</p>




<p>这个项目开始于为1998年Gravis Ultrasound所开发的驱动，它一直作为一个单独的软件包开发，直到2002年他被引进入Linux内核的开发
版本(2.5.4-2.5.5)。从2.6版本开始ALSA成为Linux内核中默认的标准音频驱动程序集，OSS则被标记为废弃。</p>




<p>ALSA由许多声卡的声卡驱动程序组成，同时它也提供一个称为libasound的API库。应用程序开发者应该使用libasound而不是内核中的ALSA接口。
因为libasound提供最高级并且编程方便的编程接口。并且提供一个设备逻辑命名功能，这样开发者甚至不需要知道类似设备文件这样的低层接口。
相反，OSS/Free驱动是在内核系统调用级上编程，它要求开发者提供设备文件名并且利用ioctrl来实现相应的功能。为了向后兼容，ALSA提供内核
模块来模拟OSS，这样之前的许多在OSS基础上开发的应用程序不需要任何改动就可以在ALSA上运行。另外，libaoss库也可以模拟OSS，而它不需要
内核模块。另外，ALSA还包含插件功能，使用插件可以扩展新的声卡驱动，包括完全用软件实现的虚拟声卡。ALSA提供一系列基于命令行的工具集，
比如混音器(mixer)，音频文件播放器(aplay)，以及控制特定声卡特定属性的工具。</p>




<p>ALSA API主要分为以下几种接口：</br>
控制接口：提供灵活的方式管理注册的声卡和对存在的声卡进行查询。</br>
PCM接口：提供管理数字音频的捕捉和回放。</br>
原始MIDI接口: 支持 MIDI (Musical Instrument Digital Interface)，一种标准电子音乐指令集。这些API提供访问声卡上的MIDI总线。
这些原始借口直接工作在 The MIDI事件上，程序员只需要管理协议和时间。</br>
记时接口: 为支持声音的同步事件提供访问声卡上的定时器。</br>
音序器接口：一个比原始MIDI接口高级的MIDI编程和声音同步高层接口。它可以处理很多的MIDI协议和定时器。</br>
混音器接口：控制发送信号和控制声音大小的声卡上的设备。</p>




<p>API库使用逻辑设备名而不是设备文件。设备名字可以是真实的硬件名字也可以是插件名字。硬件名字使用hw:i,j这样的格式。其中i是卡号，
j是这块声卡上的设备号。第一个声音设备是hw:0,0.这个别名默认引用第一块声音设备并且在本文示例中一真会被用到。插件使用另外的唯一名字。
比如plughw:,表示一个插件，这个插件不提供对硬件设备的访问，而是提供像采样率转换这样的软件特性，硬件本身并不支持这样的特性。</p>




<h2>OSS与ALSA的优缺点比较</h2>


<p>ALSA是一个完全开放源代码的音频驱动程序集，除了像OSS那样提供了一组内核驱动程序模块之外，ALSA还专门为简化应用程序的编写提供了
相应的函数库，与OSS提供的基于ioctl的原始编程接口相比，ALSA函数库使用起来要更加方便一些。利用该函数库，开发人员可以方便快捷的
开发出自己的应用程序，细节则留给函数库内部处理。当然ALSA也提供了类似于OSS的系统接口，不过ALSA的开发者建议应用程序开发者使用
音频函数库而不是驱动程序的API。Ubuntu默认使用ALSA作为底层声音驱动，程序则与PulseAudio交互，这是一个很不错的方案。</p>




<p>下面来比较一下OSS和ALSA的优缺点：</br>
<strong>(1)OSS的优点（对用户来说）</strong></br>
在内核空间（kernel space）里面包含了一个透明软件混音器(vmix)。这样多个程序就可以同时使用声音设备而且没有任何问题。</br>
这个混音器可以让你单独调节各个程序的音量。</br>
对某些老声卡有着更好的支持比如创新（Creative）的X-Fi。</br>
声音程序的初始反应时间一般更好。</br>
对使用OSS的应用程序接口（API）的程序有更好的支持，很多程序都支持OSS的API，而不需要ALSA的模拟。</br>

<strong>(2)OSS的优点（对开发者来说）</strong></br>
清晰的API文档，更易于使用。</br>
支持用户空间的声音驱动。</br>
可移植性强，OSS也可以在BSDs和Solaris下运行。</br>
本身可以跨平台，可以更方便移植到新的操作系统。</br>

<strong>(3)ALSA的优点</strong></br>
ALSA对USB音频设备支持更好，而OSS的输出还在试验中，输入还未实现。</br>
ALSA支持蓝牙声音设备。</br>
ALSA支持AC&#8217;97和HDAudio dial-up soft-modems (比如Si3055)。</br>
ALSA对MIDI支持得更好，但用OSS你只能通过软件合成器（如timidity和fluidsynth）来使用MIDI。</br>
ALSA对待机支持更好，而用OSS，你需要在待机前使用soundoff来停止OSS驱动，在恢复后使用soundon来启动OSS。</br>
OSS的jack检测目前在某些HDAudio-powered主板上不能正常工作。也就是说在某些型号的主板上，你可能需要在插入耳机的
时候手动关闭外置扬声器。而ALSA没这个问题。
</p>




<h2>参考资料</h2>


<p>[1]Archlinux上介绍OSS的Wiki：https://wiki.archlinux.org/index.php/OSS_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29 </br>
[2]Archlinux上介绍ALSA的Wiki：https://wiki.archlinux.org/index.php/Advanced_Linux_Sound_Architecture_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) </br>
[3]OSS&#8211;跨平台的音频接口简介: http://www.ibm.com/developerworks/cn/linux/l-ossapi/ </br>
[4]Linux ALSA声卡驱动之一：ALSA架构简介: http://blog.csdn.net/droidphone/article/details/6271122 </br>
[5]Linux ALSA声卡编程简介: http://enmind.blog.163.com/blog/static/164138001201092334620355/</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PCM WAVE格式详解及用C语言实现wave文件的读取]]></title>
    <link href="http://ibillxia.github.io/blog/2013/07/20/details-of-wave-format-and-reading-wave-files-in-C-language/"/>
    <updated>2013-07-20T20:07:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/07/20/details-of-wave-format-and-reading-wave-files-in-C-language</id>
    <content type="html"><![CDATA[<h2>1.PCM Wave格式详解</h2>


<p>WAVE文件格式是微软RIFF(Resource Interchange File Format,资源交换文件标准)的一种，是针对于多媒体文件存储的一种文件格式和标准。
一般而言，RIFF文件由文件头和数据两部分组成，一个WAVE文件由一个“WAVE”数据块组成，这个“WAVE”块又由一个&#8221;fmt&#8221;子数据块和一个“data”子
数据块组成，也称这种格式为“Canonical form”（权威/牧师格式），如下图所示：
<center><img src="http://ibillxia.github.io/images/2013/IMAG2013072001.gif"></center>
</p>


<!--more-->


<p>每个字段的涵义如下：
ChunkID: 占4个字节，内容为“RIFF”的ASCII码(0x52494646)，以大端（big endian）存储。</br>
ChunkSize: 4字节，存储整个文件的字节数（不包含ChunkID和ChunkSize这8个字节），以小端（little endian）方式存储。</br>
Format: 4字节，内容为“WAVE”的ASCII码(0x57415645)，以大端存储。</br>
</p>




<p>
其中bigendian 主要有一个特征，在内存中对操作数的存储方式和从高字节到低字节。例如：0x1234，这样一个数，存储为:</br>
0x4000:   0x12</br>
0x4001:   0x34</br>
而小尾端littleendian是：</br>
0x4000:   0x34</br>
0x4001:   0x12</br>
用程序在区别的话，可以考虑：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h>
</span><span class='line'>#include &lt;stdlib.h>
</span><span class='line'>int main(int argc, char *argv[])
</span><span class='line'>{
</span><span class='line'>       union w
</span><span class='line'>      {
</span><span class='line'>       short int a;
</span><span class='line'>       char b;
</span><span class='line'>      }c;
</span><span class='line'>      c.a=1;
</span><span class='line'>      if( c.b==1 )  printf("little endian\n");
</span><span class='line'>      else printf("big endian\n");
</span><span class='line'>      system("PAUSE"); 
</span><span class='line'>      return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

</p>




<p>&#8220;WAVE&#8221;格式由两个子数据块构成：“fmt”块和“data”块，其中“fmt”块的详细解释如下：
Subchunk1ID: 占4个字节，内容为“fmt ”的ASCII码(0x666d7420)，以大端存储。</br>
Subchunk1Size: 占4个字节，存储该子块的字节数（不含前面的Subchunk1ID和Subchunk1Size这8个字节），以小端方式存储。</br>
AudioFormat：占2个字节，以小端方式存储，存储音频文件的编码格式，例如若为PCM则其存储值为1，若为其他非PCM格式的则有一定的压缩。</br>
NumChannels: 占2个字节，以小端方式存储，通道数，单通道(Mono)值为1，双通道(Stereo)值为2，等等。</br>
SampleRate: 占4个字节，以小端方式存储，采样率，如8k，44.1k等。</br>
ByteRate: 占4个字节，以小端方式存储，每秒存储的bit数，其值=SampleRate * NumChannels * BitsPerSample/8</br>
BlockAlign: 占2个字节，以小端方式存储，块对齐大小，其值=NumChannels * BitsPerSample/8</br>
BitsPerSample: 占2个字节，以小端方式存储，每个采样点的bit数，一般为8,16,32等。</br>
接下来是两个可选的扩展参数：</br>
ExtraParamSize: 占2个字节，表示扩展段的大小。</br>
ExtraParams: 扩展段其他自定义的一些参数的具体内容，大小由前一个字段给定。
</p>




<p>其中，对于每个采样点的bit数，不同的bit数读取数据的方式不同：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// data 为读取到的采样点的值，speech为原始数据流，
</span><span class='line'>//对应于下面的"WAVE"格式文件的第二个子数据块“data”块的“Data”部分。
</span><span class='line'>for(i=0;i&lt;NumSample;i++){
</span><span class='line'>  if(BitsPerSample==8)
</span><span class='line'>      data[i] = (int)*((char*)speech+i);
</span><span class='line'>  else if(BitsPerSample==16)
</span><span class='line'>      data[i] = (int)*((short*)speech+i);
</span><span class='line'>  else if(BitsPerSample==32)
</span><span class='line'>      data[i] = (int)*((int*)speech+i);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

</p>




<p>&#8220;WAVE&#8221;格式文件的第二个子数据块是“data”，其个字段的详细解释如下：</br>
Subchunk2ID: 占4个字节，内容为“data”的ASCII码(0x64617461)，以大端存储。</br>
Subchunk2Size: 占4个字节，内容为接下来的正式的数据部分的字节数，其值=NumSamples * NumChannels * BitsPerSample/8</br>
Data: 真正的语音数据部分。</br>
</p>




<h2>一个Wave文件头的实例</h2>


<p>设一个wave文件的前72个字节的十六进制内容如下(可以使用Ultra Edit等工具查看wave文件头)：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>52 49 46 46 24 08 00 00 57 41 56 45 66 6d 74 20 10 00 00 00 01 00 02 00 
</span><span class='line'>22 56 00 00 88 58 01 00 04 00 10 00 64 61 74 61 00 08 00 00 00 00 00 00 
</span><span class='line'>24 17 1e f3 3c 13 3c 14 16 f9 18 f9 34 e7 23 a6 3c f2 24 f2 11 ce 1a 0d</span></code></pre></td></tr></table></div></figure>

则其个字段的解析如下图：
<center><img src="http://ibillxia.github.io/images/2013/IMAG2013072002.gif"></center>
</p>




<h2>C语言实现wave文件的读取</h2>


<p>这里给出一个用基本的C语言文件操作库函数实现的Wave文件读取的实例代码，可以跨Windows和Linux平台。</p>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h>
</span><span class='line'>#include &lt;stdlib.h>
</span><span class='line'>#include &lt;string.h>
</span><span class='line'>
</span><span class='line'>// define Wave format structure
</span><span class='line'>typedef struct tWAVEFORMATEX
</span><span class='line'>{
</span><span class='line'>    short wFormatTag;         /* format type */
</span><span class='line'>    short nChannels;          /* number of channels (i.e. mono, stereo...) */
</span><span class='line'>    unsigned int nSamplesPerSec;     /* sample rate */
</span><span class='line'>    unsigned int nAvgBytesPerSec;    /* for buffer estimation */
</span><span class='line'>    short nBlockAlign;        /* block size of data */
</span><span class='line'>    short wBitsPerSample;     /* number of bits per sample of mono data */
</span><span class='line'>    short cbSize;             /* the count in bytes of the size of */
</span><span class='line'>                                    /* extra information (after cbSize) */
</span><span class='line'>} WAVEFORMATEX, *PWAVEFORMATEX;
</span><span class='line'>
</span><span class='line'>char* wavread(char *fname, WAVEFORMATEX *wf);
</span><span class='line'>
</span><span class='line'>int main(){
</span><span class='line'>  char fname = "test.wav";
</span><span class='line'>  char *speech;
</span><span class='line'>  WAVEFORMATEX wf;
</span><span class='line'>  
</span><span class='line'>  speech = wavread(fname, &wf);
</span><span class='line'>  // afterward processing...
</span><span class='line'>  
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// read wave file
</span><span class='line'>char* wavread(char *fname, WAVEFORMATEX *wf){
</span><span class='line'>  FILE* fp;
</span><span class='line'>  char str[32];
</span><span class='line'>  char *speech;
</span><span class='line'>  unsigned int subchunk1size; // head size
</span><span class='line'>  unsigned int subchunk2size; // speech data size
</span><span class='line'>
</span><span class='line'>  // check format type
</span><span class='line'>  fp = fopen(fname,"r");
</span><span class='line'>  if(!fp){
</span><span class='line'>      fprintf(stderr,"Can not open the wave file: %s.\n",fname);
</span><span class='line'>      return NULL;
</span><span class='line'>  }
</span><span class='line'>  fseek(fp, 8, SEEK_SET);
</span><span class='line'>  fread(str, sizeof(char), 7, fp);
</span><span class='line'>  str[7] = '\0';
</span><span class='line'>  if(strcmp(str,"WAVEfmt")){
</span><span class='line'>      fprintf(stderr,"The file is not in WAVE format!\n");
</span><span class='line'>      return NULL;
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  // read format header
</span><span class='line'>  fseek(fp, 16, SEEK_SET);
</span><span class='line'>  fread((unsigned int*)(&subchunk1size),4,1,fp);
</span><span class='line'>  fseek(fp, 20, SEEK_SET);
</span><span class='line'>  fread(wf, subchunk1size, 1, fp);
</span><span class='line'>  
</span><span class='line'>  // read wave data
</span><span class='line'>  fseek(fp, 20+subchunk1size, SEEK_SET);
</span><span class='line'>  fread(str, 1, 4, fp);
</span><span class='line'>  str[4] = '\0';
</span><span class='line'>  if(strcmp(str,"data")){
</span><span class='line'>      fprintf(stderr,"Locating data start point failed!\n");
</span><span class='line'>      return NULL;
</span><span class='line'>  }
</span><span class='line'>  fseek(fp, 20+subchunk1size+4, SEEK_SET);
</span><span class='line'>  fread((unsigned int*)(&subchunk2size), 4, 1, fp);
</span><span class='line'>  speech = (char*)malloc(sizeof(char)*subchunk2size);
</span><span class='line'>  if(!speech){
</span><span class='line'>      fprintf(stderr, "Memory alloc failed!\n");
</span><span class='line'>      return NULL;
</span><span class='line'>  }
</span><span class='line'>  fseek(fp, 20+subchunk1size+8, SEEK_SET);
</span><span class='line'>  fread(speech, 1, subchunk2size, fp);
</span><span class='line'>
</span><span class='line'>  fclose(fp);
</span><span class='line'>  return speech;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<h2>参考</h2>


<p>
[1]WAVE PCM soundfile format: https://ccrma.stanford.edu/courses/422/projects/WaveFormat/ </br>
[2]Resource Interchange File Format: http://en.wikipedia.org/wiki/Resource_Interchange_File_Format </br>
[3]基于Visual C++6.0的声音文件操作: http://www.yesky.com/20030414/1663116_1.shtml
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给Octpress博客添加返回顶部按钮]]></title>
    <link href="http://ibillxia.github.io/blog/2013/06/30/add-a-back-to-top-button-on-ur-octpress-blog/"/>
    <updated>2013-06-30T10:47:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/06/30/add-a-back-to-top-button-on-ur-octpress-blog</id>
    <content type="html"><![CDATA[<p>有时候，博客文章太长，需要返回顶部时，需要用鼠标拖着滚动条向上好半天，这里提供一个用jQuery来实现的动态上滚的示例。
这个示例完全参考和翻译自webdesignerwall的blog：<a href="http://webdesignerwall.com/tutorials/animated-scroll-to-top">http://webdesignerwall.com/tutorials/animated-scroll-to-top</a>，
其中有部分删改，并在本人的blog上实现。</p>




<p>主要包含HTML和CSS的设计，基于jQuery的JS的设计。另外还有一点小trick</p>




<h2>Design & CSS</h2>


<p>相关的HTML代码很简单，在source/_include/custom/footer.html中添加如下代码：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;p id = "back-top">
</span><span class='line'>      &lt;a href="#top">&lt;span>&lt;/span>Back to Top&lt;/a>
</span><span class='line'>  &lt;/p></span></code></pre></td></tr></table></div></figure>

</p>




<!--more-->




<p>对应的CSS样式的设置如下：（这段代码同样的放在source/_include/custom/footer.html文件中）

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;style type="text/css">
</span><span class='line'>#back-top {
</span><span class='line'>  position: fixed;
</span><span class='line'>  bottom: 50px;
</span><span class='line'>  right: 100px;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>#back-top a {
</span><span class='line'>  width: 80px;
</span><span class='line'>  display: block;
</span><span class='line'>  text-align: center;
</span><span class='line'>  font: 11px/100% Arial, Helvetica, sans-serif;
</span><span class='line'>  text-transform: uppercase;
</span><span class='line'>  text-decoration: none;
</span><span class='line'>  color: #bbb;
</span><span class='line'>
</span><span class='line'>  /* transition */
</span><span class='line'>  -webkit-transition: 1s;
</span><span class='line'>  -moz-transition: 1s;
</span><span class='line'>  transition: 1s;
</span><span class='line'>}
</span><span class='line'>#back-top a:hover {
</span><span class='line'>  color: #000;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* arrow icon (span tag) */
</span><span class='line'>#back-top span {
</span><span class='line'>  width: 80px;
</span><span class='line'>  height: 80px;
</span><span class='line'>  display: block;
</span><span class='line'>  margin-bottom: 7px;
</span><span class='line'>  background: #ddd url(../../images/up-arrow.png) no-repeat center center;
</span><span class='line'>
</span><span class='line'>  /* rounded corners */
</span><span class='line'>  -webkit-border-radius: 15px;
</span><span class='line'>  -moz-border-radius: 15px;
</span><span class='line'>  border-radius: 15px;
</span><span class='line'>
</span><span class='line'>  /* transition */
</span><span class='line'>  -webkit-transition: 1s;
</span><span class='line'>  -moz-transition: 1s;
</span><span class='line'>  transition: 1s;
</span><span class='line'>}
</span><span class='line'>/*
</span><span class='line'>#back-top a:hover span {
</span><span class='line'>  background-color: #888;
</span><span class='line'>}
</span><span class='line'>*/
</span><span class='line'>&lt;/style></span></code></pre></td></tr></table></div></figure>

</p>




<p>上面的css中用到了一张图片up-arrow.png，放在source/images/目录下，图片如下：
<center><img src="http://ibillxia.github.io/images/up-arrow.png"></center>
这是从google image里面随便找的一个，你也可以找一个自己喜欢的图片。
</p>




<h2>jQuery部分</h2>


<p>HTML和CSS样式设置好了之后，最后就是添加JavaScript事件响应代码了，这里是基于jQuery实现的。代码如下：（这段代码还是放在source/_include/custom/footer.html文件中）

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.3/jquery.min.js">&lt;/script>
</span><span class='line'>&lt;script type="text/javascript">
</span><span class='line'>$(document).ready(function(){
</span><span class='line'>
</span><span class='line'>  // hide #back-top first
</span><span class='line'>  $("#back-top").hide();
</span><span class='line'>  
</span><span class='line'>  // fade in #back-top
</span><span class='line'>  $(function () {
</span><span class='line'>      $(window).scroll(function () {
</span><span class='line'>          if ($(this).scrollTop() > 100) {
</span><span class='line'>              $('#back-top').fadeIn();
</span><span class='line'>          } else {
</span><span class='line'>              $('#back-top').fadeOut();
</span><span class='line'>          }
</span><span class='line'>      });
</span><span class='line'>
</span><span class='line'>      // scroll body to 0px on click
</span><span class='line'>      $('#back-top a').click(function () {
</span><span class='line'>          $('body,html').animate({
</span><span class='line'>              scrollTop: 0
</span><span class='line'>          }, 800);
</span><span class='line'>          return false;
</span><span class='line'>      });
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>});
</span><span class='line'>&lt;/script></span></code></pre></td></tr></table></div></figure>

</p>




<h2>一个Trick</h2>


<p>
在上面的HTML代码中，我们将一个链接添加到了ID为#top的里面，这个#top标签是<body>标签的ID，这样即使浏览器不支持相关的JS，
通过这个link也实现了返回顶部的功能。
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[蛙泳、自由泳、仰泳、蝶泳图解动画教你游泳]]></title>
    <link href="http://ibillxia.github.io/blog/2013/06/28/swimming-tutorial-with-gif-images/"/>
    <updated>2013-06-28T21:37:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/06/28/swimming-tutorial-with-gif-images</id>
    <content type="html"><![CDATA[<p>最近在室友的带领下，开始去cjl游泳馆学游泳，这里转载一篇游泳教程，分享给初学游泳的网友们</p>




<h2>蛙泳</h2>


<p>蛙泳配合有一个顺口溜，在讲解蛙泳动作要领之前先介绍给大家：“划手腿不动，收手再收腿，先伸胳膊后蹬腿，并拢伸直漂一会儿。”
从顺口溜中可以看到，手的动作是先于腿的动作。一定要在收手后再收腿，伸手后再蹬腿。</p>




<center><img src="http://ibillxia.github.io/images/2013/IMAG2013062801.gif"></center>




<p>臂部动作：</br>
1、外划。双手前伸，手掌倾斜大约45度(小拇指朝上)。双手同时向外、后方划，继而屈臂向后、向下方划。</br>
2、内划。掌心由外转向内，手带动小臂加速内划，手由下向上并在胸前并拢(手高肘低、肘在肩下)，前伸。</br>
3、前伸。双手向前伸(肘关节伸直)。要提醒大家注意的是：外划是放松的，内划是用力的、加速完成的、前伸是积极的。
</p>




<!--more-->




<center><img src="http://ibillxia.github.io/images/2013/IMAG2013062802.gif"></center>




<p>腿部动作：</br>
1、收腿：屈膝收腿，脚跟向臀部靠拢，小腿要躲在大腿后面慢收腿，这样可以减少阻力。收腿结束时，两膝与肩同宽，小腿与水面垂直，脚牚在水面附近。</br>
2、翻脚：两脚距离大于两膝距离，两脚外翻，脚尖朝外，脚牚朝天，小腿和脚内侧对准水，像英文字母“W”。</br>
3、夹蹬水：实际上是腿伸直的过程(屈髋、伸膝)，由腰腹和大腿同时发力，以小腿和脚内侧同时蹬夹水，先是向外、向后、向下，然后是向内、向上方蹬水，
就像画半个圆圈。向外蹬水和向内夹水是连续完成的，也就是连蹬带夹。蹬夹水完成时双腿并拢伸直，双脚内转，脚尖相对。蹬水的速度不要过猛，要由
慢到快地加速蹬水，两条腿将近伸直并拢的时候蹬水速度最快。</br>
4、停：双腿并拢伸直后在一个短暂的滑行(1-2秒)。
</p>




<center><img src="http://ibillxia.github.io/images/2013/IMAG2013062803.gif"></center>




<p>蛙泳的完整配合动作：双手外划时抬头换气，双手内划时收腿低头稍憋气，双手前伸过头时蹬腿吐气。</p>




<h2>自由泳</h2>


<p>游泳是全身运动，任何一个部位的活动都离不开全身的协调配合。从表面上看，自由泳依靠划水和打腿产生推进力，实际上，躯干的作用也不能忽视。首先，
躯干应保持一定的紧张度，腰部如果松软，整个人就像一摊泥一样。其次，身体的转动能够有效地发挥躯干部大肌肉群的力量，减少阻力，提高工作效果。</p>




<p>自由泳的完整配合有多种形式。一般常见的是每划水2次，打水6次，呼吸1次。</p>




<center><img src="http://ibillxia.github.io/images/2013/IMAG2013062804.gif"></center>




<p>1、手的入水点在肩的延长线和身体中线之间，以大拇指领先，斜插入水。</br>
2、入水后，手、肘、肩继续前伸，使手臂伸展。随着身体的转动，屈腕、屈肘，手臂向外、后方抓水;手下划到最低点后，旋转手臂向内、上、后方划水，
保持高肘屈臂的划水姿势。</br>
3、手臂与水平面垂直时，经手领先，加速推水，手臂转为向外、向上和身后划水直到大腿侧，提肘出水。</br>
4、出水后，手臂自然、放松地经空中向前移臂，保持高肘姿势。然后手在肩前领先入水，开始下一个动作。
</p>




<center><img src="http://ibillxia.github.io/images/2013/IMAG2013062805.gif"></center>




<p>1、手臂在水下成曲线划水路线，从侧面看，手相对于身体的划水轨迹为“S”形。</br>
2、自由泳两臂配合有前交叉配合、中交叉配合、和后交叉配合3种基本形式。本图为前交叉形式，为初学者比较容易掌握的方式。
</p>


<center><img src="http://ibillxia.github.io/images/2013/IMAG2013062806.gif"></center>




<p>单臂打水划臂动作是初学者应该重点练习的动作。如此图，左臂划水，那么可以右臂扶板。一般腿打水10次左右，手臂划水一次。
掌握到一定程度的时候可以加上呼吸练习。</p>




<p>腿部鞭状打水：</br>
1、打腿动作从髋部开始发力，大腿带动小腿，做鞭状打水动作。</br>
2、向上打水腿从直到弯。以直腿开始向上打，脚接近水面时屈膝，小腿上抬，使脚牚露出水面后向下打水。开始可直腿打水，但腿略放松，不要僵硬，
在水的压力下腿会自然弯曲。向下打水前膝关节弯曲角度约130-160度，打水幅度约为30-40厘米。打水时要绷脚(芭蕾脚)，不要勾脚。
</p>




<h2>仰泳</h2>


<p>1、臂划水时，出水以大拇指领先，移臂时手臂与水面垂直，上臂贴近耳朵。移臂过程中手臂旋转，入水时小拇指领先插入水中。</br>
2、如果以头的位置为钟表12点，两手的入水点在11点和1点的位置。手入水后先直臂下划。</br>
3、两臂划水应与身体转动协调配合，两肩不断形成位置差。</br>
4、两臂划水配合采用中交叉方式，即两臂始终处于相反的位置，一臂划水时，另一臂移臂。</br>
5、头部保持稳定没有左右摆动。
</p>




<center><img src="http://ibillxia.github.io/images/2013/IMAG2013062807.gif"></center>




<p>1、呼吸虽然不受限制，但最好采用有节奏的呼吸方式，或以固定在一臂移臂时吸气。毕竟划水以及身体在水中行进时会有波浪及水花。随意呼吸易呛水。</br>
2、保持水平的身体姿势，躯干和肩随手臂动作围绕纵轴转动，始终有一肩不露出水面。</br>
3、一般每划水2次，腿打水6次，呼吸1次。</br>
4、两腿交替做鞭状上下打水。向上打水要快而有力，脚略内旋并绷直，向下打水时腿和脚自然放松。
</p>




<center><img src="http://ibillxia.github.io/images/2013/IMAG2013062808.gif"></center>




<p>1、移臂时手臂紧贴身体不能太宽。</br>
2、移臂时如果手臂易弯曲，则可暂时用小拇指领先出水，养成直臂出水的习惯以后再用大拇指领先出水。</br>
3、身体始终保持伸展、正直、几乎水平地仰卧于水面，好像平躺在床上，头下有一只矮枕头。
</p>




<center><img src="http://ibillxia.github.io/images/2013/IMAG2013062809.gif"></center>




<p>建议：仰泳腿要体会大腿用力，上抬与下压都要有，体会大腿带动小腿的感觉。</p>




<h2>蝶泳</h2>


<center><img src="http://ibillxia.github.io/images/2013/IMAG2013062810.gif"></center>


<p>1、蝶泳的手入水点在两肩的延长线上，以大拇指领先，斜插入水。</br>
2、入水后，肩、肘前伸，两手沿曲线向外、后、下方抓水。两手分开到肩宽时，屈肘，加速划水。</br>
3、两手分开到达到最大宽度后，手臂转为向内、向上和向后划水，手臂上抬时保持高肘屈臂。两手在胸下或腹下时，手之间的距离最近。</br>
4、呼吸与划水的配合也是蝶泳技术的关键。手臂结束向内划水时，头露出水面吸气，移臂时头还原入水。记住两个“之前”，即头在手出水前出水，在手入水前入水。
</p>




<center><img src="http://ibillxia.github.io/images/2013/IMAG2013062811.gif"></center>




<p>1、蝶泳双手划水两手距离接近最近时，手臂划水的方向再一次改变，转为向外、向上和向后划水，直至出水。</br>
2、划水出水后，手臂在肩的带动下经空中向前移臂，准备入水、移臂一般以低、平、放松的姿势从两侧前移。</br>
3、蝶泳的身体姿势掌握比较难，同时鞭状打水也不易掌握。在蝶泳学习的时候，我们会有专门的分解练习让您逐步掌握运作。
</p>




<center><img src="http://ibillxia.github.io/images/2013/IMAG2013062812.gif"></center>




<p>1、蝶泳的划水路线一般为“钥匙孔”形，指两手在胸下或腹下时的距离最近，这种前后划水路线比较均匀。</br>
2、注意蝶泳的四肢动作是双臂、双腿同时协调发力。
</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Windows API实现一个简单的录音程序]]></title>
    <link href="http://ibillxia.github.io/blog/2013/06/04/a-simple-code-for-wave-recording-using-windows-api/"/>
    <updated>2013-06-04T23:59:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/06/04/a-simple-code-for-wave-recording-using-windows-api</id>
    <content type="html"><![CDATA[<p>本文介绍如何使用Windows API来录制语音信号兵保存到wave文件中，主要用到三个结构体和几个wave开头的API函数（在Winmm.lib文件中）。其中三个结构体是WAVEFORMATEX、WAVEHDR、MMTIME，其详细定义都在MMSystem.h中定义，
可以转到定义看其详细内容及每一项的英文注释。用到的API函数的详细用法可以参见MSDN： http://msdn.microsoft.com/en-us/library/windows/desktop/dd743847(v=vs.85).aspx
详细的使用过程请看下文的源代码，这是一个Win32 Application，需要手动添加Winmm.lib的依赖。</p>




<!--more-->




<p>实例程序</p>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// ******************* FileName: WinMain.cpp *****************************
</span><span class='line'>// 该源程序需要加入到 VC6 的 Win32 Application 的 empty Project 中
</span><span class='line'>// 对于工程的 Link 选项，至少要包含以下库: msvcrt.lib Winmm.lib
</span><span class='line'>
</span><span class='line'>#include &lt;stdio.h>
</span><span class='line'>#include &lt;atlstr.h>
</span><span class='line'>#include &lt;windows.h>
</span><span class='line'>#include &lt;Mmsystem.h>
</span><span class='line'>
</span><span class='line'>#pragma comment(lib,"Winmm.lib")
</span><span class='line'>
</span><span class='line'>char lpTemp[256];
</span><span class='line'>
</span><span class='line'>DWORD FCC(LPSTR lpStr)
</span><span class='line'>{
</span><span class='line'>  DWORD Number = lpStr[0] + lpStr[1] *0x100 + lpStr[2] *0x10000 + lpStr[3] *0x1000000 ;
</span><span class='line'>  return Number;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
</span><span class='line'>{
</span><span class='line'>  DWORD datasize = 48000;
</span><span class='line'>    
</span><span class='line'>  // 设置录音采样参数
</span><span class='line'>  WAVEFORMATEX waveformat;
</span><span class='line'>  waveformat.wFormatTag=WAVE_FORMAT_PCM; // 指定录音格式
</span><span class='line'>  waveformat.nChannels=1;
</span><span class='line'>  waveformat.nSamplesPerSec=8000;
</span><span class='line'>  waveformat.nBlockAlign=1;
</span><span class='line'>  waveformat.wBitsPerSample=8;
</span><span class='line'>  waveformat.cbSize=0;
</span><span class='line'>  waveformat.nAvgBytesPerSec=waveformat.nChannels*waveformat.nSamplesPerSec*waveformat.wBitsPerSample/8;
</span><span class='line'>  
</span><span class='line'>  sprintf(lpTemp,"WAVEFORMATEX size = %lu", sizeof(WAVEFORMATEX));
</span><span class='line'>  MessageBox(NULL,CString(lpTemp),CString("提示"),MB_OK);
</span><span class='line'>
</span><span class='line'>  HWAVEIN m_hWaveIn;
</span><span class='line'>  if ( !waveInGetNumDevs() )
</span><span class='line'>  {
</span><span class='line'>      MessageBox(NULL,CString("没有可以使用的 WaveIn 通道"),CString("提示"),MB_OK);
</span><span class='line'>      return 0;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  // 打开录音设备
</span><span class='line'>  int res = waveInOpen(&m_hWaveIn,WAVE_MAPPER, &waveformat, (DWORD)NULL,0L,CALLBACK_WINDOW); 
</span><span class='line'>  if ( res != MMSYSERR_NOERROR )
</span><span class='line'>  {
</span><span class='line'>     sprintf(lpTemp, "打开 waveIn 通道失败，Error_Code = 0x%x", res );
</span><span class='line'>     MessageBox(NULL,CString(lpTemp),CString("提示"),MB_OK);
</span><span class='line'>     return 0;
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  WAVEHDR m_pWaveHdr;
</span><span class='line'>  m_pWaveHdr.lpData = (char *)GlobalLock( GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE, datasize) );
</span><span class='line'>  memset(m_pWaveHdr.lpData, 0, datasize );
</span><span class='line'>  m_pWaveHdr.dwBufferLength = datasize;
</span><span class='line'>  m_pWaveHdr.dwBytesRecorded = 0;
</span><span class='line'>  m_pWaveHdr.dwUser = 0;
</span><span class='line'>  m_pWaveHdr.dwFlags = 0;
</span><span class='line'>  m_pWaveHdr.dwLoops = 0;
</span><span class='line'>  sprintf( lpTemp, "WAVEHDR size = %lu", sizeof(WAVEHDR) );
</span><span class='line'>  MessageBox(NULL,CString(lpTemp),CString("提示"),MB_OK);
</span><span class='line'>
</span><span class='line'>  // 准备内存块录音
</span><span class='line'>  int resPrepare = waveInPrepareHeader( m_hWaveIn, &m_pWaveHdr, sizeof(WAVEHDR) ); 
</span><span class='line'>  if ( resPrepare != MMSYSERR_NOERROR) 
</span><span class='line'>  {
</span><span class='line'>      sprintf(lpTemp, "不能开辟录音头文件，Error_Code = 0x%03X", resPrepare );
</span><span class='line'>      MessageBox(NULL,CString(lpTemp),CString("提示"),MB_OK);
</span><span class='line'>      return 0;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  resPrepare = waveInAddBuffer( m_hWaveIn, &m_pWaveHdr, sizeof(WAVEHDR) );
</span><span class='line'>  if ( resPrepare != MMSYSERR_NOERROR) 
</span><span class='line'>  {
</span><span class='line'>      sprintf(lpTemp, "不能开辟录音用缓冲，Error_Code = 0x%03X", resPrepare );
</span><span class='line'>      MessageBox(NULL,CString(lpTemp),CString("提示"),MB_OK);
</span><span class='line'>      return 0;
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  if (! waveInStart(m_hWaveIn) ) 
</span><span class='line'>  {
</span><span class='line'>      MessageBox(NULL,CString("开始录音"),CString("提示"),MB_OK);
</span><span class='line'>  }
</span><span class='line'>  else 
</span><span class='line'>  {
</span><span class='line'>      MessageBox(NULL,CString("开始录音失败"),CString("提示"),MB_OK);
</span><span class='line'>      return 0;
</span><span class='line'>  }
</span><span class='line'>  Sleep(30000);
</span><span class='line'>
</span><span class='line'>  MMTIME mmt;
</span><span class='line'>  mmt.wType = TIME_BYTES;
</span><span class='line'>  sprintf( lpTemp, "sizeof(MMTIME) = %d, sizeof(UINT) = %d", sizeof(MMTIME), sizeof(UINT) );
</span><span class='line'>  MessageBox(NULL,CString(lpTemp),CString("提示"),MB_OK);
</span><span class='line'>
</span><span class='line'>  if (! waveInGetPosition(m_hWaveIn, &mmt, sizeof(MMTIME)) )
</span><span class='line'>  {
</span><span class='line'>      MessageBox(NULL,CString("取得现在音频位置"),CString("提示"),MB_OK);
</span><span class='line'>  }
</span><span class='line'>  else 
</span><span class='line'>  {
</span><span class='line'>      MessageBox(NULL,CString("不能取得音频长度"),CString("提示"),MB_OK);
</span><span class='line'>      return 0;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  if (mmt.wType != TIME_BYTES) 
</span><span class='line'>  {
</span><span class='line'>      MessageBox(NULL,CString("指定的 TIME_BYTES 格式音频长度不支持"),CString("提示"),MB_OK);
</span><span class='line'>      return 0;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  if (! waveInStop(m_hWaveIn) ) 
</span><span class='line'>  {
</span><span class='line'>      MessageBox(NULL,CString("停止录音"),CString("提示"),MB_OK);
</span><span class='line'>  }
</span><span class='line'>  else  
</span><span class='line'>  {
</span><span class='line'>      MessageBox(NULL,CString("停止录音失败"),CString("提示"),MB_OK);
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  if ( waveInReset(m_hWaveIn) ) 
</span><span class='line'>  {
</span><span class='line'>      MessageBox(NULL,CString("重置内存区失败"),CString("提示"),MB_OK);
</span><span class='line'>      return 0;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  m_pWaveHdr.dwBytesRecorded = mmt.u.cb;
</span><span class='line'>  DWORD NumToWrite=0;
</span><span class='line'>  DWORD dwNumber = 0;
</span><span class='line'>  HANDLE FileHandle = CreateFile( CString("myTest.wav"), GENERIC_WRITE, 
</span><span class='line'>      FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
</span><span class='line'>
</span><span class='line'>  // memset(m_pWaveHdr.lpData, 0, datasize);
</span><span class='line'>  dwNumber = FCC("RIFF");
</span><span class='line'>  WriteFile(FileHandle, &dwNumber, 4, &NumToWrite, NULL);
</span><span class='line'>  dwNumber = m_pWaveHdr.dwBytesRecorded + 18 + 20;
</span><span class='line'>  WriteFile(FileHandle, &dwNumber, 4, &NumToWrite, NULL);
</span><span class='line'>  dwNumber = FCC("WAVE");
</span><span class='line'>  WriteFile(FileHandle, &dwNumber, 4, &NumToWrite, NULL);
</span><span class='line'>  dwNumber = FCC("fmt ");
</span><span class='line'>  WriteFile(FileHandle, &dwNumber, 4, &NumToWrite, NULL);
</span><span class='line'>  dwNumber = 18L;
</span><span class='line'>  WriteFile(FileHandle, &dwNumber, 4, &NumToWrite, NULL);
</span><span class='line'>  WriteFile(FileHandle, &waveformat, sizeof(WAVEFORMATEX), &NumToWrite, NULL);
</span><span class='line'>  dwNumber = FCC("data");
</span><span class='line'>  WriteFile(FileHandle, &dwNumber, 4, &NumToWrite, NULL);
</span><span class='line'>  dwNumber = m_pWaveHdr.dwBytesRecorded;
</span><span class='line'>  WriteFile(FileHandle, &dwNumber, 4, &NumToWrite, NULL);
</span><span class='line'>  WriteFile(FileHandle, m_pWaveHdr.lpData, m_pWaveHdr.dwBytesRecorded, &NumToWrite, NULL);
</span><span class='line'>  SetEndOfFile(FileHandle);
</span><span class='line'>  CloseHandle( FileHandle );  
</span><span class='line'>  FileHandle = INVALID_HANDLE_VALUE; // 收尾关闭句柄
</span><span class='line'>  MessageBox(NULL,CString("应该已生成 myTest.wav 文件"),CString("提示"),MB_OK);
</span><span class='line'>
</span><span class='line'>  if ( waveInUnprepareHeader(m_hWaveIn, &m_pWaveHdr, sizeof(WAVEHDR)) ) 
</span><span class='line'>  {
</span><span class='line'>      MessageBox(NULL,CString("Un_Prepare Header 失败"),CString("提示"),MB_OK);
</span><span class='line'>  }
</span><span class='line'>  else 
</span><span class='line'>  {
</span><span class='line'>      MessageBox(NULL,CString("Un_Prepare Header 成功"),CString("提示"),MB_OK);
</span><span class='line'>      return 0;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  if ( GlobalFree(GlobalHandle( m_pWaveHdr.lpData )) ) 
</span><span class='line'>  {
</span><span class='line'>      MessageBox(NULL,CString("Global Free 失败"),CString("提示"),MB_OK);
</span><span class='line'>  }
</span><span class='line'>  else 
</span><span class='line'>  {
</span><span class='line'>      MessageBox(NULL,CString("Global Free 成功"),CString("提示"),MB_OK);
</span><span class='line'>      return 0;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  if (res == MMSYSERR_NOERROR ) // 关闭录音设备
</span><span class='line'>  {
</span><span class='line'>      if (waveInClose(m_hWaveIn)==MMSYSERR_NOERROR)
</span><span class='line'>      {
</span><span class='line'>          MessageBox(NULL,CString("正常关闭录音设备"),CString("提示"),MB_OK);
</span><span class='line'>      }
</span><span class='line'>      else
</span><span class='line'>      {
</span><span class='line'>          MessageBox(NULL,CString("非正常关闭录音设备"),CString("提示"),MB_OK);
</span><span class='line'>          return 0;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>// ******************* End of File ************************</span></code></pre></td></tr></table></div></figure>




<p>这里提供的代码有点杂乱，现已整理成一个小的接口，并提供了一个简单的示例，放在GitHub上：https://github.com/ibillxia/Demo/tree/master/DemoSpeechRecord</p>




<p>参考：</br>
[1]MSDN: http://msdn.microsoft.com/en-us/library/windows/desktop/dd743586(v=vs.85).aspx</br>
[2]基于API的录音机程序: http://www.vckbase.com/index.php/wv/664
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语音信号处理之时域分析-音高追踪及其Python实现]]></title>
    <link href="http://ibillxia.github.io/blog/2013/05/29/audio-signal-processing-time-domain-pitch-tracking-and-python-realization/"/>
    <updated>2013-05-29T21:37:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/05/29/audio-signal-processing-time-domain-pitch-tracking-and-python-realization</id>
    <content type="html"><![CDATA[<h2>1.概述</h2>


<p>在<a href="http://ibillxia.github.io/blog/2013/05/16/audio-signal-processing-time-domain-pitch-python-realization/">音高及其Python实现</a>一文
中，我们使用了简单的“观察法”来计算音高，这并不太难，但这并不有好而且费时费力，那么我们就想，如何通过分析和计算，使用算法来自动计算音高呢？
用算法让计算机自动抓取音高的过程，称为<b>音高追踪</b>(Pitch Tracking)。所得到的音高信息有如下一些应用：</br>
·旋律识别(Melody Recognition)：或称为“哼唱选歌”，也就是如何由使用者的哼唱，找出音乐资料库中间对应的歌。</br>
·汉语声调识别(Tone Recognition)：辨识使用者讲一句话时，每一个字的声调（一声、二声、三声、四声等）。</br>
·语音合成韵律分析(Prosody Analysis)中的音高分析：如何在合成语音时，使用最自然的音高曲线。</br>
·语音评分中的音调评分(Intonation Assessment)：如何评估使用者说话的语音，其音高曲线是否标准。</br>
·语音识别(Speech Recognition)：我们可以使用语句的音高来提高语音辨识的正确率。</br>
总而言之，音高追踪是语音信号处理中最基本也最重要的一个环节之一。
</p>




<h2>2.音高追踪的基本流程</h2>


<p>音高追踪的基本流程如下：</br>
(1)将整段音讯讯号切成音框（Frames），相邻音框之间可以重叠。</br>
(2)算出每个音框所对应的音高。</br>
(3)排除不稳定的音高值。（可由音量来筛选，或由音高值的范围来过滤。）</br>
(4)对整段音高进行平滑化，通常是使用「中位数滤波器」（Median Filters）。</br>
</p>




<!--more-->




<p>在切音框的过程中，我们允许左右音框的重叠，因此，我们定义「音框率」（Frame Rate）是每秒钟所出现的音框个数，如果取样频率是11025，音框长度是256 点，
重叠点数是84，那么音框率就是11025/(256-84) = 64，换句话说，我们的电脑要能够每秒钟处理64 个音框，才能达到实时处理的要求。如下图所示：
<center><img src="http://ibillxia.github.io/images/2013/IMAG2013052901.png"></center>
</p>




<p>我们让音框重叠的目地，只是希望相邻音框之间的变化不会太大，使抓出来的音高曲线更具有连续性。但是在实际应用时，音框的重叠也不能太大，
否则会造成计算量的过大。一般有以下考虑：</br>
·音框长度至少必须包含2 个基本周期以上，才能显示语音的特性。已知人声的音高范围大约在50 Hz 至1000 Hz 之间，因此对于一个的取样频率，我们就可以计算出
音框长度的最小值。例如，若取样频率fs = 8000 Hz，那么当音高f = 50 Hz（例如男低音的歌声）时，每个基本周期的点数是fs/f = 8000/50 = 160，因此音框必须
至少是320 点；若音高是1000 Hz（例如女高音的歌声）时，每个基本周期的点数是8000/1000 = 8，因此音框必须至少是16 点。</br>
·音框长度也不能太大，太长的音框无法抓到音讯的特性随时间而变化的细微现象，同时计算量也会变大。</br>
·音框之间的重叠完全是看计算机的运算能力来决定，若重叠多，音框率就会变大，计算量就跟着变大。若重叠少（甚至可以不重叠或跳点），音框率就会变小，
计算量也跟着变小。</p>




<h2>3.音高追踪算法</h2>


<h4>3.1概述</h4>


<p>由一个音框计算出音高的方法很多，可以分为时域和频域两大类：</br>
<b>时域（Time Domain）</b></br>
·ACF: Autocorrelation function，自相关函数</br>
·AMDF: Average magnitude difference function，平均强度差分函数</br>
·SIFT: Simple inverse filter tracking</br>
<b>频域（Frequency Domain）</b></br>
·Harmonic product spectrum method</br>
·Cepstrum method</p>




<h4>3.2 ACF自相关函数</h4>


<p>首先，我们来看看ACF(Auto-Correlation Function，自相关函数)的概念。要计算音高，就得找出波形中的周期性，自相关函数的目的就是估算语音信号当前
帧与它的下一帧的相似性，其定义如下：
<center>$acf(\tau) = \sum_{i=0}^{n-1-\tau}s(i)s(i+\tau)$</center>
其中$\tau$是一个延迟的时间间隔。在某个区间使得$acf(\tau)$取得最大值的那个$\tau$值就选为pitch的起止点，如下图所示：
<center><img src="http://ibillxia.github.io/images/2013/IMAG2013052902.png"></center>
也就是说，我们将原始语音信号与其平移延迟信号的重叠（时间上重叠）部分进行内积运算，从而得到ACF。下面看一个具体的实例，其代码如下：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import wave
</span><span class='line'>import numpy as np
</span><span class='line'>import pylab as pl
</span><span class='line'>
</span><span class='line'>def ACF(frame):
</span><span class='line'>    flen = len(frame)
</span><span class='line'>    acf = np.zeros(flen)
</span><span class='line'>    for i in range(flen):
</span><span class='line'>        acf[i] = np.sum(frame[i:flen]*frame[0:flen-i])
</span><span class='line'>    return acf
</span><span class='line'>
</span><span class='line'># ============ test the algorithm =============
</span><span class='line'># read wave file and get parameters.
</span><span class='line'>fw = wave.open('a.wav','rb')
</span><span class='line'>params = fw.getparams()
</span><span class='line'>print(params)
</span><span class='line'>nchannels, sampwidth, framerate, nframes = params[:4]
</span><span class='line'>strData = fw.readframes(nframes)
</span><span class='line'>waveData = np.fromstring(strData, dtype=np.int16)
</span><span class='line'>waveData = waveData*1.0/max(abs(waveData))  # normalization
</span><span class='line'>fw.close()
</span><span class='line'>
</span><span class='line'># plot the wave
</span><span class='line'>time = np.arange(0, len(waveData)) * (1.0 / framerate)
</span><span class='line'>
</span><span class='line'>frameSize = 512
</span><span class='line'>idx1 = 10000
</span><span class='line'>idx2 = idx1+frameSize
</span><span class='line'>index1 = idx1*1.0 / framerate
</span><span class='line'>index2 = idx2*1.0 / framerate
</span><span class='line'>acf = ACF(waveData[idx1:idx2])
</span><span class='line'>#acf[0:10] = -acf[0]
</span><span class='line'>#acfmax = np.argmax(acf)
</span><span class='line'>#print(acfmax)
</span><span class='line'>#print(framerate*1.0/acfmax)
</span><span class='line'>
</span><span class='line'>pl.subplot(311)
</span><span class='line'>pl.plot(time, waveData)
</span><span class='line'>pl.plot([index1,index1],[-1,1],'r')
</span><span class='line'>pl.plot([index2,index2],[-1,1],'r')
</span><span class='line'>pl.xlabel("time (seconds)")
</span><span class='line'>pl.ylabel("Amplitude")
</span><span class='line'>
</span><span class='line'>pl.subplot(312)
</span><span class='line'>pl.plot(np.arange(frameSize),waveData[idx1:idx2],'r')
</span><span class='line'>pl.xlabel("index in 1 frame")
</span><span class='line'>pl.ylabel("Amplitude")
</span><span class='line'>
</span><span class='line'>pl.subplot(313)
</span><span class='line'>pl.plot(np.arange(frameSize),acf,'g')
</span><span class='line'>pl.xlabel("index in 1 frame")
</span><span class='line'>pl.ylabel("ACF")
</span><span class='line'>pl.show()</span></code></pre></td></tr></table></div></figure>

程序运行结果如下图所示：
<center><img src="http://ibillxia.github.io/images/2013/IMAG2013052903.png"></center>
</p>




<p>很显然，ACF的最大值出现在第一点，这一点作为起点在任何情况下都是已知的，我们需要知道是第二个波峰。我们可以将开始的一些点的ACF值设为负无穷（这里我
设为-acf[0]），这样可以找到第二个波峰的index为110（这一点称为pitch point，简称pp），那么对应的pitch为framerate/110 = 16000/110 = 145.455Hz.这个过程取消
程序中第32行起的4行注释即可。这样，我们就初步自动计算出了pitch了。</p>




<p>但是，细心的读者会发现，这里还有一个问题，那就是ACF曲线中前多少个点应该被置为负无穷？为简单起见，设人的pitch的范围为[40,1000](Hz)，那么pp的值应满足为：
$40 < \frac{fs}{pp} < 1000$，从而得到pp的范围：$\frac{fs}{1000} < pp < \frac{fs}{40}$。这样可以部分解决问题，对于某些情况可能结果并不一定正确。</p>

<p>另外还有一些对ACF的改进。一个主要的改进原因是，当$\tau$值变大是，两端信号的重叠部分逐渐变小，这样计算出来的ACF当然越来越小。一种改进是增加一个权值：
<center>$acf(\tau) = \sum_{i=0}^{n-1-\tau} \frac{s(i)s(i+\tau)}{n-\tau}$.</center>
这种方法虽然解决了上面提到的问题，但又引入了一个新的问题，那就是，在$\tau$值较大时，计算出来的acf和pitch的差异可能很大，也即出现了不稳定。另一种改进是，
将$\tau$限制在半帧内，也即：
<center>$acf(\tau) = \sum_{i=0}^{n/2}s(i)s(i+\tau)$.</center>
但这样得到的acf只有一帧的一半，对于音高较低的信号就不利了，这时我们就得增大帧的长度，于是计算量也相应的增加了。</p>

<h4>3.3 NSDF</h4>
<p>ACF的范围是未知的，NSDF(normalized squared difference function)将ACF规整到[-1,1]之间，其定义的表达式如下：
<center>$nsdf(\tau) = \frac{2\sum s(i)s(i+\tau)}{\sum s^{2}(i) + \sum s^{2}(i+\tau)}$.</center>
</p>

<h4>3.4 AMDF</h4>
<p>AMDF (average magnitude difference function) 的定义如下：
<center>$amdf(\tau) = \sum_{i=0}^{n-1-\tau}|s(i)-s(i+\tau)|$.</center>
与ACF相反，这里用距离而不是相似度来计算，所以这里选取pitch point(简称pp)的标准是选最小值对应的index(实际代码中，为了与ACF进行统一，我对AMDF取了相反数)。
相应的，也有一些对AMDF这个函数的修正，如加权值、只是用前半帧等，另外还可以将AMDF与ACF结合，将ACF除以AMDF，得到的结果可以更容易找到pitch point。
</p>

<h4>3.5 Pitch Tracking</h4>
<p>能够正确计算pitch了，我们就可以对一段时序的信号进行pitch tracking了。</p>

<p>PS：另外，还有一些频域的音高追踪方法，将在后续文章中介绍。</p>

<h2>4.参考资料</h2>
<p>[1]Audio Signal Processing and Recognition, Chap 7: http://neural.cs.nthu.edu.tw/jang/books/audiosignalprocessing/index.asp
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[大白鼠听人话]]></title>
    <link href="http://ibillxia.github.io/blog/2013/05/24/cctv-news-rat-understand-what-human-says/"/>
    <updated>2013-05-24T22:59:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/05/24/cctv-news-rat-understand-what-human-says</id>
    <content type="html"><![CDATA[<p>最近一直忙着准备给媒体展示的音控大鼠机器人一不小心上了CCTV了，虽然自己感觉没什么了不起的，也不知道网络上是什么评论。
但既然上了CCTV，还是发博纪念一下吧</p>




<p>央视新闻视频链接：<a href="http://tv.cntv.cn/vodplay/e58c8785e00a4ead9b83dfae5b53f12a/860010-1102010100">浙江杭州最新科研成果：大白鼠听人话</a>
真没想到自己居然正面出境这么长时间。</p>




<p>杭州日报的记者写的新闻还挺生动的：<a href="http://hzdaily.hangzhou.com.cn/hzrb/html/2013-05/24/content_1501396.htm">“嫁接”了机器视觉的大白鼠在沙盘迷宫中寻觅阿汤哥的照片</a></p>




<p>PS：感谢CCTV，感谢杭州日报，感谢ZJU，感谢CCNT，感谢各位老师和同学，感谢生仪的给大鼠做开颅手术的两位mm，感谢各位在微博帮忙宣传和转发的各位同学！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语音信号处理之时域分析-端点检测及Python实现]]></title>
    <link href="http://ibillxia.github.io/blog/2013/05/22/audio-signal-processing-time-domain-Voice-Activity-Detection/"/>
    <updated>2013-05-22T22:22:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/05/22/audio-signal-processing-time-domain-Voice-Activity-Detection</id>
    <content type="html"><![CDATA[<h2>端点检测</h2>


<p>端点检测（End-Point Detection，EPD）的目标是要决定信号的语音开始和结束的位置，所以又可以称为Speech Detection或Voice Activity Detection（VAD）。
端点检测在语音预处理中扮演着一个非常重要的角色。</p>




<p>常见的端点检测方法大致可以分为如下两类：</br>
（1）时域（Time Domain）的方法：计算量比较小，因此比较容易移植到计算能力较差的嵌入式平台</br>
（a）音量：只使用音量来进行端检，是最简单的方法，但是容易对清音造成误判。另外，不同的音量计算方法得到的结果也不尽相同，至于那种方法更好也没有定论。</br>
（b）音量和过零率：以音量为主，过零率为辅，可以对清音进行较精密的检测。</br>
（2）频域（Frequency Domain）的方法：计算量相对较大。</br>
（a）频谱的变化性（Variance）：有声音的频谱变化较规律，可以作为一个判断标准。</br>
（b）频谱的Entropy：有规律的频谱的Entropy一般较小，这也可以作为一个端检的判断标准。
</p>




<p>下面我们分别从这两个方面来探讨端检的具体方法和过程。</p>




<!--more-->




<h2>时域的端检方法</h2>


<p>时域的端检方法分为只用音量的方法和同时使用音量和过零率的方法。只使用音量的方法最简单计算量也最小，我们只需要设定一个音量阈值，任何音量小于该阈值的帧
被认为是静音（silence）。这种方法的关键在于如何选取这个阈值，一种常用的方法是使用一些带标签的数据来训练得到一个阈值，使得误差最小。</p>




<p>下面我们来看看最简单的、不需要训练的方法，其代码如下：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import wave
</span><span class='line'>import numpy as np
</span><span class='line'>import matplotlib.pyplot as plt
</span><span class='line'>import Volume as vp
</span><span class='line'>
</span><span class='line'>def findIndex(vol,thres):
</span><span class='line'>    l = len(vol)
</span><span class='line'>    ii = 0
</span><span class='line'>    index = np.zeros(4,dtype=np.int16)
</span><span class='line'>    for i in range(l-1):
</span><span class='line'>        if((vol[i]-thres)*(vol[i+1]-thres)&lt;0):
</span><span class='line'>            index[ii]=i
</span><span class='line'>            ii = ii+1
</span><span class='line'>    return index[[0,-1]]
</span><span class='line'>
</span><span class='line'>fw = wave.open('sunday.wav','r')
</span><span class='line'>params = fw.getparams()
</span><span class='line'>nchannels, sampwidth, framerate, nframes = params[:4]
</span><span class='line'>strData = fw.readframes(nframes)
</span><span class='line'>waveData = np.fromstring(strData, dtype=np.int16)
</span><span class='line'>waveData = waveData*1.0/max(abs(waveData))  # normalization
</span><span class='line'>fw.close()
</span><span class='line'>
</span><span class='line'>frameSize = 256
</span><span class='line'>overLap = 128
</span><span class='line'>vol = vp.calVolume(waveData,frameSize,overLap)
</span><span class='line'>threshold1 = max(vol)*0.10
</span><span class='line'>threshold2 = min(vol)*10.0
</span><span class='line'>threshold3 = max(vol)*0.05+min(vol)*5.0
</span><span class='line'>
</span><span class='line'>time = np.arange(0,nframes) * (1.0/framerate)
</span><span class='line'>frame = np.arange(0,len(vol)) * (nframes*1.0/len(vol)/framerate)
</span><span class='line'>index1 = findIndex(vol,threshold1)*(nframes*1.0/len(vol)/framerate)
</span><span class='line'>index2 = findIndex(vol,threshold2)*(nframes*1.0/len(vol)/framerate)
</span><span class='line'>index3 = findIndex(vol,threshold3)*(nframes*1.0/len(vol)/framerate)
</span><span class='line'>end = nframes * (1.0/framerate)
</span><span class='line'>
</span><span class='line'>plt.subplot(211)
</span><span class='line'>plt.plot(time,waveData,color="black")
</span><span class='line'>plt.plot([index1,index1],[-1,1],'-r')
</span><span class='line'>plt.plot([index2,index2],[-1,1],'-g')
</span><span class='line'>plt.plot([index3,index3],[-1,1],'-b')
</span><span class='line'>plt.ylabel('Amplitude')
</span><span class='line'>
</span><span class='line'>plt.subplot(212)
</span><span class='line'>plt.plot(frame,vol,color="black")
</span><span class='line'>plt.plot([0,end],[threshold1,threshold1],'-r', label="threshold 1")
</span><span class='line'>plt.plot([0,end],[threshold2,threshold2],'-g', label="threshold 2")
</span><span class='line'>plt.plot([0,end],[threshold3,threshold3],'-b', label="threshold 3")
</span><span class='line'>plt.legend()
</span><span class='line'>plt.ylabel('Volume(absSum)')
</span><span class='line'>plt.xlabel('time(seconds)')
</span><span class='line'>plt.show()</span></code></pre></td></tr></table></div></figure>

其中计算音量的函数calVolume参见<a href="http://ibillxia.github.io/blog/2013/05/15/audio-signal-process-time-domain-volume-python-realization/">
音量及其Python实现</a>一文。程序的运行结果如下图：
<center><img src="http://ibillxia.github.io/images/2013/IMAG2013052201.png"></center>
</p>




<p>这里采用了三种设置阈值的方法，但这几种设置方法对所有的输入都是相同的，对于一些特定的语音数据可能得不到很好的结果，比如杂音较强、清音较多或音量
变化较大等语音信号，此时单一阈值的方法的效果就不太好了，虽然我们可以通过增加帧与帧之间的重叠部分，但相对而言计算量会比较大。下面我们利用一些更多的
特征来进行端点加测，例如使用过零率等信息，其过程如下：</br>
（1）以较高音量阈值($\tau _{u}$)为标准，找到初步的端点；</br>
（2）将端点前后延伸到低音量阈值($\tau _{l}$)处；</br>
（3）再将端点前后延伸到过零率阈值($\tau _{zc}$)处，以包含语音中清音的部分。</br>
这种方法需要确定三个阈值($\tau _{u}$,$\tau _{l}$,$\tau _{zc}$)，可以用各种搜寻方法来调整这三个参数。其示意图(参考[1])如下：
<center><img src="http://ibillxia.github.io/images/2013/IMAG2013052202.png"></center>
我们在同一个图中绘制出音量和过零率的阈值图如下：
<center><img src="http://ibillxia.github.io/images/2013/IMAG2013052203.png"></center>
可以看到我们可以通过过零率的阈值来把错分的清音加入到语音部分来。上图使用到的阈值还是和音量的阈值选取方法相同，比较简单直接。
</p>




<p>另外，我们还可以连续对波形进行微分，再计算音量，这样就可以凸显清音的部分，从而将其正确划分出来，详见参考[1]。</p>




<h2>频域的端检方法</h2>


<p>有声音的信号在频谱上会有重复的谐波结构，因此我们也可以使用频谱的变化性（Variation）或Entropy来进行端点检测，可以参见如下链接：
http://neural.cs.nthu.edu.tw/jang/books/audiosignalprocessing/paper/endPointDetection/</p>




<p>总之，端点检测是语音预处理的重头戏，其实现方法也是五花八门，本文只给出了最简单最原始也最好理解的几种方法，这些方法要真正做到实用，还需要针对一些
特殊的情况在做一些精细的设置和处理，但对于一般的应用场景应该还是基本够用的。</p>




<h2>参考（References）</h2>


<p>
[1]EPD in Time Domain: http://neural.cs.nthu.edu.tw/jang/books/audiosignalprocessing/epdTimeDomain.asp?title=6-2%20EPD%20in%20Time%20Domain</br>
[2]EPD in Frequency Domain: http://neural.cs.nthu.edu.tw/jang/books/audiosignalprocessing/epdFreqDomain.asp?title=6-3%20EPD%20in%20Frequency%20Domain
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语音信号处理之时域分析-音色及其Python实现]]></title>
    <link href="http://ibillxia.github.io/blog/2013/05/18/audio-signal-processing-time-domain-timbre-python-realization/"/>
    <updated>2013-05-18T21:57:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/05/18/audio-signal-processing-time-domain-timbre-python-realization</id>
    <content type="html"><![CDATA[<h2>音色（Timbre）</h2>


<p>音色是一个很模糊的概念，它泛指语音的内容，例如“天书”这两个字的发音，虽然都是一声（即他们的音高应该是相同或接近的），
但由于音色不同，我们可以分辨这两个音。直觉而言，音色的不同，意味着基本波形的不同，因此我们可以用基本周期的波形来代表音色。
</p>




<p>若要从基本周期的波形来直接分析音色是一件很困难的事情。通常我们的做法是将每一个帧进行频谱分析（Spectral Analysis），算出一个
帧如何分解为不同频率的分量，然后才能进行对比或分析。在频谱分析中，最常用的方法就是快速傅里叶变换（Fast Fourier Transform，FFT），
这是一个相当常用的方法，可以讲在时域（Time Domain）的信号转换成频域（Frequency Domain）的信号，并进而知道每个频率的信号强度。</p>




<p>语谱图（Spectrogram）就是语音频谱图，一般是通过处理接收的时域信号得到频谱图，因此只要有足够时间长度的时域信号就可以(时间长度
为保证频率分辨率)。专业点讲，语谱图就是频谱分析视图，如果针对语音数据的话，叫语谱图。语谱图的横坐标是时间，纵坐标是频率，坐标点
值为语音数据能量，因而语谱图很好的表达了语音的音色随时间变化的趋势。有些经验丰富的人能够通过看语谱图而知道对应的语音信号的内容，
这种技术成为Spectrogram Reading。</p>




<!--more-->




<h2>Python绘制语谱图</h2>


<p>如果是用Matlab，绘制语谱图并不难，网上资料也一堆一堆的。但是，如果要想用Python来绘制呢？网上相关资料很少很少，万幸中找到了参考[4]，
但是，[4]中提供的程序是不能运行的，还需要安装几个库，特别是Audiolab这个，折腾了我好半天，最终安装了，但运行时发现这个audiolab根本无法
import进来，因为ms与numpy的版本有冲突，出现了什么“numpy.dtype does not appear to be the correct type object”，弄了好半天也没有解决，
后来才发现其实不需要audiolab也可以的，因为其实audiolab只是读取不同格式（扩展名）的语音文件的一个lib而已，并不涉及到绘制语谱图的东西。</p>




<p>
闲话少说了，上代码吧，其实看看这代码也挺简单的，就调一个matplotlib.pyplot.specgram()就可以了。

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import wave
</span><span class='line'>import numpy as np
</span><span class='line'>import matplotlib.pyplot as plt
</span><span class='line'>
</span><span class='line'>fw = wave.open('aeiou.wav','r')
</span><span class='line'>soundInfo = fw.readframes(-1)
</span><span class='line'>soundInfo = np.fromstring(soundInfo,np.int16)
</span><span class='line'>f = fw.getframerate()
</span><span class='line'>fw.close()
</span><span class='line'>
</span><span class='line'>plt.subplot(211)
</span><span class='line'>plt.plot(soundInfo)
</span><span class='line'>plt.ylabel('Amplitude')
</span><span class='line'>plt.title('Wave from and spectrogram of aeiou.wav')
</span><span class='line'>
</span><span class='line'>plt.subplot(212)
</span><span class='line'>plt.specgram(soundInfo,Fs = f, scale_by_freq = True, sides = 'default')
</span><span class='line'>plt.ylabel('Frequency')
</span><span class='line'>plt.xlabel('time(seconds)')
</span><span class='line'>plt.show()</span></code></pre></td></tr></table></div></figure>

</p>




<p>程序运行的效果如下图：
<center><img src="http://ibillxia.github.io/images/2013/IMAG2013051801.png"></center>
虽然程序简单，但还有一些小bug，比如subplot(212)的xlabel和ylabel无法显示，这个问题暂时还没有解决。（更新：这个问题已解决，把mpp.show()放到
最后一行就可以了，顺便图也更新了）</p>




<p>另外，就是关于这个语谱图具体是如何绘制的，这一点涉及到FFT和短时能量的计算，短时能量在<a href="">前文中</a>
已经讲过了，这里不再赘述。关于FFT将在后续文章中讨论。</p>




<h2>参考（References）</h2>


<p>
[1]Timbre (音色): http://neural.cs.nthu.edu.tw/jang/books/audiosignalprocessing/basicFeatureTimber.asp?title=5-5</br>
[2]Wiki - 音色: http://zh.wikipedia.org/wiki/音色</br>
[3]语谱图： http://blog.csdn.net/wuxiaoer717/article/details/6941339</br>
[4]How to plot spectrogram with Python：http://jaganadhg.freeflux.net/blog/archive/2009/07/23/how-to-plot-spectrogram-with-python.html
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语音信号处理之时域分析-音高及其Python实现]]></title>
    <link href="http://ibillxia.github.io/blog/2013/05/16/audio-signal-processing-time-domain-pitch-python-realization/"/>
    <updated>2013-05-16T23:10:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/05/16/audio-signal-processing-time-domain-pitch-python-realization</id>
    <content type="html"><![CDATA[<h2>音高（Pitch）</h2>


<p>概念：音高（Pitch）是语音信号的一个很重要的特征，直觉上而言它表示声音频率的高低，这个频率是指基本频率（基频），也即基本周期的倒数。
若直接观察语音的波形，只要语音信号稳定，我们可以很容易的看出基本周期的存在。例如我们取一个包含256个采样点的帧，单独绘制波形图，就可以明显的
看到它的基本周期。如下图所示：
<center><img src="http://ibillxia.github.io/images/2013/IMAG2013051601.png"></center>
其中最上面的波形为|a|的发音，中间的为上图中红色双竖线（位于语音区）所对应的帧的具体波形，而最下面的是上图中绿色双竖线（位于静音区）所
对应的帧的具体波形。很容易看到中间的波形具有明显的周期性。
</p>


<!--more-->


<p>其代码如下：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import wave
</span><span class='line'>import numpy as np
</span><span class='line'>import pylab as pl
</span><span class='line'>
</span><span class='line'># ============ test the algorithm =============
</span><span class='line'># read wave file and get parameters.
</span><span class='line'>fw = wave.open('a.wav','rb')
</span><span class='line'>params = fw.getparams()
</span><span class='line'>print(params)
</span><span class='line'>nchannels, sampwidth, framerate, nframes = params[:4]
</span><span class='line'>strData = fw.readframes(nframes)
</span><span class='line'>waveData = np.fromstring(strData, dtype=np.int16)
</span><span class='line'>waveData = waveData*1.0/max(abs(waveData))  # normalization
</span><span class='line'>fw.close()
</span><span class='line'>
</span><span class='line'># plot the wave
</span><span class='line'>time = np.arange(0, len(waveData)) * (1.0 / framerate)
</span><span class='line'>
</span><span class='line'>index1 = 10000.0 / framerate
</span><span class='line'>index2 = 10512.0 / framerate
</span><span class='line'>index3 = 15000.0 / framerate
</span><span class='line'>index4 = 15512.0 / framerate
</span><span class='line'>
</span><span class='line'>pl.subplot(311)
</span><span class='line'>pl.plot(time, waveData)
</span><span class='line'>pl.plot([index1,index1],[-1,1],'r')
</span><span class='line'>pl.plot([index2,index2],[-1,1],'r')
</span><span class='line'>pl.plot([index3,index3],[-1,1],'g')
</span><span class='line'>pl.plot([index4,index4],[-1,1],'g')
</span><span class='line'>pl.xlabel("time (seconds)")
</span><span class='line'>pl.ylabel("Amplitude")
</span><span class='line'>
</span><span class='line'>pl.subplot(312)
</span><span class='line'>pl.plot(np.arange(512),waveData[10000:10512],'r')
</span><span class='line'>pl.plot([59,59],[-1,1],'b')
</span><span class='line'>pl.plot([169,169],[-1,1],'b')
</span><span class='line'>print(1/( (169-59)*1.0/framerate ))
</span><span class='line'>pl.xlabel("index in 1 frame")
</span><span class='line'>pl.ylabel("Amplitude")
</span><span class='line'>
</span><span class='line'>pl.subplot(313)
</span><span class='line'>pl.plot(np.arange(512),waveData[15000:15512],'g')
</span><span class='line'>pl.xlabel("index in 1 frame")
</span><span class='line'>pl.ylabel("Amplitude")
</span><span class='line'>pl.show()</span></code></pre></td></tr></table></div></figure>

</p>




<p>根据参考[1]，可以通过观察一帧的波形图来计算基音频率（感觉这种方法有点奇葩，不过很直观。例如这里的基频为：1/( (169-59)*1.0/framerate )=145.45Hz），
然后还可以计算半音（semitone，可以参见[2]），进而得到pitch与semitone的关系。[1]中还提到了钢琴的半音差，DS表示完全看不懂啊，有木有！！！</p>




<p>参考[2]中还简单介绍了如何改变音高、扩展音域，以及如何改变乐器的振动的弦的音高（通过改变弦长、张力、密度等），感兴趣的可以看看。</p>




<p>另外，由于生理结构的差异，男女性的音高范围不尽相同，一般而言：</br>
·男性的音高范围是35~72半音，对应的频率范围是62~523Hz；</br>
·女性的音高范围是45~83半音，对应的频率范围是110~1000Hz。</br>
然而，我们分辨男女的声音并不是只根据音高，还要根据音色（也即共振峰，下一篇文章中将详细介绍）。
</p>




<p>关于音高的计算，目前有很多种算法，具体将会在后续文章中详细介绍。</p>




<h2>参考（References）</h2>


<p>
[1]Pitch (音高): http://neural.cs.nthu.edu.tw/jang/books/audiosignalprocessing/basicFeaturePitch.asp</br>
[2]Wiki： http://zh.wikipedia.org/wiki/音高
</p>

]]></content>
  </entry>
  
</feed>
